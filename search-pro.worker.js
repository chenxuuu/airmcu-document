const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":258,\"nextId\":258,\"documentIds\":{\"0\":\"v-2ffffada\",\"1\":\"v-2ffffada#使用-vscode-的crotex-debug插件\",\"2\":\"v-2ffffada#先决条件\",\"3\":\"v-2ffffada#vscode-的配置\",\"4\":\"v-2ffffada#安装插件\",\"5\":\"v-2ffffada#安装-pyocd\",\"6\":\"v-2ffffada#建立工程\",\"7\":\"v-2ffffada#调试配置\",\"8\":\"v-2ee6af9a\",\"9\":\"v-2ee6af9a#快速开始\",\"10\":\"v-43642281\",\"11\":\"v-43642281#关于\",\"12\":\"v-43642281#文档结构\",\"13\":\"v-43642281#格式要求\",\"14\":\"v-5cfe713d\",\"15\":\"v-5cfe713d#如何贡献\",\"16\":\"v-5cfe713d#前置要求\",\"17\":\"v-5cfe713d#pr-请求流程\",\"18\":\"v-5cfe713d#贡献流程\",\"19\":\"v-7d9ee880\",\"20\":\"v-7d9ee880#arduino-ide-的安装\",\"21\":\"v-7d9ee880#windows下exe版本安装\",\"22\":\"v-7d9ee880#windows下zip版本安装\",\"23\":\"v-7d9ee880#修改语言\",\"24\":\"v-7d9ee880#安装-airmcu-支持包\",\"25\":\"v-7d9ee880#添加开发板地址\",\"26\":\"v-7d9ee880#安装开发板\",\"27\":\"v-e220f13c\",\"28\":\"v-e220f13c#支持芯片\",\"29\":\"v-e220f13c#arduino-核心参考\",\"30\":\"v-e220f13c#支持的操作系统\",\"31\":\"v-e220f13c#相关支持\",\"32\":\"v-e220f13c#问题报告\",\"33\":\"v-79606c06\",\"34\":\"v-79606c06#adc-通用-api\",\"35\":\"v-79606c06#analogread\",\"36\":\"v-79606c06#analogreference\",\"37\":\"v-79606c06#airmcu-专用-api\",\"38\":\"v-79606c06#analogreadresolution\",\"39\":\"v-79606c06#analogreadmillivolts\",\"40\":\"v-79606c06#analogreadtempsensor\",\"41\":\"v-79606c06#analogreadvref\",\"42\":\"v-07e7fdec\",\"43\":\"v-07e7fdec#简介\",\"44\":\"v-07e7fdec#api\",\"45\":\"v-07e7fdec#read\",\"46\":\"v-07e7fdec#示例\",\"47\":\"v-07e7fdec#write\",\"48\":\"v-07e7fdec#示例-1\",\"49\":\"v-07e7fdec#update\",\"50\":\"v-07e7fdec#示例-2\",\"51\":\"v-07e7fdec#get\",\"52\":\"v-07e7fdec#示例-3\",\"53\":\"v-07e7fdec#put\",\"54\":\"v-07e7fdec#示例-4\",\"55\":\"v-07e7fdec#eeprom\",\"56\":\"v-07e7fdec#示例-5\",\"57\":\"v-07e7fdec#length\",\"58\":\"v-9820ff86\",\"59\":\"v-9820ff86#about\",\"60\":\"v-9820ff86#gpio-模式\",\"61\":\"v-9820ff86#gpio-api\",\"62\":\"v-9820ff86#pinmode\",\"63\":\"v-9820ff86#内部上拉和下拉\",\"64\":\"v-9820ff86#digitalwrite\",\"65\":\"v-9820ff86#digitalread\",\"66\":\"v-9820ff86#interrupts-中断\",\"67\":\"v-9820ff86#attachinterrupt\",\"68\":\"v-9820ff86#detachinterrupt\",\"69\":\"v-9820ff86#示例代码\",\"70\":\"v-9820ff86#gpio-输入和输出模式\",\"71\":\"v-9820ff86#gpio-中断\",\"72\":\"v-6372404c\",\"73\":\"v-6372404c#关于\",\"74\":\"v-6372404c#i2c-模式\",\"75\":\"v-6372404c#i2c-通用-api\",\"76\":\"v-6372404c#begin\",\"77\":\"v-6372404c#setsda\",\"78\":\"v-6372404c#setscl\",\"79\":\"v-6372404c#setclock\",\"80\":\"v-6372404c#write\",\"81\":\"v-6372404c#end\",\"82\":\"v-6372404c#i2c-主模式\",\"83\":\"v-6372404c#基本用法\",\"84\":\"v-6372404c#i2c-主机-api\",\"85\":\"v-6372404c#begin-1\",\"86\":\"v-6372404c#begintransmission\",\"87\":\"v-6372404c#endtransmission\",\"88\":\"v-6372404c#requestfrom\",\"89\":\"v-6372404c#示例应用程序\",\"90\":\"v-6372404c#i2c-从机模式\",\"91\":\"v-6372404c#基本用法-1\",\"92\":\"v-6372404c#i2c-从机-api\",\"93\":\"v-6372404c#begin-2\",\"94\":\"v-6372404c#onreceive\",\"95\":\"v-6372404c#onrequest\",\"96\":\"v-6372404c#示例应用程序-1\",\"97\":\"v-6372404c#进阶用法\",\"98\":\"v-6372404c#默认-i2c-引脚\",\"99\":\"v-6372404c#重新定义i2c引脚\",\"100\":\"v-6372404c#i2c-缓冲区管理\",\"101\":\"v-e48e2dc0\",\"102\":\"v-e48e2dc0#pwm-通用-api\",\"103\":\"v-e48e2dc0#analogwrite\",\"104\":\"v-e48e2dc0#airmcu-专用-api\",\"105\":\"v-e48e2dc0#analogwritefrequency\",\"106\":\"v-e48e2dc0#analogwriteresolution\",\"107\":\"v-09c55ccd\",\"108\":\"v-09c55ccd#支持的外设\",\"109\":\"v-09c55ccd#apis\",\"110\":\"v-09c55ccd#datasheet\",\"111\":\"v-4c3d6e7a\",\"112\":\"v-4c3d6e7a#关于\",\"113\":\"v-4c3d6e7a#arduino-api-参考\",\"114\":\"v-4c3d6e7a#airmcu-专用api\",\"115\":\"v-4c3d6e7a#spiclass-spiclass-uint8-t-mosi-uint8-t-miso-uint8-t-sclk-uint8-t-ssel\",\"116\":\"v-4c3d6e7a#void-spiclass-begin-uint8-t-pin\",\"117\":\"v-4c3d6e7a#void-begintransaction-uint8-t-pin-spisettings-settings\",\"118\":\"v-4c3d6e7a#void-endtransaction-uint8-t-pin\",\"119\":\"v-4c3d6e7a#byte-transfer-uint8-t-pin-uint8-t-data-spitransfermode-mode-spi-last\",\"120\":\"v-4c3d6e7a#uint16-t-transfer16-uint8-t-pin-uint16-t-data-spitransfermode-mode-spi-last\",\"121\":\"v-4c3d6e7a#void-transfer-uint8-t-pin-void-buf-size-t-count-spitransfermode-mode-spi-last\",\"122\":\"v-4c3d6e7a#void-transfer-byte-pin-void-bufout-void-bufin-size-t-count-spitransfermode-mode-spi-last\",\"123\":\"v-4c3d6e7a#例子\",\"124\":\"v-4c3d6e7a#更改默认-spi-实例引脚\",\"125\":\"v-23357d41\",\"126\":\"v-23357d41#api接口\",\"127\":\"v-23357d41#使用方式\",\"128\":\"v-c3c77cc4\",\"129\":\"v-c3c77cc4#关于\",\"130\":\"v-c3c77cc4#uart-通用api\",\"131\":\"v-c3c77cc4#begin\",\"132\":\"v-c3c77cc4#end\",\"133\":\"v-c3c77cc4#available\",\"134\":\"v-c3c77cc4#read\",\"135\":\"v-c3c77cc4#write\",\"136\":\"v-c3c77cc4#flush\",\"137\":\"v-c3c77cc4#peek\",\"138\":\"v-c3c77cc4#airmcu-专用api\",\"139\":\"v-c3c77cc4#更改默认-serial-实例引脚\",\"140\":\"v-c3c77cc4#启用半双工模式\",\"141\":\"v-c3c77cc4#启用硬件流控制\",\"142\":\"v-69a3e260\",\"143\":\"v-69a3e260#问题描述\",\"144\":\"v-69a3e260#问题原因\",\"145\":\"v-69a3e260#解决方案\",\"146\":\"v-69a3e260#新建一个不带中文路径的文件夹\",\"147\":\"v-69a3e260#迁移当前的包文件\",\"148\":\"v-69a3e260#更改配置文件中的包文件路径\",\"149\":\"v-69a3e260#使用\",\"150\":\"v-05b37edb\",\"151\":\"v-05b37edb#为什么烧录到一半就显示失败\",\"152\":\"v-05b37edb#为什么烧录提示无法进入boot模式\",\"153\":\"v-6e9c7c90\",\"154\":\"v-6e9c7c90#连上开发板\",\"155\":\"v-6e9c7c90#添加代码\",\"156\":\"v-6e9c7c90#编译下载\",\"157\":\"v-6e9c7c90#查看串口输出\",\"158\":\"v-e0186346\",\"159\":\"v-e0186346#安装开发板\",\"160\":\"v-e0186346#选择开发板\",\"161\":\"v-e0186346#添加代码\",\"162\":\"v-e0186346#编译下载\",\"163\":\"v-e0186346#查看效果\",\"164\":\"v-a836b422\",\"165\":\"v-a836b422#简介\",\"166\":\"v-a836b422#硬件准备\",\"167\":\"v-a836b422#软件部分\",\"168\":\"v-a836b422#输出结果\",\"169\":\"v-261792c2\",\"170\":\"v-261792c2#简介\",\"171\":\"v-261792c2#硬件准备\",\"172\":\"v-261792c2#软件部分\",\"173\":\"v-261792c2#输出结果\",\"174\":\"v-b9e1bb36\",\"175\":\"v-b9e1bb36#简介\",\"176\":\"v-b9e1bb36#硬件准备\",\"177\":\"v-b9e1bb36#软件部分\",\"178\":\"v-b9e1bb36#输出结果\",\"179\":\"v-15213f90\",\"180\":\"v-15213f90#简介\",\"181\":\"v-15213f90#硬件准备\",\"182\":\"v-15213f90#软件部分\",\"183\":\"v-15213f90#输出结果\",\"184\":\"v-15213f90#进一步优化\",\"185\":\"v-15213f90#优化后的结果\",\"186\":\"v-592ca764\",\"187\":\"v-592ca764#简介\",\"188\":\"v-592ca764#硬件准备\",\"189\":\"v-592ca764#软件部分\",\"190\":\"v-592ca764#更进一步\",\"191\":\"v-1d57cf08\",\"192\":\"v-1d57cf08#简介\",\"193\":\"v-1d57cf08#硬件准备\",\"194\":\"v-1d57cf08#软件部分\",\"195\":\"v-1d57cf08#输出结果\",\"196\":\"v-42dd3c58\",\"197\":\"v-42dd3c58#简介\",\"198\":\"v-42dd3c58#硬件准备\",\"199\":\"v-42dd3c58#软件部分\",\"200\":\"v-42dd3c58#输出结果\",\"201\":\"v-40b42f53\",\"202\":\"v-40b42f53#简介\",\"203\":\"v-40b42f53#硬件准备\",\"204\":\"v-40b42f53#软件部分\",\"205\":\"v-40b42f53#输出结果\",\"206\":\"v-255a8b83\",\"207\":\"v-255a8b83#简介\",\"208\":\"v-255a8b83#硬件准备\",\"209\":\"v-255a8b83#软件部分\",\"210\":\"v-255a8b83#输出结果\",\"211\":\"v-7715cbc0\",\"212\":\"v-7715cbc0#简介\",\"213\":\"v-7715cbc0#硬件准备\",\"214\":\"v-7715cbc0#软件部分\",\"215\":\"v-7715cbc0#输出结果\",\"216\":\"v-6574c13e\",\"217\":\"v-6574c13e#简介\",\"218\":\"v-6574c13e#硬件准备\",\"219\":\"v-6574c13e#软件部分\",\"220\":\"v-6574c13e#输出结果\",\"221\":\"v-5d22f180\",\"222\":\"v-5d22f180#简介\",\"223\":\"v-5d22f180#硬件准备\",\"224\":\"v-5d22f180#软件部分\",\"225\":\"v-5d22f180#输出结果\",\"226\":\"v-4c0d303e\",\"227\":\"v-4c0d303e#t-trace\",\"228\":\"v-4c0d303e#connect-attempts-次数\",\"229\":\"v-4c0d303e#before-default-reset-direct-connect\",\"230\":\"v-4c0d303e#after-default-reset-direct-connect\",\"231\":\"v-4c0d303e#环境变量\",\"232\":\"v-4c0d303e#eng-lang\",\"233\":\"v-7985d8e6\",\"234\":\"v-7985d8e6#c-chip-目标芯片型号\",\"235\":\"v-7985d8e6#p-port-串口名称\",\"236\":\"v-7985d8e6#b-baud-串口波特率\",\"237\":\"v-e4be9d74\",\"238\":\"v-e4be9d74#chip-id\",\"239\":\"v-e4be9d74#get\",\"240\":\"v-e4be9d74#get-version\",\"241\":\"v-e4be9d74#write-flash-芯片flash地址-固件文件\",\"242\":\"v-e4be9d74#write-flash-命令参数\",\"243\":\"v-e4be9d74#read-unprotect\",\"244\":\"v-e4be9d74#read-protect\",\"245\":\"v-e4be9d74#read-flash-芯片flash地址-读取长度-固件文件\",\"246\":\"v-e4be9d74#read-flash-命令参数\",\"247\":\"v-d1a7873a\",\"248\":\"v-d1a7873a#write-flash-命令参数\",\"249\":\"v-7aec6318\",\"250\":\"v-a7f9168e\",\"251\":\"v-a7f9168e#解除读保护\",\"252\":\"v-a7f9168e#启用读保护\",\"253\":\"v-45ac1154\",\"254\":\"v-74379e72\",\"255\":\"v-c481d952\",\"256\":\"v-6d5ae094\",\"257\":\"v-4523b40c\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2],\"1\":[6],\"2\":[1,17],\"3\":[2],\"4\":[1,17],\"5\":[2,21],\"6\":[1,47],\"7\":[1,77],\"8\":[2,10],\"9\":[1,123],\"10\":[1,2],\"11\":[1,8],\"12\":[1,57],\"13\":[1,45],\"14\":[1,4],\"15\":[1,14],\"16\":[1,31],\"17\":[2,15],\"18\":[1,7],\"19\":[1,4],\"20\":[3,18],\"21\":[1,28],\"22\":[1,20],\"23\":[1,12],\"24\":[3],\"25\":[1,27],\"26\":[1,10],\"27\":[2,11],\"28\":[1,18],\"29\":[2,13],\"30\":[1,8],\"31\":[1,6],\"32\":[1,14],\"33\":[1,23],\"34\":[3],\"35\":[1,34],\"36\":[1,12],\"37\":[3],\"38\":[1,16],\"39\":[1,10],\"40\":[1,8],\"41\":[1,8],\"42\":[1],\"43\":[1,19],\"44\":[1,6],\"45\":[2,11],\"46\":[1,27],\"47\":[2,11],\"48\":[1,17],\"49\":[2,12],\"50\":[1,35],\"51\":[2,16],\"52\":[1,77],\"53\":[2,24],\"54\":[1,92],\"55\":[2,14],\"56\":[1,24],\"57\":[2,9],\"58\":[1],\"59\":[1,17],\"60\":[2,17],\"61\":[2,4],\"62\":[1,24],\"63\":[1,12],\"64\":[1,24],\"65\":[1,18],\"66\":[3,5],\"67\":[1,25],\"68\":[1,11],\"69\":[1],\"70\":[2,23],\"71\":[2,24],\"72\":[1],\"73\":[1,44],\"74\":[2,11],\"75\":[3,2],\"76\":[1,7],\"77\":[1,12],\"78\":[1,18],\"79\":[1,9],\"80\":[1,12],\"81\":[1,11],\"82\":[2,2],\"83\":[2,53],\"84\":[3,6],\"85\":[1,15],\"86\":[1,13],\"87\":[1,21],\"88\":[1,27],\"89\":[1,59],\"90\":[2,2],\"91\":[1,31],\"92\":[3],\"93\":[1,18],\"94\":[1,9],\"95\":[1,9],\"96\":[1,82],\"97\":[1,32],\"98\":[3,49],\"99\":[1,14],\"100\":[2,39],\"101\":[1,10],\"102\":[3],\"103\":[1,12],\"104\":[3],\"105\":[1,18],\"106\":[1,15],\"107\":[1],\"108\":[1,26],\"109\":[1,5],\"110\":[1,7],\"111\":[1],\"112\":[1,36],\"113\":[3,3],\"114\":[2,23],\"115\":[8,25],\"116\":[7,9],\"117\":[8,14],\"118\":[6,34],\"119\":[12,18],\"120\":[12,18],\"121\":[14,22],\"122\":[15,25],\"123\":[1,50],\"124\":[3,23],\"125\":[1,46],\"126\":[1,183],\"127\":[1,312],\"128\":[1],\"129\":[1,11],\"130\":[2,10],\"131\":[1,30],\"132\":[1,4],\"133\":[1,5],\"134\":[1,8],\"135\":[1,16],\"136\":[1,4],\"137\":[1,9],\"138\":[2,101],\"139\":[3,18],\"140\":[1,61],\"141\":[1,24],\"142\":[1],\"143\":[1,8],\"144\":[1,2],\"145\":[1,7],\"146\":[1,11],\"147\":[1,13],\"148\":[1,35],\"149\":[1,19],\"150\":[1],\"151\":[1,1],\"152\":[1,3],\"153\":[1],\"154\":[1,14],\"155\":[1,44],\"156\":[1,3],\"157\":[1,7],\"158\":[3,2],\"159\":[1,13],\"160\":[1,6],\"161\":[1,47],\"162\":[1,12],\"163\":[1,4],\"164\":[2],\"165\":[1,7],\"166\":[1,19],\"167\":[1,36],\"168\":[1,4],\"169\":[2],\"170\":[1,13],\"171\":[1,16],\"172\":[1,60],\"173\":[1,4],\"174\":[2],\"175\":[1,19],\"176\":[1,20],\"177\":[1,78],\"178\":[1,10],\"179\":[1],\"180\":[1,4],\"181\":[1,11],\"182\":[1,60],\"183\":[1,21],\"184\":[1,95],\"185\":[1,5],\"186\":[1],\"187\":[1,1],\"188\":[1,10],\"189\":[1,42],\"190\":[1,16],\"191\":[2],\"192\":[1,8],\"193\":[1,41],\"194\":[1,121],\"195\":[1,4],\"196\":[1],\"197\":[1,11],\"198\":[1,18],\"199\":[1,44],\"200\":[1,1],\"201\":[2],\"202\":[1,4],\"203\":[1,20],\"204\":[1,89],\"205\":[1,4],\"206\":[2],\"207\":[1,6],\"208\":[1,29],\"209\":[1,94],\"210\":[1,2],\"211\":[2],\"212\":[1,4],\"213\":[1,26],\"214\":[1,169],\"215\":[1,7],\"216\":[2],\"217\":[1,7],\"218\":[1,15],\"219\":[1,69],\"220\":[1,3],\"221\":[2],\"222\":[1,16],\"223\":[1,31],\"224\":[1,134],\"225\":[1,3],\"226\":[1],\"227\":[3,5],\"228\":[4,4],\"229\":[5,27],\"230\":[5,15],\"231\":[1],\"232\":[2,5],\"233\":[1,4],\"234\":[4,9],\"235\":[4,5],\"236\":[4,5],\"237\":[1],\"238\":[2,2],\"239\":[1,4],\"240\":[2,4],\"241\":[4,6],\"242\":[3,16],\"243\":[2,6],\"244\":[2,6],\"245\":[5,6],\"246\":[3,12],\"247\":[1,53],\"248\":[3,19],\"249\":[1,89],\"250\":[1],\"251\":[1,37],\"252\":[1,35],\"253\":[1],\"254\":[3],\"255\":[2],\"256\":[2],\"257\":[1]},\"averageFieldLength\":[1.7286821705426356,24.264128955807596],\"storedFields\":{\"0\":{\"h\":\"AirMCU 的调试方法\"},\"1\":{\"h\":\"使用 VSCode 的 Crotex-Debug 插件\"},\"2\":{\"h\":\"先决条件\",\"t\":[\"安装 VSCode\",\"有一个支持的调试器，可以是 JLink，ST-Link，CMSIS-DAP 等，这里我们使用 DAPLink 作为例子\",\"安装 AirMCU 的 SDK\",\"安装PyOCD\"]},\"3\":{\"h\":\"VSCode 的配置\"},\"4\":{\"h\":\"安装插件\",\"t\":[\"在 VSCode 的插件市场中搜索Cortex-Debug，或者在https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug安装即可。\",\"同样，搜索 Arduino，安装Arduino插件。\"]},\"5\":{\"h\":\"安装 PyOCD\",\"t\":[\"安装 PyOCD 比较简单，在拥有 Python 环境的情况下，直接输入\",\"pip install --pre -U git+https://github.com/pyocd/pyOCD.git@develop \",\"命令安装最新版的 develop 分支的即可。\"]},\"6\":{\"h\":\"建立工程\",\"t\":[\"不管是新建一个工程还是用之前老的工程都行，这里我们以新建工程为例。\",\"点击F1按钮，输入Arduino: Initialize\",\"这里输入文件名，需要注意的是，这个文件名必须和父目录的名字一样，我们这里就修改为Air001DebugTest.ino。\",\"芯片型号我们以Air001 Dev Chip为例。\",\"建立完成之后，我们随便写一些测试代码，例如：\",\"void setup() { Serial.begin(115200); pinMode(PB0, OUTPUT); Serial.println(\\\"Hello World!\\\"); } void loop() { digitalWrite(PB0, HIGH); delay(1000); digitalWrite(PB0, LOW); delay(1000); } \",\"对于 Arduino Board Configuration，我们选择如下的配置：\",\"切记，Debug symbols and logs 选项中一定要选择有带-g的选项，这样才能生成调试符号。\"]},\"7\":{\"h\":\"调试配置\",\"t\":[\"在自动生成的.vscode/arduino.json文件中，我们需要添加一个属性output，这样才能获得编译出来的文件，一个典型的配置如下：\",\"{ \\\"sketch\\\": \\\"Air001DebugTest.ino\\\", \\\"configuration\\\": \\\"UploadSpeed=115200,ClockSourceAndFrequency=HSI24M_HCLK48M,LowSpeedClockSource=None,xserial=generic,dbg=enable_sym,opt=osstd,SupplyVoltage=3V3,BootConnection=defaule\\\", \\\"board\\\": \\\"AirM2M:AirMCU:Air001Dev\\\", \\\"output\\\": \\\"build\\\" } \",\"然后，我们点击上方的Upload按钮，编译并上传代码。\",\"接下来，我们需要配置调试器，点击F1按钮，输入Debug: Add uration，然后选择Cortex-Debug。\",\"这样，在.vscode文件夹下就会自动生成一个launch.json文件。\",\"我们需要修改其中的serverpath属性为pyocd\",\"添加一个armToolchainPath属性，该属性的含义是一个arm-none-eabi-gcc套件的地址，需要注意的是其中需要包含 gbd，我们这里可以直接使用 AirMCU sdk 自带的，\",\"添加targetId属性，属性的值为 pyocd 的 target 的 Part Number，我们这里使用Air001。\",\"修改executable属性，属性的值为编译出来的 elf 文件的地址，我们这里使用${workspaceRoot}/build/Air001DebugTest.ino.elf。\",\"修改runToEntryPoint属性，该属性为调试时自动运行到入口点，我们这里设置为setup。\",\"最后，我们点击 vscode 左边的运行与调试图标，或者是直接按F5，就可以开始调试了。\",\"享受调试的乐趣吧！\"]},\"8\":{\"h\":\"AirISP 烧录工具\",\"t\":[\"AirISP 是一个通过串口与芯片ISP功能进行交互，从而实现擦除、烧录、修改读保护等功能的一个小工具。\",\"它使用.NET6进行编写，支持跨平台。可以在GitHub上获取该项目的源码。\"]},\"9\":{\"h\":\"快速开始\",\"t\":[\"前往GitHub Release页面下载最新版本的AirISP工具。\",\"Arch 包管理安装\",\"Arch Linux 及其衍生版可以安装 AUR airisp-git。\",\"注：命令行名称按 Arch Linux 规范应该是小写，安装后命令行为：airisp。\",\"yay -Syu airisp \",\"解压或安装后可以得到 AirISP：\",\"> .\\\\AirISP -h Description: AirISP 是一个flash烧录工具 Usage: AirISP [command] [options] Options: -c, --chip <chip> 目标芯片型号，auto/air001 -p, --port <port> 串口名称 -b, --baud <baud> 串口波特率 -t, --trace 启用trace日志输出 [default: False] --connect-attempts <connect-attempts> 最大重试次数，小于等于0表示无限次，默认为10次 [default: 10] --before <before> 下载前要执行的操作 [default: default_reset] --after <after> 下载后要执行的操作 [default: hard_reset] --version Show version information -?, -h, --help Show help and usage information Commands: chip_id 获取芯片ID get 获取ISP版本和支持的命令列表 get_version 获取ISP版本和芯片读保护状态 write_flash <address> <filename> 向flash刷入固件 read_unprotect 关闭读保护 read_protect 开启读保护 \",\"我们可以使用该工具为芯片进行烧录，比如下面这样：\",\"> .\\\\AirISP.exe -c air001 -p COM21 -b 115200 write_flash -e 0x08000000 gpio.hex AirISP v1.2.4.0 串口 COM21 连接中... Chip PID is: 0x04 0x40 擦除flash中（请耐心等待）... 擦除成功，耗时 39.5811 ms. Writing at 134219264... 100.00% Write 1536 bytes at 0x08000000 in 274.0526 ms Leaving... 通过RTS硬件复位... \",\"更多信息请见其他章节内容\"]},\"10\":{\"h\":\"文档编写规范\",\"t\":[\"我们欢迎任何关于文档的新贡献！\"]},\"11\":{\"h\":\"关于\",\"t\":[\"AirMCU 有一个专用于文档的仓库，位于GitHub中。该文档使用了VuePress进行配置，并使用了VuePress Theme Hope作为主题。\"]},\"12\":{\"h\":\"文档结构\",\"t\":[\". ├── .github → GitHub 配置文件存放路径 │ └── workflow → GitHub 工作流配置 │ └── docs-deploy.yml → 自动部署文档的工作流 │ ├── docs → 文档文件夹 │ │ │ ├── .vuepress → VuePress 配置文件夹 │ │ │ │ │ ├── dist → 构建输出目录 │ │ │ │ │ ├── public → 静态资源目录 │ │ │ │ │ ├── styles → 用于存放样式相关的文件 │ │ │ │ │ ├── config.{js,ts} → 配置文件的入口文件 │ │ │ │ │ └── client.{js,ts} → 客户端文件 │ │ │ ├── ContributionsGuide → 贡献指南 │ │ │ ├── FAQ → 常见问题 │ │ │ ├── getting_started → 快速开始 │ │ │ ├── library → API参考 │ │ │ ├── tutorial-advanced → 进阶教程 │ │ │ ├── tutorial-extras → 应用示例 │ │ │ └── README.md → 项目主页 │ └── package.json → Nodejs 配置文件 \",\"其中，每个文件夹下的README.md和index.md将被作为主页，而其余的.md文档将被添加二级目录。\"]},\"13\":{\"h\":\"格式要求\",\"t\":[\"每篇文档的头部应当加上一个 icon 提高美观度，icon 名称可以在 fontawesome v4 图标列表找到。\",\"文档排版需要合理，参考https://theme-hope.vuejs.press/zh/guide/markdown/的附加组件和语法，其余参考 Markdown 标准语法。\",\"所有图片添加前都要经过此网站的压缩，减小文件体积。\",\"为了观察方便，英文与汉字之间需要添加空格，例如例子 example 例子。\",\"句末需要加上中文句号。。\",\"一般习惯上来说，我们应当把图片或者静态资源放在.vuepress/public下，但是为了方便编写，我们也可以把图片放在相应文档目录下的img文件夹下，例如docs/getting_started/img。\",\"每篇文档的头部类似如下的写法：\",\"--- title: 标题 order: 文章的顺序序列号 icon: 图标名 --- \"]},\"14\":{\"h\":\"贡献指南\",\"t\":[\"我们欢迎为 AirMCU 项目做出任何贡献！\"]},\"15\":{\"h\":\"如何贡献\",\"t\":[\"欢迎对 AirMCU 做出贡献（修复错误、添加功能、添加文档）。我们通过 Github Pull Requests （后文中我们将其称之为“PR”） 接受贡献。\"]},\"16\":{\"h\":\"前置要求\",\"t\":[\"在向我们发送 PR 请求之前，请考虑以下事项：\",\"该贡献完全是您自己的作品吗？还是已经根据 LGPL 2.1 兼容的开源许可证获得了许可？如果没有，那我们将无法接受。\",\"代码是否有足够的注释并且人们可以理解它的结构吗？\",\"是否有与代码贡献相关的文档或示例？\",\"注释和文档是否用清晰的英语或者中文编写，没有拼写或语法错误？\",\"也欢迎提供示例贡献。\",\"如果您通过添加新示例进行贡献，请使用 Arduino 风格指南和下面的示例指南。\",\"如果贡献包含多个提交，它们是否被归类为逻辑变更（每个拉取请求一个主要变更）？是否有名称为“修正了拼写错误”的提交被挤压到之前的提交中？\",\"如果您对上述任何一点不确定，都可以开启一个新的PR，然后向我们寻求帮助。\"]},\"17\":{\"h\":\"PR 请求流程\",\"t\":[\"打开 PR 后，请求本身的注释栏中可能会有一些讨论。\",\"一旦拉取请求准备好合并，它将首先被合并到我们的内部 git 系统中进行 \\\"内部 \\\"自动测试。\",\"如果测试通过，它将被合并到 GitHub 公共仓库。\"]},\"18\":{\"h\":\"贡献流程\",\"t\":[\"如果是有关 AirMCU 文档部分，请参考文档贡献指南\",\"如果是有关核心库部分，请参考下面的流程：<>\"]},\"19\":{\"h\":\"安装\",\"t\":[\"此文档旨在介绍关于 AirMCU 的相关安装方式。\"]},\"20\":{\"h\":\"Arduino IDE 的安装\",\"t\":[\"Arduino IDE支持Windows、Mac OS X及Linux等平台，下载地址为Software > Arduino，本文仅介绍Windows下的安装方式，其他系统大同小异，请读者自行研究，接下来针对两种方式分别介绍如何安装。\",\"提示\",\"Windows系统下的IDE有EXE安装版和ZIP压缩包免安装版。EXE安装版需要按步骤安装，ZIP压缩包免安装版解压后即可使用（但不会在桌面建立IDE启动图标），后者无须管理员权限也可运行使用。\"]},\"21\":{\"h\":\"Windows下exe版本安装\",\"t\":[\"在Software > Arduino可以获取最新的IDE目前版本是2.10，点击如图所示的区域，下载exe版本安装包。\",\"提示\",\"注：现在大部分电脑都是64位因此可以直接下载最新版本，对于32位的电脑可以在页面下翻，选择老版本进行下载安装。\",\"image-20230609164109637\",\"选择JUST DOWNLOAD仅下载，根据网速等待片刻即可下载完成。\",\"image-20230609164252675\",\"双击安装包进行安装，点击我同意。\",\"image-20230609164821984\",\"仅为自己安装即可。\",\"image-20230609164900031\",\"默认安装位置不用动，直接点击安装，稍等一会就可以安装好了。\",\"image-20230609164926761\",\"最后点击完成即可。\",\"image-20230609165202809\"]},\"22\":{\"h\":\"windows下zip版本安装\",\"t\":[\"在Software > Arduino可以获取最新的IDE目前版本是2.10，点击如图所示的区域，下载zip版本免安装包。\",\"提示\",\"注：现在大部分电脑都是64位因此可以直接下载最新版本，对于32位的电脑可以在页面下翻，选择老版本进行下载安装。\",\"image-20230612140840851\",\"下载完成以后直接解压即可，双击解压后的文件夹中的Arduino_IDE.exe即可运行。为了方便日后使用，可以右键添加到开始菜单或者在桌面创建快捷方式。\",\"image-20230617205905523\"]},\"23\":{\"h\":\"修改语言\",\"t\":[\"首次安装默认语言为英文，可以点击File/Preference。\",\"image-20230612140357459\",\"在Language选项卡下拉，选择语言为中文（简体）。点击右下角OK，IDE将自动重启，语言将切换为中文。\",\"image-20230612140452011\"]},\"24\":{\"h\":\"安装 AirMCU 支持包\"},\"25\":{\"h\":\"添加开发板地址\",\"t\":[\"点击Arduino IDE左上角的文件-首选项\",\"1\",\"在其它开发板管理器地址中输入AirMCU的地址：\",\"https://arduino.luatos.com/package_air_cn_index.json \",\"提示\",\"海外用户可以使用这个：\",\"https://github.com/Air-duino/Arduino-pack-json-ci/releases/download/Nightly/package_air_index.json \",\"2\",\"3\"]},\"26\":{\"h\":\"安装开发板\",\"t\":[\"在开发板管理器中搜索Air MCU\",\"4\",\"安装最新版即可\",\"提示\",\"安装过程需要安装多个工具链，可能会稍慢，请耐心等待\",\"接下来可以继续查看下一章节，进行开发测试\"]},\"27\":{\"h\":\"关于 AirMCU\",\"t\":[\"AirMCU 是一个由社区推动，旨在适配上海合宙通信有限公司的 Arm-Cortex 系列 MCU 的 Arduino 框架。\"]},\"28\":{\"h\":\"支持芯片\",\"t\":[\"目前我们支持的 MCU 如下：\",\"MCU 系列\",\"是否支持\",\"详细链接\",\"Air001\",\"✅\",\"https://air001.cn\",\"Air32F103\",\"✅\",\"https://air32.cn\",\"Air401\",\"✅\",\"https://air401.cn\",\"有关开发板的更多资料，请查看所述链接中的开发板内容。\"]},\"29\":{\"h\":\"Arduino 核心参考\",\"t\":[\"本文档基于 AirMCU，兼容官方的 Arduino API，同时也可以调用芯片专用的接口如HAL库。\",\"提示\",\"AirMCU特有的接口，可以参考左侧的 API 参考，余下的接口，可以参考 Arduino 官方文档\"]},\"30\":{\"h\":\"支持的操作系统\",\"t\":[\"系统\",\"包\",\"编译器\",\"烧录工具\",\"Windows\",\"✅\",\"✅\",\"✅\",\"Linux\",\"✅\",\"✅\",\"✅\",\"MacOS\",\"✅\",\"✅\",\"✅\"]},\"31\":{\"h\":\"相关支持\",\"t\":[\"这是一个开放项目，由 Air-duino 社区支持。\"]},\"32\":{\"h\":\"问题报告\",\"t\":[\"提示\",\"提交前请务必在 Issue 列表中提前搜索，这可以避免在 GitHub 问题报告中重复或产生不必要的噪音。 我们还提供常见问题指南，以节省您解决常见问题的时间。\",\"上报新的问题或框架中的错误，请前往问题模板。\",\"如果您有任何新想法或者功能建议，请前往功能请求模板。\"]},\"33\":{\"h\":\"ADC\",\"t\":[\"ADC ，即analog to digital converter（模数转换器）是一种非常常见的外设，用于将电压等模拟信号转换为数字形式，以便微控制器可以读取和处理。\",\"ADC 在控制和监控应用中非常有用，因为大多数传感器（例如温度、压力、力）都会产生模拟输出电压。\",\"注\",\"每个 MCU 或模块都有不同数量的 ADC，以及不同数量的可用通道和引脚。有关详细信息，请参阅每个板的数据手册。\"]},\"34\":{\"h\":\"ADC 通用 API\"},\"35\":{\"h\":\"analogRead\",\"t\":[\"此函数用于获取给定引脚/ADC 通道的 ADC 原始值。\",\"uint32_t analogRead(uint32_t pin); \",\"pin GPIO 引脚或 ADC 通道。\",\"ADC的内部通道可以为ATEMP (内部温度传感器)、AVBAT (VBAT电压)、AVREF (内部参考电压)。\",\"该函数将返回模拟原始值。\",\"读取内部通道时需要最小 ADC 采样时间，因此默认将其设置为最大可能值。它可以通过定义更精确地定义：\",\"ADC_SAMPLINGTIME_INTERNAL 到所需的 ADC 采样时间。\",\"ADC_SAMPLINGTIME 和 ADC_CLOCK_DIV 也可以通过变体或使用 build_opt.h 重新定义。\"]},\"36\":{\"h\":\"analogReference\",\"t\":[\"配置模拟输入所用的基准电压（即用作输入范围上限的值）。保留此功能只是为了与现有的基于 AVR 的 API 兼容。\",\"void analogReference(eAnalogReference ulMode) ; \"]},\"37\":{\"h\":\"AirMCU 专用 API\"},\"38\":{\"h\":\"analogReadResolution\",\"t\":[\"此函数用于设置 ADC 读取的分辨率。默认为 10 位（范围为 0 至 1023）。\",\"void analogReadResolution(uint8_t bits); \"]},\"39\":{\"h\":\"analogReadMillivolts\",\"t\":[\"此函数用于获取给定引脚上的实际电压值（单位为毫伏）。\",\"uint32_t analogReadMillivolts(uint32_t ulPin); \",\"ulPin GPIO 引脚\",\"该函数将返回模拟电压值。\"]},\"40\":{\"h\":\"analogReadTempSensor\",\"t\":[\"此函数用于获取内部温度传感器的实际温度值（单位为摄氏度）。\",\"uint32_t analogReadTempSensor(void); \",\"该函数将返回模拟温度值。\"]},\"41\":{\"h\":\"analogReadVref\",\"t\":[\"此函数用于获取内部参考电压的实际电压值（单位为毫伏）。\",\"uint32_t analogReadVref(void); \",\"该函数将返回模拟电压值。\"]},\"42\":{\"h\":\"EEPROM\"},\"43\":{\"h\":\"简介\",\"t\":[\"EEPROM 是一种存储器，其值在电路板断电时保留。在 AirMCU 中，没有内置的 EEPROM，但是可以使用 Flash 模拟 EEPROM。一般来说，我们采用内置 flash 的最后一个 page 扇区（或者是其它可擦写的最小单位）来模拟。\"]},\"44\":{\"h\":\"API\",\"t\":[\"要使用此库，请在代码顶部包含头文件：\",\"#include <EEPROM.h> \"]},\"45\":{\"h\":\"read()\",\"t\":[\"从 EEPROM 读取一个字节。\",\"EEPROM.read(address) \",\"address：要读取的地址，从 0 开始。\",\"返回值：读取的字节。\"]},\"46\":{\"h\":\"示例\",\"t\":[\"#include <EEPROM.h> int a = 0; int value; void setup() { Serial.begin(9600); } void loop() { value = EEPROM.read(a); Serial.print(a); Serial.print(\\\"\\\\t\\\"); Serial.print(value); Serial.println(); a = a + 1; if (a == 512) a = 0; delay(500); } \"]},\"47\":{\"h\":\"write()\",\"t\":[\"将一个字节写入 EEPROM。\",\"EEPROM.write(address, value) \",\"address：要写入的地址，从 0 开始。\",\"value：要写入的值。\"]},\"48\":{\"h\":\"示例\",\"t\":[\"#include <EEPROM.h> void setup() { for (int i = 0; i < 255; i++) EEPROM.write(i, i); } void loop() { } \"]},\"49\":{\"h\":\"update()\",\"t\":[\"将一个字节写入 EEPROM，但仅在值不同的情况下才写入。\",\"EEPROM.update(address, value) \",\"address：要写入的地址，从 0 开始。\",\"value：要写入的值。\"]},\"50\":{\"h\":\"示例\",\"t\":[\"#include <EEPROM.h> void setup() { for (int i = 0; i < 255; i++) { // this performs as EEPROM.write(i, i) EEPROM.update(i, i); } for (int i = 0; i < 255; i++) { // write value \\\"12\\\" to cell 3 only the first time // will not write the cell the remaining 254 times EEPROM.update(3, 12); } } void loop() { } \"]},\"51\":{\"h\":\"get()\",\"t\":[\"从 EEPROM 读取一个值。\",\"EEPROM.get(address, value) \",\"address：要读取的地址，从 0 开始。\",\"value要读取的数据，可以是原始类型（例如 float）或自定义结构。\",\"返回值：对传入数据的引用\"]},\"52\":{\"h\":\"示例\",\"t\":[\"#include <EEPROM.h> struct MyObject{ float field1; byte field2; char name[10]; }; void setup(){ float f = 0.00f; //Variable to store data read from EEPROM. int eeAddress = 0; //EEPROM address to start reading from Serial.begin( 9600 ); while (!Serial) { ; // wait for serial port to connect. Needed for Leonardo only } Serial.print( \\\"Read float from EEPROM: \\\" ); //Get the float data from the EEPROM at position 'eeAddress' EEPROM.get( eeAddress, f ); Serial.println( f, 3 ); //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float. // get() can be used with custom structures too. eeAddress = sizeof(float); //Move address to the next byte after float 'f'. MyObject customVar; //Variable to store custom object read from EEPROM. EEPROM.get( eeAddress, customVar ); Serial.println( \\\"Read custom object from EEPROM: \\\" ); Serial.println( customVar.field1 ); Serial.println( customVar.field2 ); Serial.println( customVar.name ); } void loop(){ /* Empty loop */ } \"]},\"53\":{\"h\":\"put()\",\"t\":[\"将一个值写入 EEPROM。\",\"EEPROM.put(address, value) \",\"address：要写入的地址，从 0 开始。\",\"value要写入的数据，可以是原始类型（例如 float）或自定义结构。\",\"返回值：对传入数据的引用\",\"注\",\"注意：此函数使用 EEPROM.update() 执行写入，因此如果值没有更改，则不会重写该值。\"]},\"54\":{\"h\":\"示例\",\"t\":[\"#include <EEPROM.h> struct MyObject { float field1; byte field2; char name[10]; }; void setup() { Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } float f = 123.456f; //Variable to store in EEPROM. int eeAddress = 0; //Location we want the data to be put. //One simple call, with the address first and the object second. EEPROM.put(eeAddress, f); Serial.println(\\\"Written float data type!\\\"); /** Put is designed for use with custom structures also. **/ //Data to store. MyObject customVar = { 3.14f, 65, \\\"Working!\\\" }; eeAddress += sizeof(float); //Move address to the next byte after float 'f'. EEPROM.put(eeAddress, customVar); Serial.print(\\\"Written custom data type! \\\\n\\\\nView the example sketch eeprom_get to see how you can retrieve the values!\\\"); } void loop() { /* Empty loop */ } \"]},\"55\":{\"h\":\"EEPROM[]\",\"t\":[\"EEPROM[] 是一个重载了EEPROM类的operator[]运算符，可以像数组一样使用。\",\"该运算符允许像数组一样使用标识符。使用这种方法可以直接读写 EEPROM 单元。\",\"EEPROM[address] \",\"address：要读取的地址，从 0 开始。\",\"返回值：EEPROM 自身的引用\"]},\"56\":{\"h\":\"示例\",\"t\":[\"#include <EEPROM.h> void setup(){ unsigned char val; //Read first EEPROM cell. val = EEPROM[ 0 ]; //Write first EEPROM cell. EEPROM[ 0 ] = val; //Compare contents if( val == EEPROM[ 0 ] ){ //Do something... } } void loop(){ /* Empty loop */ } \"]},\"57\":{\"h\":\"length()\",\"t\":[\"该函数返回一个无符号整数，其中包含 EEPROM 中的单元数。\",\"EEPROM.length() \",\"返回值：EEPROM 中的单元数。类型为unsigned int。\"]},\"58\":{\"h\":\"GPIO\"},\"59\":{\"h\":\"About\",\"t\":[\"GPIO 是微控制器中最常用和通用的外设之一。 GPIO 通常用于写入和读取引脚状态。\",\"GPIO代表通用输入输出，负责控制或读取数字世界中特定引脚的状态。例如，该外设广泛用于创建 LED 闪烁或读取简单的按钮。\",\"注\",\"有些 GPIO 有特殊限制，并非所有 GPIO 都可以通过开发板访问。欲了解更多信息，请参阅相应的板引脚布局信息。\"]},\"60\":{\"h\":\"GPIO 模式\",\"t\":[\"GPIO 配置有两种不同的模式：\",\"Input Mode （输入模式）\",\"在此模式下，GPIO 将从特定设备接收数字状态。该设备可以是按钮或开关。\",\"Output Mode （输出模式）\",\"对于输出模式，GPIO 会将 GPIO 数字状态更改为特定设备。例如，您可以驱动 LED。\"]},\"61\":{\"h\":\"GPIO API\",\"t\":[\"以下是 GPIO 外设的常用函数。\"]},\"62\":{\"h\":\"pinMode\",\"t\":[\"pinMode 函数用于定义特定引脚的GPIO操作模式。\",\"void pinMode(uint32_t ulPin, uint32_t ulMode) \",\"ulPin：要配置的引脚号。\",\"ulMode：要设置的模式。可以是以下值之一：\",\"INPUT：输入模式。\",\"OUTPUT：输出模式。\",\"INPUT_PULLUP：输入模式，但是在引脚上启用内部上拉电阻。\",\"INPUT_PULLDOWN：输入模式，但是在引脚上启用内部下拉电阻。\",\"INPUT_ANALOG：模拟输入模式。\",\"OUTPUT_OPEN_DRAIN：输出模式，但是在引脚上启用开漏输出。\"]},\"63\":{\"h\":\"内部上拉和下拉\",\"t\":[\"AirMCU 系列通过内部大约 40k 电阻支持内部上拉和下拉，可在将 GPIO 模式配置为 INPUT 模式时启用。如果未定义上拉或下拉模式，引脚将保持在高阻抗模式。\"]},\"64\":{\"h\":\"digitalWrite\",\"t\":[\"函数 digitalWrite 将所选 GPIO 的状态设置为 HIGH 或 LOW 。仅当 pinMode 配置为 OUTPUT 时才使用此函数。\",\"void digitalWrite(uint32_t ulPin, uint32_t ulVal) \",\"ulPin：要配置的引脚号。\",\"ulVal：要设置的值。可以是以下值之一：\",\"HIGH：将引脚状态设置为高电平。\",\"LOW：将引脚状态设置为低电平。\"]},\"65\":{\"h\":\"digitalRead\",\"t\":[\"要读取配置为 INPUT 的给定引脚的状态，请使用函数 digitalRead。\",\"int digitalRead(uint32_t ulPin) \",\"ulPin：要配置的引脚号。\",\"返回值：引脚状态。可以是以下值之一：\",\"HIGH：引脚状态为高电平。\",\"LOW：引脚状态为低电平。\"]},\"66\":{\"h\":\"Interrupts （中断）\",\"t\":[\"AirMCU 上的 GPIO 外设支持中断。\"]},\"67\":{\"h\":\"attachInterrupt\",\"t\":[\"函数 attachInterrupt 用于将中断附加到定义的引脚。\",\"void attachInterrupt(uint32_t pin, callback_function_t callback, uint32_t mode) \",\"pin：要配置的引脚号。\",\"callback：中断回调函数。\",\"mode：中断触发模式。可以是以下值之一：\",\"CHANGE：引脚状态发生变化时触发中断。\",\"RISING：引脚状态从低电平变为高电平时触发中断。\",\"FALLING：引脚状态从高电平变为低电平时触发中断。\",\"LOW：引脚状态为低电平时触发中断。\",\"HIGH：引脚状态为高电平时触发中断。\"]},\"68\":{\"h\":\"detachInterrupt\",\"t\":[\"要从特定引脚分离中断，请使用 detachInterrupt 函数来分离 GPIO。\",\"void detachInterrupt(uint32_t channel) \",\"channel：要分离的引脚号。\"]},\"69\":{\"h\":\"示例代码\"},\"70\":{\"h\":\"GPIO 输入和输出模式\",\"t\":[\"const auto ledPin = PB0; const auto BUTTON = PF4; uint8_t stateLED = 0; void setup() { pinMode(ledPin, OUTPUT); pinMode(BUTTON,INPUT_PULLUP); } void loop() { if(!digitalRead(BUTTON)) { stateLED = stateLED^1; digitalWrite(ledPin,stateLED); } } \"]},\"71\":{\"h\":\"GPIO 中断\",\"t\":[\"const auto ledPin = PB0; const auto interruptPin = PF4; volatile byte state = LOW; void setup() { pinMode(ledPin, OUTPUT); pinMode(interruptPin, INPUT_PULLDOWN); attachInterrupt(digitalPinToInterrupt(interruptPin), blink, CHANGE); } void loop() { digitalWrite(ledPin, state); } void blink() { state = !state; } \"]},\"72\":{\"h\":\"I2C\"},\"73\":{\"h\":\"关于\",\"t\":[\"I2C（Inter-Integrated Circuit）/TWI（Two-wire Interface）是一种广泛使用的串行通信，用于短距离连接设备。这是用于连接传感器、EEPROM、RTC、ADC、DAC、显示器、OLED 以及许多其他设备和微控制器的最常见外设之一。\",\"这种串行通信被视为低速总线，多个设备可以连接在同一条两线总线上，每个设备都有一个唯一的 7 位地址（最多 128 个设备）。这两根线称为SDA（串行数据线）和SCL（串行时钟线）。\",\"注\",\"SDA 和SCL 线需要上拉电阻。有关电阻值和工作电压的更多详细信息，请参阅器件数据表。\",\"AirMCU I2C 库基于 Arduino Wire 库，并实现了更多 API，如本文档中所述。\"]},\"74\":{\"h\":\"I2C 模式\",\"t\":[\"I2C 可用于两种不同的模式：\",\"主模式\",\"在此模式下，AirMCU 生成时钟信号并发起与从设备的通信。\",\"从模式\",\"从机模式，时钟由主设备产生，如果目的地址与目的设备相同则响应主设备。\"]},\"75\":{\"h\":\"I2C 通用 API\",\"t\":[\"以下是主模式和从模式下使用的常用功能。\"]},\"76\":{\"h\":\"begin\",\"t\":[\"该函数用于使用默认配置启动外设。\",\"bool begin(); \",\"如果外设正确初始化，此函数将返回 true 。\"]},\"77\":{\"h\":\"setSDA\",\"t\":[\"该函数用于设置 SDA 引脚。\",\"void setSDA(uint32_t pin); \",\"pin：SDA 引脚。\",\"或者\",\"void setSDA(PinName sda) \"]},\"78\":{\"h\":\"setSCL\",\"t\":[\"该函数用于设置 SCL 引脚。\",\"void setSCL(uint32_t pin); \",\"pin：SCL 引脚。\",\"或者\",\"void setSCL(PinName scl) \",\"注意\",\"setSDA 和 setSCL 函数必须在 begin 函数之前调用。\"]},\"79\":{\"h\":\"setClock\",\"t\":[\"该函数用于设置 I2C 时钟频率。\",\"void setClock(uint32_t frequency); \",\"frequency：I2C 时钟频率。\"]},\"80\":{\"h\":\"write\",\"t\":[\"该函数将数据写入缓冲区。\",\"size_t write(uint8_t data); \",\"data：要写入的数据。\",\"或者\",\"size_t write(const uint8_t *data, size_t len); \",\"data：要写入的数据。\",\"len：要写入的数据数量。\"]},\"81\":{\"h\":\"end\",\"t\":[\"该函数用于停止 I2C 通信。\",\"void end(); \",\"调用 end 后，您需要再次使用 begin 以再次初始化I2C驱动程序。\"]},\"82\":{\"h\":\"I2C 主模式\",\"t\":[\"该模式用于启动与从机的通信。\"]},\"83\":{\"h\":\"基本用法：\",\"t\":[\"要开始在 Arduino 上使用 I2C 主模式，第一步是将 Wire.h 头文件引入到你的代码中。\",\"#include <Wire.h> \",\"现在，我们可以通过调用 begin 函数来开始外设配置。\",\"Wire.begin(); \",\"通过使用不带任何参数的 begin ，所有设置都将使用默认值完成。如需自行设置值，请参阅函数说明。\",\"调用 begin 后，我们可以通过调用 beginTransmission 并传递 I2C 从机地址来开始传输：\",\"Wire.beginTransmission(address); \",\"要将一些字节写入从设备，请使用 write 函数。\",\"Wire.write(data); \",\"您可以使用 write 函数传递不同的数据类型。\",\"要结束传输，请使用 endTransmission 函数。\",\"注\",\"write 函数不会直接写入从设备，而是添加到I2C缓冲区。为此，您需要使用 endTransmission 函数将缓冲的字节发送到从设备。\",\"Wire.endTransmission(); \",\"调用 endTransmission 后，I2C缓冲区中存储的数据将被传输到从设备。\",\"现在您可以请求从从设备读取数据。 requestFrom 将要求通过提供地址和大小来读取所选设备的数据。\",\"Wire.requestFrom(I2C_DEV_ADDR, SIZE); \",\"readBytes 将读取它。\",\"Wire.readBytes(temp, error); \"]},\"84\":{\"h\":\"I2C 主机 API\",\"t\":[\"以下是 I2C 主机 API。这些功能仅用于主模式。\"]},\"85\":{\"h\":\"begin\",\"t\":[\"您可以使用不带任何参数的 begin 函数来使用所有默认值。\",\"bool begin(); \",\"或者，您可以指定您使用的 SDA 和 SCL 引脚。\",\"bool begin(uint32_t sda, uint32_t scl); \"]},\"86\":{\"h\":\"beginTransmission\",\"t\":[\"该函数用于启动 I2C 传输。\",\"void beginTransmission(uint8_t address); \",\"该函数用于启动与从设备的通信过程。在将消息写入缓冲区之前，通过传递从属 address 来调用此函数。\"]},\"87\":{\"h\":\"endTransmission\",\"t\":[\"使用i2c write写入缓冲区后，使用函数 endTransmission 将消息发送到 beginTransmission 函数上定义的从设备地址。\",\"uint8_t endTransmission(bool stopBit = true); \",\"stopBit：如果为 true ，则发送停止位。\",\"在没有 sendStop 的情况下调用此函数相当于 sendStop = true 。\",\"uint8_t endTransmission(void); \",\"该函数将返回错误代码。\"]},\"88\":{\"h\":\"requestFrom\",\"t\":[\"要从从设备读取，请使用 requestFrom 函数。\",\"uint8_t requestFrom(uint8_t address, uint8_t quantity, uint32_t iaddress, uint8_t isize, uint8_t sendStop) \",\"address：从设备地址。\",\"quantity：要读取的字节数。\",\"iaddress：内部地址。\",\"isize：内部地址大小。\",\"sendStop：如果为 true ，则发送停止位。\",\"或者，您可以使用\",\"uint8_t requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop) \",\"此函数将调用 requestFrom ，并将 iaddress 和 isize 设置为 0 。\",\"或者，您可以使用\",\"uint8_t requestFrom(uint8_t address, uint8_t quantity) \",\"此函数将调用 requestFrom ，并将 iaddress 和 isize 设置为 0 ，并将 sendStop 设置为 true 。\"]},\"89\":{\"h\":\"示例应用程序\",\"t\":[\"以下是如何在主模式下使用 I2C 的示例。\",\"#include \\\"Wire.h\\\" #define I2C_DEV_ADDR 0x55 uint32_t i = 0; void setup() { Serial.begin(115200); Serial.setDebugOutput(true); Wire.begin(); } void loop() { delay(5000); //Write message to the slave Wire.beginTransmission(I2C_DEV_ADDR); Wire.printf(\\\"Hello World! %u\\\", i++); uint8_t error = Wire.endTransmission(true); Serial.printf(\\\"endTransmission: %u\\\\n\\\", error); //Read 16 bytes from the slave uint8_t bytesReceived = Wire.requestFrom(I2C_DEV_ADDR, 16); Serial.printf(\\\"requestFrom: %u\\\\n\\\", bytesReceived); if((bool)bytesReceived){ //If received more than zero bytes uint8_t temp[bytesReceived]; Wire.readBytes(temp, bytesReceived); log_print_buf(temp, bytesReceived); } } \"]},\"90\":{\"h\":\"I2C 从机模式\",\"t\":[\"该模式用于接受来自主机的通信。\"]},\"91\":{\"h\":\"基本用法\",\"t\":[\"要开始在 Arduino 上使用 I2C 作为从模式，第一步是将 Wire.h 头文件引入到你的代码中。\",\"#include <Wire.h> \",\"在调用 begin 之前，我们必须创建两个回调函数来处理与主设备的通信。\",\"Wire.onReceive(onReceive); \",\"和\",\"Wire.onRequest(onRequest); \",\"onReceive 将根据从属设备读取请求处理来自主设备的请求， onRequest 将处理对主设备的应答。\",\"现在，我们可以通过使用设备地址调用 begin 函数来开始外设配置。\",\"Wire.begin(I2C_DEV_ADDR); \",\"通过使用不带任何参数的 begin ，所有设置都将使用默认值完成。如需自行设置值，请参阅函数说明。\"]},\"92\":{\"h\":\"I2C 从机 API\"},\"93\":{\"h\":\"begin\",\"t\":[\"在从机模式下，必须通过传递从机地址来使用 begin 函数。\",\"void TwoWire::begin(uint8_t address, bool generalCall, bool NoStretchMode) \",\"address：从机地址。\",\"generalCall：如果为 true ，则启用广播地址。\",\"NoStretchMode：如果为 true ，则禁用时钟拉伸。\"]},\"94\":{\"h\":\"onReceive\",\"t\":[\"onReceive 函数用于定义从主机接收到的数据的回调。\",\"void onReceive(cb_function_receive_t callback); \"]},\"95\":{\"h\":\"onRequest\",\"t\":[\"onRequest 函数用于定义要发送到主机的数据的回调。\",\"void onRequest(cb_function_request_t callback); \"]},\"96\":{\"h\":\"示例应用程序\",\"t\":[\"以下是如何在从模式下使用 I2C 的示例。\",\"#include <Wire.h> #define I2C_ADDR 2 void setup() { Wire.begin(I2C_ADDR); // join i2c bus with address #4 Wire.onRequest(requestEvent); // register event Wire.onReceive(receiveEvent); // register event Serial.begin(9600); // start serial for output } void loop() { //empty loop } // function that executes whenever data is received from master // this function is registered as an event, see setup() void receiveEvent(int howMany) { while(1 < Wire.available()) // loop through all but the last { char c = Wire.read(); // receive byte as a character Serial.print(c); // print the character } int x = Wire.read(); // receive byte as an integer Serial.println(x); // print the integer } // function that executes whenever data is requested by master // this function is registered as an event, see setup() void requestEvent() { Wire.write(\\\"hello\\\\n\\\"); // respond with message of 6 bytes // as expected by master } \"]},\"97\":{\"h\":\"进阶用法\",\"t\":[\"默认情况下，只有一个 Wire 实例可用，它使用了默认的I2C引脚，具体可以参考开发板的手册。要使用第二个 I2C 端口，应在代码中在 setup() 函数之前声明 TwoWire 对象：\",\"#include <Wire.h> TwoWire Wire2(SDA_PIN, SCL_PIN); void setup() { Wire2.begin(); } void loop() { Wire2.beginTransmission(0x71); Wire2.write('v'); Wire2.endTransmission(); delay(1000); } \"]},\"98\":{\"h\":\"默认 I2C 引脚\",\"t\":[\"默认 I2C 接口引脚在 PeripheralPins.c 文件中配置。\",\"示例（对于文件 PeripheralPins.c 中的 AIR001_DEV）：\",\"#ifdef HAL_I2C_MODULE_ENABLED WEAK const PinMap PinMap_I2C_SDA[] = { {PA_2, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF12_I2C)}, {PA_7, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF12_I2C)}, {PA_9, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF12_I2C)}, {PA_10, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C)}, {PA_12, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C)}, {PB_7, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C)}, {PB_8, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF12_I2C)}, {PF_0, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF12_I2C)}, {NC, NP, 0} }; #endif #ifdef HAL_I2C_MODULE_ENABLED WEAK const PinMap PinMap_I2C_SCL[] = { {PA_3, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF12_I2C)}, {PA_8, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF12_I2C)}, {PA_9, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C)}, {PA_10, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF12_I2C)}, {PA_11, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C)}, {PB_6, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C)}, {PB_8, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C)}, {PF_1, I2C, AIR_PIN_DATA(AIR_MODE_AF_OD, GPIO_NOPULL, GPIO_AF12_I2C)}, {NC, NP, 0} }; #endif \"]},\"99\":{\"h\":\"重新定义I2C引脚\",\"t\":[\"因为它们被定义为 WEAK，所以您可以在代码文件中重新定义它们，而不是更改 PeripheralPins.c 文件中的值。您还可以使用 AIR_PIN_DATA() 的第二个参数启用/禁用内部上拉电阻。\"]},\"100\":{\"h\":\"I2C 缓冲区管理\",\"t\":[\"默认情况下，I2C 缓冲区都在 Arduino API 上对齐：32 字节。\",\"但是我们最多可以传输 255 个字节：\",\"在主模式下：RX 和 TX 缓冲区将在需要时自动增长，彼此独立，并且独立于其他 I2C 实例。\",\"从应用程序的角度来看无事可做。\",\"在从模式下：借助开关 I2C_TXRX_BUFFER_SIZE ，可以使用 hal_conf_extra.h 或 build_opt.h （在编译时）静态重新定义 RX 和 TX 缓冲区大小\",\"所有 I2C 实例都受此编译开关更改的影响。\"]},\"101\":{\"h\":\"PWM\",\"t\":[\"PWM，即Pulse Width Modulation（脉宽调制）是是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在测量、通信、工控等方面。\"]},\"102\":{\"h\":\"PWM 通用 API\"},\"103\":{\"h\":\"analogWrite\",\"t\":[\"此函数用于设置 PWM 输出的占空比\",\"void analogWrite(uint32_t ulPin, uint32_t ulValue) \",\"ulPin：要设置的 PWM 输出引脚\",\"ulValue：占空比\"]},\"104\":{\"h\":\"AirMCU 专用 API\"},\"105\":{\"h\":\"analogWriteFrequency\",\"t\":[\"此函数用于设置 analogWrite() 使用的频率。默认值为 PWM_FREQUENCY (1000)，单位为赫兹。\",\"void analogWriteFrequency(uint32_t freq); \",\"freq：要设置的频率\",\"注\",\"频率对于指定定时器的所有通道是通用的，为一个通道设置频率将影响同一定时器的所有其他通道。\"]},\"106\":{\"h\":\"analogWriteResolution\",\"t\":[\"此函数用于设置 analogWrite 参数的分辨率。默认为 8 位（范围为 0 至 255）。\",\"void analogWriteResolution(int bits); \",\"bits：要设置的分辨率\"]},\"107\":{\"h\":\"文档概述\"},\"108\":{\"h\":\"支持的外设\",\"t\":[\"目前，AirMCU 通过 Arduino API 支持以下外设。\",\"外设\",\"Air001\",\"Air32F103\",\"Air401\",\"备注\",\"ADC\",\"✅\",\"🔨\",\"🔨\",\"-\",\"DAC\",\"❌\",\"🔨\",\"🔨\",\"-\",\"GPIO\",\"✅\",\"✅\",\"✅\",\"-\",\"I2C\",\"✅\",\"🔨\",\"🔨\",\"-\",\"Servo\",\"✅\",\"🔨\",\"🔨\",\"-\",\"SPI\",\"✅\",\"🔨\",\"🔨\",\"-\",\"PWM\",\"✅\",\"🔨\",\"🔨\",\"-\",\"UART\",\"✅\",\"🔨\",\"✅\",\"-\",\"USB\",\"❌\",\"🔨\",\"❌\",\"-\",\"✅：支持\",\"🔨：开发中\",\"❌：不支持\"]},\"109\":{\"h\":\"APIs\",\"t\":[\"AirMCU 提供了一些独特的 API，如本节所述：\",\"ADCGPIOI2CPWM\"]},\"110\":{\"h\":\"Datasheet\",\"t\":[\"目前，您可以在以下网站找到 AirMCU 支持芯片的相关数据手册。\",\"air001\",\"air32f103\",\"air401\"]},\"111\":{\"h\":\"SPI\"},\"112\":{\"h\":\"关于\",\"t\":[\"SPI，即Serial Peripheral Interface Bus（串行外设接口），是一种用于芯片通信的同步串行通信接口规范，主要应用于单片机系统中。类似I²C。 这种接口首先由摩托罗拉公司于20世纪80年代中期开发，后发展成了行业规范。它的典型应用有闪存、EEPROM、SD卡与液晶显示器。\",\"SPI设备之间使用全双工模式通信，是一个主机和一个或多个从机的主从模式。主机负责初始化帧，这个数据传输帧可以用于读与写两种操作，片选线路可以从多个从机选择一个来响应主机的请求。\",\"有时SPI接口被称作四线式接口，这是为了与其他不同线制的数据传输接口加以区分。SPI准确来讲应为“同步串行接口”，但是它又与同步串行接口协议（SSI）是完全不同的两种协议。虽然SSI也是一个四线式同步通信协议，但是它使用差分信号，而且仅提供一个单工通信信道。于此相对地，SPI是一个单主机多从机的通信接口。\",\"SPI是一种事实标准，也就是说这种规范没有对应的技术标准。因此各个厂家生产的SPI器件配置不一样，不一定有互操作性。\"]},\"113\":{\"h\":\"Arduino API 参考\",\"t\":[\"SPI Reference\",\"SPI Description\"]},\"114\":{\"h\":\"AirMCU 专用API\",\"t\":[\"AirMCU SPI 库已经过修改，可以在不停止 SPI 接口的情况下管理多个 CS 引脚。\",\"我们为用户提供了 3 种关于 CS 引脚管理的可能性：\",\"CS 引脚在传输数据之前由用户代码直接管理（如 Arduino SPI 库）\",\"或者用户将 CS pin 号提供给库 API，库自行管理 CS pin（参见下面的示例）\",\"或者用户使用链接到 SPI 外设的硬件 CS 引脚\"]},\"115\":{\"h\":\"SPIClass::SPIClass(uint8_t mosi, uint8_t miso, uint8_t sclk, uint8_t ssel)\",\"t\":[\"构造函数，用于初始化 SPI 外设，参数为 SPI 外设的引脚号。\",\"mosi：MOSI 引脚号\",\"miso：MISO 引脚号\",\"sclk：SCLK 引脚号\",\"ssel：CS 引脚号，该引脚必须是硬件 CS 引脚。如果配置该引脚，片选将由 SPI 外设管理。请勿在参数中使用带有 CS 引脚的 API 函数。\"]},\"116\":{\"h\":\"void SPIClass::begin(uint8_t _pin)\",\"t\":[\"初始化 SPI 外设。\",\"_pin：CS 引脚号，由 SPI 库管理。\"]},\"117\":{\"h\":\"void beginTransaction(uint8_t pin, SPISettings settings)\",\"t\":[\"允许使用其他参数配置SPI。这些新参数保存在关联的 CS 引脚上。\",\"pin：CS 引脚号，由 SPI 库管理。\",\"settings：SPI 设置，包括速率、位顺序和数据模式。\"]},\"118\":{\"h\":\"void endTransaction(uint8_t pin)\",\"t\":[\"删除 CS 引脚和关联的 SPI 设置\",\"pin：CS 引脚号，由 SPI 库管理。\",\"注\",\"使用 begin() 或 beginTransaction() 初始化 SPI 实例后，必须调用以下函数。 如果要管理多个设备，可以多次调用 beginTransaction()，并在参数中包含不同的 CS 引脚。 然后，您可以使用不同的 CS 引脚调用以下函数，而无需再次调用 beginTransaction()（直到调用 end() 或 endTransaction()）。\",\"注\",\"如果模式设置为 SPI_CONTINUE，CS 引脚将保持启用状态。使用多个 CS 引脚时要小心。\"]},\"119\":{\"h\":\"byte transfer(uint8_t pin, uint8_t _data, SPITransferMode _mode = SPI_LAST)\",\"t\":[\"写入/读取一个字节\",\"pin： CS 引脚，由 SPI 库管理\",\"data：要写入的参数\",\"mode：（可选）如果 SPI_LAST mode CS 引脚复位， SPI_CONTINUE mode CS 引脚保持启用状态。返回接收到的数据\"]},\"120\":{\"h\":\"uint16_t transfer16(uint8_t pin, uint16_t _data, SPITransferMode _mode = SPI_LAST)\",\"t\":[\"写/读半字\",\"pin： CS 引脚，由 SPI 库管理\",\"data：要写入的参数\",\"mode：（可选）如果 SPI_LAST mode CS 引脚复位， SPI_CONTINUE mode CS 引脚保持启用状态。返回接收到的数据\"]},\"121\":{\"h\":\"void transfer(uint8_t pin, void *_buf, size_t _count, SPITransferMode _mode = SPI_LAST)\",\"t\":[\"写入/读取几个字节。仅使用一个缓冲区来写入和读取数据\",\"pin： CS 引脚，由 SPI 库管理\",\"buf：指向要写入的数据的指针\",\"count：要写入/读取的数据数量\",\"mode：（可选）如果 SPI_LAST mode CS 引脚复位， SPI_CONTINUE mode CS 引脚保持启用状态。\"]},\"122\":{\"h\":\"void transfer(byte _pin, void *_bufout, void *_bufin, size_t _count, SPITransferMode _mode = SPI_LAST)\",\"t\":[\"写入/读取几个字节。一个用于输出数据的缓冲区，一个用于输入数据的缓冲区\",\"pin： CS 引脚，由 SPI 库管理\",\"bufout：指向要写入的数据的指针\",\"bufin：指向要读取的数据的指针\",\"count：要写入/读取的数据数量\",\"mode：（可选）如果 SPI_LAST mode CS 引脚复位， SPI_CONTINUE mode CS 引脚保持启用状态。\"]},\"123\":{\"h\":\"例子\",\"t\":[\"这是使用 CS 引脚管理的示例：\",\"#include <SPI.h> // MOSI MISO SCLK SPIClass SPI_3(PC12, PC11, PC10); void setup() { SPI_3.begin(2); //Enables the SPI_3 instance with default settings and attaches the CS pin SPI_3.beginTransaction(1, settings); //Attaches another CS pin and configure the SPI_3 instance with other settings SPI_3.transfer(2, 0x52); //Transfers data to the first device SPI_3.transfer(1, 0xA4); //Transfers data to the second device. The SPI_3 instance is configured with the right settings SPI_3.end() //SPI_3 instance is disabled } \"]},\"124\":{\"h\":\"更改默认 SPI 实例引脚\",\"t\":[\"还可以使用下列 API 更改 SPI 实例使用的默认引脚：\",\"void setMISO(uint32_t miso)\",\"void setMOSI(uint32_t mosi)\",\"void setSCLK(uint32_t sclk)\",\"void setSSEL(uint32_t ssel)\",\"void setMISO(PinName miso)\",\"void setMOSI(PinName mosi)\",\"void setSCLK(PinName sclk)\",\"void setSSEL(PinName ssel)\",\"注意\",\"这些 API 必须在调用 begin() 之前调用。\"]},\"125\":{\"h\":\"硬件定时器\",\"t\":[\"HardwareTimer库旨在提供对部分AirMCU硬件定时器功能的访问（如果需要其他功能，可以通过HAL/LL访问它们）。\",\"使用该库假设您对 AirMCU 硬件定时器架构有一些基本了解。首先提醒一下，所有定时器并不等同，也不支持相同的功能。请参阅您的 MCU 的参考手册。\",\"一些例子：\",\"TIM6 和 TIM7 没有输出的引脚，这就是为什么在可用时，它们被用于实现 Tone 和 Servo。\",\"有些定时器有多达 4 个输出通道，其中有 4 个互补通道，而其他定时器则没有互补通道，或者只有 1 或 2 个通道...\",\"每个定时器可以提供多个通道，但是重要的是要理解同一定时器的所有通道共享相同的计数器，因此具有相同的周期/频率。\",\"注意\",\"出于通用性目的，HardwareTimer 库使用所有定时器，如 16 位定时器（即使有些定时器的位数更多）。\"]},\"126\":{\"h\":\"API接口\",\"t\":[\" void pause(void); // Pause counter and all output channels void pauseChannel(uint32_t channel); // Timer is still running but channel (output and interrupt) is disabled void resume(void); // Resume counter and all output channels void resumeChannel(uint32_t channel); // Resume only one channel void setPrescaleFactor(uint32_t prescaler); // set prescaler register (which is factor value - 1) uint32_t getPrescaleFactor(); void setOverflow(uint32_t val, TimerFormat_t format = TICK_FORMAT); // set AutoReload register depending on format provided uint32_t getOverflow(TimerFormat_t format = TICK_FORMAT); // return overflow depending on format provided void setPWM(uint32_t channel, PinName pin, uint32_t frequency, uint32_t dutycycle, callback_function_t PeriodCallback = nullptr, callback_function_t CompareCallback = nullptr); // Set all in one command freq in HZ, Duty in percentage. Including both interrup. void setPWM(uint32_t channel, uint32_t pin, uint32_t frequency, uint32_t dutycycle, callback_function_t PeriodCallback = nullptr, callback_function_t CompareCallback = nullptr); void setCount(uint32_t val, TimerFormat_t format = TICK_FORMAT); // set timer counter to value 'val' depending on format provided uint32_t getCount(TimerFormat_t format = TICK_FORMAT); // return current counter value of timer depending on format provided void setMode(uint32_t channel, TimerModes_t mode, PinName pin = NC); // Configure timer channel with specified mode on specified pin if available void setMode(uint32_t channel, TimerModes_t mode, uint32_t pin); TimerModes_t getMode(uint32_t channel); // Retrieve configured mode void setPreloadEnable(bool value); // Configure overflow preload enable setting uint32_t getCaptureCompare(uint32_t channel, TimerCompareFormat_t format = TICK_COMPARE_FORMAT); // return Capture/Compare register value of specified channel depending on format provided void setCaptureCompare(uint32_t channel, uint32_t compare, TimerCompareFormat_t format = TICK_COMPARE_FORMAT); // set Compare register value of specified channel depending on format provided void setInterruptPriority(uint32_t preemptPriority, uint32_t subPriority); // set interrupt priority //Add interrupt to period update void attachInterrupt(callback_function_t callback); // Attach interrupt callback which will be called upon update event (timer rollover) void detachInterrupt(); // remove interrupt callback which was attached to update event bool hasInterrupt(); //returns true if a timer rollover interrupt has already been set //Add interrupt to capture/compare channel void attachInterrupt(uint32_t channel, callback_function_t callback); // Attach interrupt callback which will be called upon compare match event of specified channel void detachInterrupt(uint32_t channel); // remove interrupt callback which was attached to compare match event of specified channel bool hasInterrupt(uint32_t channel); //returns true if an interrupt has already been set on the channel compare match void timerHandleDeinit(); // Timer deinitialization // Refresh() is usefull while timer is running after some registers update void refresh(void); // Generate update event to force all registers (Autoreload, prescaler, compare) to be taken into account uint32_t getTimerClkFreq(); // return timer clock frequency in Hz. static void captureCompareCallback(TIM_HandleTypeDef *htim); // Generic Caputre and Compare callback which will call user callback static void updateCallback(TIM_HandleTypeDef *htim); // Generic Update (rollover) callback which will call user callback // The following function(s) are available for more advanced timer options TIM_HandleTypeDef *getHandle(); // return the handle address for HAL related configuration int getChannel(uint32_t channel); int getLLChannel(uint32_t channel); int getIT(uint32_t channel); int getAssociatedChannel(uint32_t channel); #if defined(TIM_CCER_CC1NE) bool isComplementaryChannel[TIMER_CHANNELS]; #endif \"]},\"127\":{\"h\":\"使用方式\",\"t\":[\"HardwareTimer 是一个 C++ 类，要做的第一件事是以 TIM 实例作为参数实例化一个对象。\",\"注\",\"有些实例由 Servo、Tone 和 SoftSerial 使用（请参阅 TIMER_SERVO、TIMER_TONE 和 TIMER_SERIAL），但仅在使用时使用。只要确保与您自己的使用没有冲突即可。\",\"HardwareTimer *MyTim = new HardwareTimer(TIM3); // TIM3 is MCU hardware peripheral instance, its definition is provided in CMSIS \",\"然后就可以配置通道的模式。\",\"注\",\"无需配置引脚模式（输出/输入/AlternateFunction），它将由 HardwareTimer 库自动完成。\",\"注\",\"通道范围[1..4]，但并非所有定时器都支持4个通道。\",\"MyTim->setMode(channel, TIMER_OUTPUT_COMPARE_PWM1, pin); \",\"支持模式有：\",\"typedef enum { TIMER_DISABLED, // == TIM_OCMODE_TIMING no output, useful for only-interrupt // Output Compare TIMER_OUTPUT_COMPARE, // == Obsolete, use TIMER_DISABLED instead. Kept for compatibility reason TIMER_OUTPUT_COMPARE_ACTIVE, // == TIM_OCMODE_ACTIVE pin is set high when counter == channel compare TIMER_OUTPUT_COMPARE_INACTIVE, // == TIM_OCMODE_INACTIVE pin is set low when counter == channel compare TIMER_OUTPUT_COMPARE_TOGGLE, // == TIM_OCMODE_TOGGLE pin toggles when counter == channel compare TIMER_OUTPUT_COMPARE_PWM1, // == TIM_OCMODE_PWM1 pin high when counter < channel compare, low otherwise TIMER_OUTPUT_COMPARE_PWM2, // == TIM_OCMODE_PWM2 pin low when counter < channel compare, high otherwise TIMER_OUTPUT_COMPARE_FORCED_ACTIVE, // == TIM_OCMODE_FORCED_ACTIVE pin always high TIMER_OUTPUT_COMPARE_FORCED_INACTIVE, // == TIM_OCMODE_FORCED_INACTIVE pin always low //Input capture TIMER_INPUT_CAPTURE_RISING, // == TIM_INPUTCHANNELPOLARITY_RISING TIMER_INPUT_CAPTURE_FALLING, // == TIM_INPUTCHANNELPOLARITY_FALLING TIMER_INPUT_CAPTURE_BOTHEDGE, // == TIM_INPUTCHANNELPOLARITY_BOTHEDGE // Used 2 channels for a single pin. One channel in TIM_INPUTCHANNELPOLARITY_RISING another channel in TIM_INPUTCHANNELPOLARITY_FALLING. // Channels must be used by pair: CH1 with CH2, or CH3 with CH4 // This mode is very useful for Frequency and Dutycycle measurement TIMER_INPUT_FREQ_DUTY_MEASUREMENT, TIMER_NOT_USED = 0xFFFF // This must be the last item of this enum } TimerModes_t; \",\"然后就可以配置PrescalerFactor。定时器时钟将除以该因子（如果定时器时钟为 10Khz，预分频器因子为 2，则定时器将以 5kHz 计数）。\",\"注\",\"将方法 setOverflow 与 format == MICROSEC_FORMAT 或 format == HERTZ_FORMAT 一起使用时，预分频器的配置是自动的。\",\"注\",\"预分频器用于定时器计数器，因此对所有通道都是通用的。\",\"注\",\"预分频器因子范围：[1..0x10000]（硬件寄存器范围为[0..0xFFFF]）。\",\"MyTim->setPrescaleFactor(8); \",\"然后就可以配置溢出（也称为翻转或更新）。\",\"对于输出，它对应于周期或频率。\",\"对于输入捕获，建议使用最大值：0x10000，以避免在捕获发生之前发生翻转。\",\"注\",\"将方法 setOverflow 与 format == MICROSEC_FORMAT 或 format == HERTZ_FORMAT 一起使用时，预分频器的配置是自动的。\",\"溢出是所有通道共有的。\",\"溢出范围：[1..0x10000]（硬件寄存器的范围为[0..0xFFFF]）。\",\"MyTim->setOverflow(10000); // Default format is TICK_FORMAT. Rollover will occurs when timer counter counts 10000 ticks (it reach it count from 0 to 9999) MyTim->setOverflow(10000, TICK_FORMAT); MyTim->setOverflow(10000, MICROSEC_FORMAT); // 10000 microseconds MyTim->setOverflow(10000, HERTZ_FORMAT); // 10 kHz \",\"然后可以配置 CaptureCompare（通道特定的 CaptureCompare 寄存器）。\",\"注\",\"CaptureCompare 仅适用于一个通道。\",\"CaptureCompare 范围：[0.. 0xFFFF]\",\"MyTim->setCaptureCompare(channel, 50); // Default format is TICK_FORMAT. 50 ticks MyTim->setCaptureCompare(channel, 50, TICK_FORMAT) MyTim->setCaptureCompare(channel, 50, MICROSEC_COMPARE_FORMAT); // 50 microseconds between counter resetand compare MyTim->setCaptureCompare(channel, 50, HERTZ_COMPARE_FORMAT); // 50 Hertz -> 1/50 seconds between counterreset and compare MyTim->setCaptureCompare(channel, 50, RESOLUTION_8B_COMPARE_FORMAT); // used for Dutycycle: [0.. 255] MyTim->setCaptureCompare(channel, 50, RESOLUTION_12B_COMPARE_FORMAT); // used for Dutycycle: [0.. 4095] \",\"可以在更新中断（翻转）和/或捕获/比较中断上附加用户回调。如果未指定通道，则用户回调将附加到更新事件。请注意，更新中断标志 (UIF) 在更新事件发生并生成中断时设置，并在执行用户回调之前由 HAL 驱动程序自动清除。用户回调无需显式清除 UIF。\",\"MyTim->attachInterrupt(Update_IT_callback); // Userdefined call back. See 'Examples' chapter to see how to use callback with or without parameter MyTim->attachInterrupt(channel, Compare_IT_callback); // Userdefined call back. See 'Examples' chapter to see how to use callback with or without parameter \",\"现在可以启动定时器了\",\"注\",\"同一定时器的所有通道同时启动（因为每个定时器只有 1 个计数器）。\",\"MyTim->resume(); \",\"计时器可以暂停然后恢复\",\"MyTim->pause(); // ... MyTim->resume(); \",\"以下是完整 PWM 配置的示例:\",\"MyTim->setMode(channel, TIMER_OUTPUT_COMPARE_PWM1, pin); // MyTim->setPrescaleFactor(8); // Due to setOverflow with MICROSEC_FORMAT, prescaler will be computedautomatically based on timer input clock MyTim->setOverflow(100000, MICROSEC_FORMAT); // 10000 microseconds = 10 milliseconds MyTim->setCaptureCompare(channel, 50, PERCENT_COMPARE_FORMAT); // 50% MyTim->attachInterrupt(Update_IT_callback); MyTim->attachInterrupt(channel, Compare_IT_callback); MyTim->resume(); \",\"为了简化基本 PWM 配置，提供了专用的一体化 API。溢出/频率以赫兹为单位，占空比以百分比为单位。\",\"MyTim->setPWM(channel, pin, 5, 10, NULL, NULL); // No callback required, we can simplify the function call MyTim->setPWM(channel, pin, 5, 10); // 5 Hertz, 10% dutycycle \",\"一些额外的 API 允许检索配置：\",\"getPrescaleFactor(); getOverflow(); getCaptureCompare(); // In InputCapture mode, this method doesn't retrieve configuration but retrieve thecaptured counter value getCount(); \",\"另外，要使用中断回调：\",\"detachInterrupt() \",\"注\",\"一旦计时器启动并启用回调，您可以通过 detachInterrupt 和 attachInterrupt 自由禁用和启用回调，次数不限。但是，如果第一个 resume （= 计时器启动）在调用 attachInterrupt 之前完成，则 HardwareTimer 将无法稍后附加中断（出于性能原因，计时器将启动禁用中断）\",\"如果在定时器运行时分离和附加中断，您还可以通过该方法知道是否已经附加了回调（无需在外部跟踪它）\",\"hasInterrupt() \"]},\"128\":{\"h\":\"UART\"},\"129\":{\"h\":\"关于\",\"t\":[\"UART，即Universal Asynchronous Receiver/Transmitter（通用异步收发器），是一种串行、异步、全双工的通信协议，在嵌入式领域应用的非常广泛。\"]},\"130\":{\"h\":\"UART 通用API\",\"t\":[\"在 Arduino 中，我们一般把UART称为Serial。我们在此仅介绍一些常用的 API ，具体的通用 API 可以参考 Arduino 官方文档。\"]},\"131\":{\"h\":\"begin\",\"t\":[\"此函数用于初始化串口，设置波特率。\",\"void begin(unsigned long baud, byte config) \",\"baud：波特率，单位为 bps\",\"config：配置，可选值为SERIAL_8N1SERIAL_8N2SERIAL_7N1SERIAL_8E1SERIAL_7E2SERIAL_8E2SERIAL_7O1SERIAL_8O1SERIAL_7O2SERIAL_8O2\",\"当然，您也可以使用\",\"void begin(unsigned long baud) \",\"来进行初始化，此时配置为SERIAL_8N1。\"]},\"132\":{\"h\":\"end\",\"t\":[\"此函数用于关闭串口。\",\"void end() \"]},\"133\":{\"h\":\"available\",\"t\":[\"此函数用于获取串口接收缓冲区中的字节数。\",\"int available() \",\"返回值：串口接收缓冲区中的字节数\"]},\"134\":{\"h\":\"read\",\"t\":[\"此函数用于从串口接收缓冲区中读取一个字节。\",\"int read() \",\"返回值：读取到的字节，如果没有可读取的字节，则返回-1\"]},\"135\":{\"h\":\"write\",\"t\":[\"此函数用于向串口发送数据。\",\"size_t write(uint8_t data) \",\"返回值：发送的字节数\",\"data：要发送的字节\",\"当然，您也可以使用\",\"size_t write(const uint8_t *buffer, size_t size) \",\"来发送多个字节。\",\"buffer：要发送的字节缓冲区\",\"size：要发送的字节数\",\"返回值：发送的字节数\"]},\"136\":{\"h\":\"flush\",\"t\":[\"此函数用于清空串口接收缓冲区。\",\"void flush() \"]},\"137\":{\"h\":\"peek\",\"t\":[\"此函数用于查看串口接收缓冲区中的下一个字节，但不会将其从缓冲区中删除。\",\"int peek() \",\"返回值：下一个字节，如果没有可读取的字节，则返回-1\"]},\"138\":{\"h\":\"AirMCU 专用API\",\"t\":[\"AirMCU 有多个 U(S)ART 外设。为方便起见，U(S)ARTx 编号用于定义 Serialx 实例：\",\"Serial1 为 USART1\",\"Serial2 为 USART2\",\"Serial3 为 USART3\",\"Serial4 为 UART4\",\"...对于 LPUART1 ，为 SerialLP1\",\"默认情况下，只有一个 Serialx 实例可映射到通用 Serial 名称。需要注意的是，一般我们习惯上使用Serial1来作为全局的Serial对象。\",\"要使用第二个串行端口，代码中应中在 setup() 函数之前声明 HardwareSerial 对象：\",\"// RX TX HardwareSerial Serial2(PA1, PA0); void setup() { Serial1.begin(115200); } void loop() { Serial1.println(\\\"Hello World!\\\"); delay(1000); } \",\"另一个解决方案是在主 .ino 文件旁边添加一个 build_opt.h 文件： -DENABLE_HWSERIALx 。这将使用变体的 PeripheralPins.c 中找到的第一个 USARTx 实例来定义 Serialx 实例。\",\"提示\",\"只用使用这种解决方案才能在代码中使用 serialEventx() 回调。\",\"例如，如果您在 build_opt.h 中定义： -DENABLE_HWSERIAL2\",\"这将使用您的变体的 PeripheralPins.c 中的 PinMap_UART_RX[] 和 PinMap_UART_TX[] 数组中找到的第一个 Rx 和 Tx 引脚实例化 Serial2serialEvent2() 将被启用。\",\"要指定应使用哪个 Rx 或 Tx 引脚而不是第一个找到的引脚，您可以指定 PIN_SERIALn_RX 或 PIN_SERIALn_TX ，其中 n 是串行实例的编号。\",\"Serial2 的示例：\",\"在 variant.h 中：\",\"#define PIN_SERIAL2_RX PA1 #define PIN_SERIAL2_TX PA0 \",\"在 build_opt.h 中： -DPIN_SERIAL2_RX=PA1 -DPIN_SERIAL2_TX=PA0\"]},\"139\":{\"h\":\"更改默认 Serial 实例引脚\",\"t\":[\"还可以使用下列 API 更改 Serial 实例使用的默认引脚：\",\"void setRx(PinName rxPin)\",\"void setRx(uint32_t rxPin)\",\"void setTx(PinName txPin)\",\"void setTx(uint32_t txPin)\",\"注意\",\"这些API必须在 begin() 之前调用。\"]},\"140\":{\"h\":\"启用半双工模式\",\"t\":[\"U(S)ART 可配置为遵循单线半双工协议，其中 Tx 和 Rx 线路在内部连接。在此通信模式下，仅 Tx 引脚用于发送和接收。\",\"扩展 HardwareSerial 构造函数：\",\"HardwareSerial(uint32_t _rxtx) ：用于半双工的 U(S)ART Tx 引脚号 ( PYn )\",\"HardwareSerial(PinName _rxtx) ：用于半双工的 U(S)ART Tx 引脚名称 ( PY_n )\",\"如果 Rx == Tx 则采用半双工模式： \",\"HardwareSerial(uint32_t _rx, uint32_t _tx) ：用于半双工的 U(S)ART Tx 引脚号 ( PYn )\",\"HardwareSerial(PinName _rx, PinName tx) ：用于半双工的 U(S)ART Tx 引脚名称 ( PY_n )\",\"HardwareSerial(void *peripheral, HalfDuplexMode_t halfDuplex = HALF_DUPLEX_DISABLED) ：如果 HALF_DUPLEX_ENABLED 获取用于半双工的 PeripheralPins.c 中请求的外设的第一个Tx引脚\",\"添加 enableHalfDuplexRx() 以在 Rx 模式下启用串行。可以使用 read() ，但会避免执行读取。在 available() 使用之前有用\",\"void setHalfDuplex() ：当实例未以半双工模式实例化时，启用实例的半双工模式。在这种情况下，必须在 begin() 之前调用。\"]},\"141\":{\"h\":\"启用硬件流控制\",\"t\":[\"HardwareSerial 构造函数接受可选的 RTS/CTS 引脚：\",\"HardwareSerial(uint32_t _rx, uint32_t _tx, uint32_t _rts = NUM_DIGITAL_PINS, uint32_t _cts = NUM_DIGITAL_PINS)\",\"HardwareSerial(PinName _rx, PinName _tx, PinName _rts = NC, PinName _cts = NC)\",\"您还可以在 HardwareSerial 实例上启用 RTS/CTS 引脚：\",\"void setRts(uint32_t _rts)\",\"void setCts(uint32_t _cts)\",\"void setRtsCts(uint32_t _rts, uint32_t _cts)\",\"void setRts(PinName _rts)\",\"void setCts(PinName _cts)\",\"void setRtsCts(PinName _rts, PinName _cts)\"]},\"142\":{\"h\":\"中文路径导致编译报错\"},\"143\":{\"h\":\"问题描述\",\"t\":[\"在编译项目时，链接(ld)阶段报错，并且报错信息的路径包含乱码，实际应为中文路径名，如下图所示：\",\"报错信息\"]},\"144\":{\"h\":\"问题原因\",\"t\":[\"GCC编译器不支持使用中文路径，需要将此包放置到英文路径下\"]},\"145\":{\"h\":\"解决方案\",\"t\":[\"注意\",\"开始之前，你需要确保 Arduino IED 处于关闭状态。\"]},\"146\":{\"h\":\"新建一个不带中文路径的文件夹\",\"t\":[\"首先，新建一个你需要放置文件的文件夹路径，并且保证路径纯英文，不包含空格。 如：D:\\\\arduino_pack。\",\"提示\",\"我们下面将默认你的新文件夹路径为D:\\\\arduino_pack。\"]},\"147\":{\"h\":\"迁移当前的包文件\",\"t\":[\"打开文件管理器，在文件路径栏中输入C:\\\\Users\\\\%USERNAME%\\\\AppData\\\\Local\\\\Arduino15，回车。\",\"Arduino15文件夹\",\"全选这里的所有文件，将他们全部移动到你最开始新建的文件夹，比如我们这里举例的：\",\"移动后\"]},\"148\":{\"h\":\"更改配置文件中的包文件路径\",\"t\":[\"打开文件管理器，在文件路径栏中输入C:\\\\Users\\\\%USERNAME%\\\\.arduinoIDE，回车。\",\"打开arduino-cli.yaml，可以看到当前的配置：\",\"... directories: builtin: libraries: C:\\\\Users\\\\测试\\\\AppData\\\\Local\\\\Arduino15\\\\libraries data: c:\\\\Users\\\\测试\\\\AppData\\\\Local\\\\Arduino15 downloads: C:\\\\Users\\\\测试\\\\AppData\\\\Local\\\\Arduino15\\\\staging user: c:\\\\Users\\\\测试\\\\Documents\\\\Arduino ... \",\"我们将C:\\\\Users\\\\测试\\\\AppData\\\\Local\\\\Arduino15全部替换成新建的文件夹路径即可：\",\"... directories: builtin: libraries: D:\\\\arduino_pack\\\\libraries data: D:\\\\arduino_pack downloads: D:\\\\arduino_pack\\\\staging user: c:\\\\Users\\\\测试\\\\Documents\\\\Arduino ... \",\"修改完后，保存配置，即可正常编译。\",\"提示\",\"你需要保证项目文件的路径也不能包含中文或空格\"]},\"149\":{\"h\":\"使用\",\"t\":[\"重新打开 Arduino IED 即可正常编译。\",\"如果依旧报错\",\"若你的用户名文件夹为中文，则可能依旧报错，此时需要更改你的TEMP环境变量路径。\",\"首先，新建一个你需要放置TEMP的文件夹路径，并且保证路径纯英文，不包含空格。 如：D:\\\\TEMP。\",\"将你的环境变量的TEMP与TMP值改为你新建的文件夹路径即可，可以参考这篇文章。\",\"修改后重新启动 Arduino IED 即可正常编译。\"]},\"150\":{\"h\":\"烧录问题\"},\"151\":{\"h\":\"为什么烧录到一半就显示失败\",\"t\":[\"尝试调低串口烧录波特率后再试\"]},\"152\":{\"h\":\"为什么烧录提示无法进入boot模式\",\"t\":[\"自动boot模式需要连接DTR与RTS才能实现。若无法自动进入，请尝试手动进入boot模式\"]},\"153\":{\"h\":\"Air001开发板入门\"},\"154\":{\"h\":\"连上开发板\",\"t\":[\"使用串口连接上板子USB另一头的串口引脚，具体可以参考：使用串口下载\",\"如果购买了合宙的DAPLink调试器\",\"如果是购买的小白板和合宙的DAPLink调试器，可以直接通过排针排母相连，方向如图所示\",\"5\",\"连接后，保证开发板有供电，开发板选择AirMCU-Air001 Board，端口选择连接的串口\"]},\"155\":{\"h\":\"添加代码\",\"t\":[\"在主函数中添加一些测试代码\",\"void setup() { // put your setup code here, to run once: pinMode(PB_0, OUTPUT); Serial.begin(115200); Serial.printf(\\\"Hello, Air001. \\\\n\\\"); } void loop() { // put your main code here, to run repeatedly: static int count = 0; if (count % 2 == 0) { digitalWrite(PB_0, HIGH); } else { digitalWrite(PB_0, LOW); } Serial.printf(\\\"This is NO.%d print. \\\\n\\\", count); count++; delay(1000); } \"]},\"156\":{\"h\":\"编译下载\",\"t\":[\"点击上传按钮，等待编译并上传测试代码\",\"1\"]},\"157\":{\"h\":\"查看串口输出\",\"t\":[\"如果代码编译上传正常，那么打开串口监视器，即可看到输出的相关日志\",\"2\",\"并可观察到LED以1秒的间隔闪烁\",\"接下来可以继续查看应用示例，测试更多的例子\"]},\"158\":{\"h\":\"RP2040 树莓派 Pico\",\"t\":[\"本文将演示如何为合宙RP2040开发板进行配置与上手。\"]},\"159\":{\"h\":\"安装开发板\",\"t\":[\"在开发板管理器中搜索Pico\",\"开发板列表\",\"安装Arduino Mbed OS RP2040 Boards最新版即可\",\"提示\",\"安装过程需要安装多个工具链，可能会稍慢，请耐心等待 中途会安装驱动，请全部点击安装\"]},\"160\":{\"h\":\"选择开发板\",\"t\":[\"开发板选择选择其他开发板和端口，在开发板中搜索pico，选择Raspberry Pi Pico：\",\"选择其他开发板和端口\"]},\"161\":{\"h\":\"添加代码\",\"t\":[\"在主函数中添加一些测试代码：\",\"// the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(100); // wait for a second digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(100); // wait for a second } \"]},\"162\":{\"h\":\"编译下载\",\"t\":[\"将开发板的 USB 连接移除，按住开发板上的按键，再重新插入 USB 接口。\",\"此时电脑会识别到一个名为RPI-RP2的U盘设备，说明进入烧录模式成功。\",\"点击上传按钮，等待编译并上传测试代码\",\"烧录\"]},\"163\":{\"h\":\"查看效果\",\"t\":[\"如果代码编译上传正常，那么可观察到LED在十分快速地闪烁。\",\"接下来可以继续查看应用示例，测试更多的例子\"]},\"164\":{\"h\":\"测量 ADC\"},\"165\":{\"h\":\"简介\",\"t\":[\"本章介绍使用 Arduino 烧录 Air001 开发板测量 ADC。\"]},\"166\":{\"h\":\"硬件准备\",\"t\":[\"按 ☁️ Air001 开发板入门，将 Air001 和 DAPLink 调试器使用排针排母连接。\",\"可控电压源，负极接 Air001 的 GND 引脚（地）、正极接引脚 PA0 以及 PA1。\"]},\"167\":{\"h\":\"软件部分\",\"t\":[\"按前文下载 Arduino IDE、安装 AirMCU，并选择接口和 AirM2M Air001 Board。\",\"添加如下代码：\",\"void setup() { Serial.begin(115200); analogReadResolution(12); } void loop() { Serial.printf(\\\"PA0 Voltage is %d mv \\\\n\\\", analogReadMillivolts(PA0)); Serial.printf(\\\"PA1 Voltage is %d mv \\\\n\\\", analogReadMillivolts(PA1)); Serial.printf(\\\"Chip temp is %d C \\\\n\\\", analogReadTempSensor()); Serial.printf(\\\"Vref is %d mv \\\\n\\\", analogReadVref()); delay(500); } \"]},\"168\":{\"h\":\"输出结果\",\"t\":[\"将波特率调为 115200，在串口监视器中可观察到当前串口输出和引脚上的实际电压。\"]},\"169\":{\"h\":\"气压传感器 BMP180\"},\"170\":{\"h\":\"简介\",\"t\":[\"本章介绍使用Air001开发板驱动 BMP180。\",\"提示\",\"BMP180 使用I²C通信接口，是专为测量大气压力而设计的基本传感器， BMP180可以测量300至1100 hPa（海拔9000m至-500m）的大气压，以及-40°C至85°C的温度。\"]},\"171\":{\"h\":\"硬件准备\",\"t\":[\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接。\",\"将BMP180模块与Air001开发板，按如下表格进行相连：\",\"BMP180\",\"Air001\",\"GND\",\"GND\",\"VCC\",\"3.3V\",\"SCL\",\"PF_1\",\"SDA\",\"PF_0\"]},\"172\":{\"h\":\"软件部分\",\"t\":[\"首先，安装Adafruit BMP085 Library库。\",\"打开Arduino管理库，进行安装\",\"可以打开Arduino管理库，找到Adafruit BMP085 Library库，并选择全部安装以安装所需依赖。\",\"库管理器中的 Adafruit BMP085 Library\",\"开头引用Adafruit_BMP085包，并实例化对象bmp，后续仅需调用bmp对象即可使用BMP180。\",\"#include <Adafruit_BMP085.h> Adafruit_BMP085 bmp; \",\"在setup()函数中初始化串口与BMP180：\",\"void setup() { Serial.begin(9600);//初始化串口，波特率9600 if (!bmp.begin()) {//初始化设备 Serial.println(\\\"initial failed\\\"); while (1); } } \",\"在loop()函数中添加如下代码：\",\"void loop() { Serial.print(\\\"温度\\\"); Serial.print(bmp.readTemperature()); Serial.println(\\\"℃\\\"); Serial.print(\\\"气压\\\"); Serial.print(bmp.readPressure()); Serial.println(\\\"Pa\\\"); // 粗略计算海拔高度 Serial.print(\\\"海拔\\\"); Serial.print(bmp.readAltitude()); Serial.println(\\\"米\\\"); Serial.println(); delay(500); } \",\"使用bmp.readTemperature方法，获取当前温度。\",\"使用bmp.readPressure方法，获取当前气压。\",\"使用bmp.readAltitude()方法，粗略计算当前的海拔高度。\"]},\"173\":{\"h\":\"输出结果\",\"t\":[\"在串口监视器中将波特率调至9600，可观察到当前的信息，如下图：\",\"uart\"]},\"174\":{\"h\":\"温度传感器 DS18B20\"},\"175\":{\"h\":\"简介\",\"t\":[\"本章介绍使用Air001开发板驱动 DS18B20。\",\"提示\",\"DS18B20 是数字温度传感器，使用1Wire(单总线)通信接口，只需要一条数据线 (和地线) 即可与处理器进行数据传输。 器件可以工作在-55°C至+125°C范围，在-10°C至+85°C范围内测量精度为±0.5°C。 每个DS18B20具有唯一的64位序列号，从而允许多个DS18B20挂接在同一条1-Wire总线。\"]},\"176\":{\"h\":\"硬件准备\",\"t\":[\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接。\",\"将DS18B20模块与Air001开发板，按如下表格进行相连：\",\"DS18B20\",\"Air001\",\"GND\",\"GND\",\"VCC\",\"3.3V\",\"DQ\",\"PA_5\",\"注意\",\"如果你是直接连接的DS18B20元器件，你需要为DQ进行上拉操作。 （比如在VCC与DQ之间连接一颗4.7K电阻）\"]},\"177\":{\"h\":\"软件部分\",\"t\":[\"首先，安装DallasTemperature库，并选择全部安装以安装所需依赖。\",\"打开Arduino管理库，进行安装\",\"可以打开Arduino管理库，找到Adafruit DallasTemperature Library库，并选择全部安装以安装所需依赖。\",\"库管理器中的 Adafruit DallasTemperature Library\",\"全部安装\",\"为了保证单总线的时序保持正常，我们需要将芯片主频设置为最高的 48M。\",\"在Arduino中设置芯片主频\",\"设置芯片主频\",\"开头引用OneWire包与DallasTemperature包，并实例化对象sensors，后续仅需调用sensors对象即可使用DS18B20。\",\"// 引用必要的库 #include <OneWire.h> #include <DallasTemperature.h> // 初始化一个单总线对象，设置使用PA_5引脚进行通信 OneWire oneWire(PA_5); // 初始化一个传感器对象，使用刚新建的单总线对象 DallasTemperature sensors(&oneWire); \",\"在setup()函数中初始化串口与sensors对象：\",\"void setup() { //初始化串口 Serial.begin(9600); //初始化传感器库 sensors.begin(); } \",\"在loop()函数中添加如下代码：\",\"void loop() { Serial.print(\\\"开始获取温度信息...\\\"); sensors.requestTemperatures(); //发出获取温度的请求 Serial.println(\\\"获取完成\\\"); // 我们只取第一个传感器的温度信息 float tempC = sensors.getTempCByIndex(0); //检查一下是不是真的获取成功了 if (tempC != DEVICE_DISCONNECTED_C) { Serial.print(\\\"获取到的温度为：\\\"); Serial.print(tempC); Serial.println(\\\"℃\\\"); } else { Serial.println(\\\"数据读取失败！\\\"); delay(500); } Serial.println(); } \",\"使用sensors.requestTemperatures方法，尝试获取温度。\",\"使用sensors.getTempCByIndex方法，获取到第一个设备的温度值。\",\"如果成功获取，将温度值打印出来\"]},\"178\":{\"h\":\"输出结果\",\"t\":[\"在串口监视器中将波特率调至9600，可观察到当前的信息，如下：\",\"开始获取温度信息...获取完成 获取到的温度为：27.19℃ 开始获取温度信息...获取完成 获取到的温度为：27.25℃ 开始获取温度信息...获取完成 获取到的温度为：27.19℃ 开始获取温度信息...获取完成 获取到的温度为：27.25℃ 开始获取温度信息...获取完成 获取到的温度为：27.19℃ 开始获取温度信息... \"]},\"179\":{\"h\":\"按键输入\"},\"180\":{\"h\":\"简介\",\"t\":[\"本文将介绍使用 Air001 开发板按键打印按键状态。\"]},\"181\":{\"h\":\"硬件准备\",\"t\":[\"Air001开发板一块。\",\"提示\",\"在 Air001 开发板上，BOOT按键可作为通用按键使用，GPIO 编号为PB6，具体可参考 Air001 硬件手册。\"]},\"182\":{\"h\":\"软件部分\",\"t\":[\"首先，在代码的开头定义一下全局变量：\",\"int ButtonState = LOW; #define Button PB_6 \",\"定义ButtonState变量，用于存储上一次的按键状态。\",\"将Button的值定义为PB_6，BOOT按键所属的 GPIO。\",\"接着，在setup()函数中，添加如下代码：\",\"void setup() { Serial.begin(9600); pinMode(Button, INPUT_PULLDOWN); } \",\"初始化串口为9600波特率，用于打印按键状态。\",\"使用pinMode函数初始化PB6这个GPIO，并且设置为INPUT_PULLDOWN下拉输入模式。\",\"最后，我们在loop()函数中添加剩下的代码，轮询当前 GPIO 的状态：\",\"void loop() { int state = digitalRead(Button); if(ButtonState==state) return; if (state == LOW) { Serial.println(\\\"key up\\\"); } else { Serial.println(\\\"key pressed\\\"); } ButtonState = state; } \",\"我们首先获取这一次的按键电平状态，存入state变量中。\",\"接着对比这一次的电平是否变化，如果没变化，退出这次检测。\",\"如果有变化，我们打印一下当前按钮的电平状态，这里使用了三元运算符。\",\"最后将当前的电平状态存入ButtonState，提供给下一次读取使用。\"]},\"183\":{\"h\":\"输出结果\",\"t\":[\"可以在串口监视器中看到：\",\"当按下按键时，打印key pressed。\",\"松开时打印key up。\",\"key pressed key up key pressed key up key pressed key up key pressed key up \",\"注意\",\"由于使用了BOOT按键，有概率会影响到自动进入BOOT模式的逻辑。 如若无法进入BOOT模式导致无法烧录，可尝试下面的步骤进行烧录：\",\"断开 USB 的连接\",\"按住BOOT按键，不要松开\",\"插入 USB\",\"松开BOOT按键\",\"点击电脑上的烧录按键，开始烧录\"]},\"184\":{\"h\":\"进一步优化\",\"t\":[\"我们会发现，loop()函数中只进行了轮询按键的判断，如果这个函数中添加了其他耗时的操作（比如进行了delay操作），那么按键打印将变得不够及时。\",\"我们可以使用GPIO 中断来摆脱这种轮询逻辑造成的问题。\",\"提示\",\"中断就是 CPU 在运行过程中上报的一种异常（只是叫做异常，不一定真的运行异常），它可以打断当前代码的运行，优先执行中断的操作。 当中断处理完后，再继续运行当前代码。 这里的GPIO 中断就是当 GPIO 的状态符合某种条件时，会触发的中断。\",\"首先，在代码的开头定义一下全局变量：\",\"#define Button PB_6 \",\"将Button的值定义为PB_6，BOOT按键所属的 GPIO。\",\"接着，新建一个中断回调函数，该函数用于触发中断后，进行调用\",\"void onChange() { if (digitalRead(Button) == LOW) { Serial.println(\\\"key up\\\"); } else { Serial.println(\\\"key pressed\\\"); } } \",\"当触发onChange函数后，获取一下当前的GPIO状态，用来判断时按下还是松开\",\"提示\",\"中断回调函数是这个中断被触发后会被调用的函数。当这个函数运行完毕后，其他代码会继续执行。\",\"在setup()函数中，添加如下代码：\",\"void setup() { Serial.begin(9600); //打开串口 pinMode(Button, INPUT_PULLDOWN); //设置管脚为输入 attachInterrupt(digitalPinToInterrupt(Button), onChange, CHANGE); /* LOW 当引脚为低电平时，触发中断 CHANGE 当引脚电平发生改变时，触发中断 RISING 当引脚由低电平变为高电平时，触发中断 FALLING 当引脚由高电平变为低电平时，触发中断 */ pinMode(PB_1, OUTPUT); } \",\"初始化串口为9600波特率，用于打印按键状态。\",\"使用attachInterrupt函数初始化一个中断事件，编号可以由digitalPinToInterrupt函数获取，触发标志设置为CHANGE。\",\"我们使用pinMode函数初始化PB1，并且设置为OUTPUT输出模式，用来闪灯。\",\"最后我们可以在我们在loop()函数中添加剩下的代码，为了演示不影响按键响应，我们加一个闪灯的功能代码：\",\"void loop() { digitalWrite(PB_1, HIGH); delay(500); digitalWrite(PB_1, LOW); delay(500); } \",\"当使用中断方式编写代码时，loop()函数中的延时将不会对按键状态变化时的相应造成影响。\"]},\"185\":{\"h\":\"优化后的结果\",\"t\":[\"我们可以看到开发板上的 LED 灯正常闪烁，并且串口监视器中的按键事件打印也很及时。\"]},\"186\":{\"h\":\"点灯\"},\"187\":{\"h\":\"简介\",\"t\":[\"本章介绍使用arduino烧录Air001开发板控制其上3个LED灯闪烁\"]},\"188\":{\"h\":\"硬件准备\",\"t\":[\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接\",\"提示\",\"在Air001开发板上，板载的三个LED灯，分别由PB1、PB0和PB3三个GPIO控制 具体可参考Air001 开发板PinOut\"]},\"189\":{\"h\":\"软件部分\",\"t\":[\"按前文下载Arduino IDE、安装Air MCU，并选择接口和Air001 Dev Chip\",\"在setup()函数中，添加如下代码\",\"void setup() { pinMode(PB_1, OUTPUT); pinMode(PB_0, OUTPUT); pinMode(PB_3, OUTPUT); } \",\"在这里，我们使用pinMode函数初始化PB1、PB0和PB3这三个GPIO，并且设置为OUTPUT输出模式。\",\"接着，我们在loop()函数中添加剩下的代码\",\"void loop() { digitalWrite(PB_1, HIGH); digitalWrite(PB_0, HIGH); digitalWrite(PB_3, HIGH); delay(1000); digitalWrite(PB_1, LOW); digitalWrite(PB_0, LOW); digitalWrite(PB_3, LOW); delay(1000); } \",\"我们在这段代码中，使用digitalWrite函数来控制这三个GPIO的数出状态：\",\"首先将GPIO设置为HIGH——高电平。此时LED灯亮起\",\"使用delay(1000)延时一秒\",\"然后将GPIO设置为LOW——低电平。此时LED灯熄灭\",\"使用delay(1000)延时一秒\",\"可以在开发板上观察到测试结果\"]},\"190\":{\"h\":\"更进一步\",\"t\":[\"在上面代码的基础上，我们可以将loop()函数更改为下面这样，可以实现三个灯依次被点亮的效果\",\"void loop() { digitalWrite(PB_3, LOW); digitalWrite(PB_1, HIGH); delay(200); digitalWrite(PB_1, LOW); digitalWrite(PB_0, HIGH); delay(200); digitalWrite(PB_0, LOW); digitalWrite(PB_3, HIGH); delay(200); } \"]},\"191\":{\"h\":\"6轴传感器 MPU6050\"},\"192\":{\"h\":\"简介\",\"t\":[\"本章介绍使用Air001开发板驱动MPU6050。\",\"提示\",\"MPU6050使用I²C通信接口，内部整合了三轴MEMS陀螺仪、三轴MEMS加速度计和一个内置温度传感器，可以读取三轴角度，三轴加速度以及当前温度。\"]},\"193\":{\"h\":\"硬件准备\",\"t\":[\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接。\",\"将MPU6050模块与Air001开发板，按如下表格进行相连：\",\"MPU6050\",\"Air001\",\"GND\",\"GND\",\"VCC\",\"3.3V\",\"SCL\",\"PF_1\",\"SDA\",\"PF_0\",\"提示\",\"剩余的XDA,XCL,ADO,INT引脚不用连接。\",\"关于MPU6050的方向\",\"对于陀螺仪：令芯片表面(有文字的一面)朝上，将其表面文字转至正向自己，以芯片内部中心为原点，水平向右的为X轴正方向，水平指向外侧的为Y轴正方向，竖直向上的为Z轴正方向。\",\"陀螺仪方向示意\",\"对于加速度计： 假想一个不受任何外力作用的球漂浮在正方体盒子中心，此时三轴加速度为0。当小球偏向任何一个方向时，为了保持静止，它自身将具有相反方向的加速度。\",\"加速度计方向示意\",\"小球的位置偏向X轴的负向，因此X轴的加速度读数应为正\"]},\"194\":{\"h\":\"软件部分\",\"t\":[\"我们只需要使用Arduino自带的Wire库。\",\"代码如下：\",\"#include<Wire.h> //定义数组用于存放测量的三轴角度、三轴加速度和温度 int16_t data[7]; //MPU6050的总线地址是0x68 const int mpu_addr =0x68; //依据加速度计和陀螺仪的量程设定精度 const uint16_t AccelScaleFactor = 16384; const uint16_t GyroScaleFactor = 131; \",\"提示\",\"加速度计的范围有2g、4g、8g、16g可选。\",\"陀螺仪的范围有±250、±500、±1000、±2000可选，而对应的精度分别是131LSB/(°/s)、65.5LSB/(°/s)、32.8LSB/(°/s)、16.4 LSB/(°/s)。\",\"定义getData函数来读取MPU6050测量的数据并依次赋给数组data[]。\",\"void getData(){ //开启MPU6050的传输 Wire.beginTransmission(mpu_addr); //寄存器的地址为0x3b Wire.write(0x3b); //结束传输 Wire.endTransmission(false); //获取7个数据，每个两位 Wire.requestFrom(mpu_addr,14,true); //赋值 for(byte i=0;i<7;i++) { data[i] = Wire.read() << 8 | Wire.read(); } } \",\"在setup函数中添加如下代码：\",\"void setup() { //设定SCL、SDA引脚 Wire.setSCL(PF_1); Wire.setSDA(PF_0); //初始化I²C接口 Wire.begin(); //初始化陀螺仪参数 Wire.beginTransmission(mpu_addr); Wire.write(0x6B); Wire.write(0); Wire.endTransmission(true); //初始化加速度计参数 Wire.beginTransmission(mpu_addr); Wire.write(0x1c); Wire.write(0x08); Wire.endTransmission(true); //初始化串口，用于输出日志 Serial.begin(9600); } \",\"最后在loop函数中添加其余代码：\",\"void loop() { //声明双精度实型变量三轴加速度，温度，和三轴角度 double Ax, Ay, Az, T, Gx, Gy, Gz; //引用之前定义的函数读取数据 getData(); //赋值 Ax = (double)data[0]/AccelScaleFactor; Ay = (double)data[1]/AccelScaleFactor; Az = (double)data[2]/AccelScaleFactor; T = (double)data[3]/340+36.53; Gx = (double)data[4]/GyroScaleFactor; Gy = (double)data[5]/GyroScaleFactor; Gz = (double)data[6]/GyroScaleFactor; //输出三轴加速度 Serial.print(\\\" Ax:\\\"); Serial.print(Ax);Serial.print(\\\",\\\"); Serial.print(\\\" Ay:\\\"); Serial.print(Ay);Serial.print(\\\",\\\"); Serial.print(\\\" Az:\\\"); Serial.print(Az);Serial.print(\\\",\\\"); //输出三轴角度 Serial.print(\\\" Gx:\\\"); Serial.print(Gx);Serial.print(\\\",\\\"); Serial.print(\\\" Gy:\\\"); Serial.print(Gy);Serial.print(\\\",\\\"); Serial.print(\\\" Gz:\\\"); Serial.print(Gz);Serial.print(\\\",\\\"); //输出温度 Serial.print(\\\" T:\\\"); Serial.print(T); //换行 Serial.print(\\\"\\\\r\\\\n\\\"); //延时 delay(50); } \"]},\"195\":{\"h\":\"输出结果\",\"t\":[\"在串口监视器中将波特率调至9600，可观察到当前状态和温度，如下图:\",\"串口打印\"]},\"196\":{\"h\":\"控制舵机\"},\"197\":{\"h\":\"简介\",\"t\":[\"本章介绍使用 Air001 开发板在 Arduino 平台上实现驱动舵机的方法。\",\"提示\",\"SG90舵机是一种位置（角度）伺服的驱动器，适用于需要角度不断变化并可以保持的控制系统。\"]},\"198\":{\"h\":\"硬件准备\",\"t\":[\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接。\",\"SG90舵机一个，air001开发板一块，接线示意如下：\",\"SG90\",\"air001\",\"棕色\",\"GND\",\"红色\",\"3.3V\",\"黄色\",\"PWM\",\"提示\",\"你也可以使用其他可通过PWM控制的舵机型号。\"]},\"199\":{\"h\":\"软件部分\",\"t\":[\"提示\",\"Servo库为 AirMCU 软件包自带\",\"代码如下\",\"开头通过#include调用Servo包，并实例化对象my_servo，后续仅需调用my_servo对象即可启动舵机，\",\"#include <Servo.h> Servo my_servo; \",\"在setup()函数中设置my_servo使用引脚PB_3来输出PWM：\",\"void setup() { my_servo.attach(PB_3); } \",\"在loop()函数中添加如下代码：\",\"void loop() { my_servo.write(0); delay(1000); my_servo.write(90); delay(1000); my_servo.write(180); delay(1000); my_servo.write(90); delay(1000); my_servo.write(0); delay(1000); } \",\"使用write方法，设置舵机旋转。其中变量即为旋转角度。\",\"使用delay函数延时1秒。\",\"注意\",\"write方法中传入的变量为绝对角度。 本例中观察到的现象应为：顺时针旋转90°两次、再逆时针旋转90°两次。\"]},\"200\":{\"h\":\"输出结果\",\"t\":[\"舵机旋转\"]},\"201\":{\"h\":\"温湿度计 SHT30\"},\"202\":{\"h\":\"简介\",\"t\":[\"本章介绍使用Air001开发板驱动SHT30。\",\"提示\",\"SHT30是一款使用I²C通信接口的温湿度传感器。\"]},\"203\":{\"h\":\"硬件准备\",\"t\":[\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接。\",\"将SHT30模块与Air001开发板，按如下表格进行相连：\",\"SHT30\",\"Air001\",\"GND\",\"GND\",\"VCC\",\"3.3V\",\"SCL\",\"PF_1\",\"SDA\",\"PF_0\",\"提示\",\"I²C的SCL与SDA需要有上拉电阻，请确认外接的SHT30模块上有相应处理。\"]},\"204\":{\"h\":\"软件部分\",\"t\":[\"代码如下:\",\"#include <Wire.h> //SHT30 I²C通信从机地址为0x44 #define Addr_SHT30 0x44 void setup() { //设定SCL和SDA引脚 Wire.setSDA(PF_0); Wire.setSCL(PF_1); //初始化I²C Wire.begin(); //设定波特率为9600 Serial.begin(9600); //延时 delay(300); } void loop() { //定义数组以存储获取的6个数据 unsigned char data[6]; //开始传输，设置I²C从机地址 Wire.beginTransmission(Addr_SHT30); //发送测量命令0x2C06,由于一次只能发一个8位数据，因此分开发两次 Wire.write(0x2C); Wire.write(0x06); //I²C停止 Wire.endTransmission(); //延时（等待测量数据） delay(500); //请求获取6字节的数据，传入对应的从机地址 Wire.requestFrom(Addr_SHT30, 6); //判断是否成功读取到6个字节 if (Wire.available() == 6) { //成功读取，则将数据存入data数组 for (int i = 0; i <= 5; i++) { data[i] = Wire.read(); } } else { //读取失败则打印\\\"error!\\\" Serial.println(\\\"error!\\\"); return; } //计算得到的数据将其转化为直观的温度和湿度，公式参考下方说明 int cTemp = ((((data[0] * 256) + data[1]) * 175) / 65535) - 45; int humidity = ((((data[3] * 256) + data[4]) * 100) / 65535); //在串口里输出得到的数据 Serial.printf(\\\"湿度：%d%%RH\\\\n\\\",humidity); Serial.printf(\\\"温度：%d℃\\\",cTemp); //延时 delay(500); } \",\"温湿度计算公式可以参考官方文档：\",\"计算公式\"]},\"205\":{\"h\":\"输出结果\",\"t\":[\"在串口监视器中将波特率调至9600，可观察到当前温湿度，如下图:\",\"串口打印\"]},\"206\":{\"h\":\"OLED屏 SSD1306\"},\"207\":{\"h\":\"简介\",\"t\":[\"本章介绍使用 Air001 开发板在 Arduino 平台上点亮SSD1306屏幕的使用方法。\"]},\"208\":{\"h\":\"硬件准备\",\"t\":[\"Air001开发板一块、I²C接口的OLED屏幕（SSD1306驱动）一块。\",\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接。\",\"将OLED屏幕模块与Air001开发板，按如下表格进行相连：\",\"SSD1306\",\"air001\",\"GND\",\"GND\",\"VCC\",\"3.3V\",\"D0(SCL)\",\"PF01\",\"D1(SDA)\",\"PF00\",\"RES\",\"空\",\"DC\",\"VCC/GND\",\"CS\",\"GND\",\"提示\",\"DC连接可以决定I²C从机地址：\",\"DC连接VCC则I²C从机地址为0x3d\",\"DC连接GND则I²C从机地址为0x3c\"]},\"209\":{\"h\":\"软件部分\",\"t\":[\"首先，安装Adafruit GFX Library库与Adafruit SSD1306库。\",\"打开Arduino管理库，进行安装\",\"可以打开Arduino管理库，找到Adafruit GFX Library库和Adafruit SSD1306库并进行安装。\",\"库管理器中的 Adafruit GFX Library\",\"首先引用这些库，并定义：\",\"#include <SPI.h> #include <Wire.h> #include <Adafruit_GFX.h> #include <Adafruit_SSD1306.h> #define SCREEN_WIDTH 128 #define SCREEN_HEIGHT 64 #define OLED_RESET 4 Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET); \",\"定义 SCREEN_WIDTH(OLED显示宽度)，以像素为单位。\",\"定义 SCREEN_HEIGHT(OLED显示高度)，以像素为单位。\",\"初始化了一个SSD1306型号的显示器，使该显示器具SCREEN_WIDTH和SCREEN_HEIGHT指定的宽度和高度。\",\"接着，在setup()函数中，添加如下代码：\",\"void setup() { Serial.begin(9600); if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { Serial.println(\\\"SSD1306 allocation failed\\\"); while(1); } display.clearDisplay(); ShowText(); } \",\"初始化串口为9600波特率用于输出日志。\",\"使用display.begin初始化屏幕设备，如果初始化失败，打印SSD1306 allocation failed，并阻塞代码。\",\"使用display.clearDisplay清空屏幕信息。\",\"调用ShowText函数，显示数据（函数见下方）。\",\"接着声明ShowText函数，用于打印数据：\",\"void ShowText(void) { //清空屏幕信息 display.clearDisplay(); //设置文本字体大小为2 display.setTextSize(2); //设置屏幕颜色为白色 display.setTextColor(SSD1306_WHITE); //设置打印的起始坐标10,16 display.setCursor(10, 16); //设置显示的文本信息 display.println(F(\\\"happy day\\\")); //将屏幕缓冲区数据刷到屏幕上，显示出来 display.display(); } \",\"最后加上loop函数，由于只是演示，所以这里我们用空函数实现：\",\"void loop() {} \"]},\"210\":{\"h\":\"输出结果\",\"t\":[\"屏幕显示效果：\",\"效果图\"]},\"211\":{\"h\":\"LCD彩屏 ST7735\"},\"212\":{\"h\":\"简介\",\"t\":[\"本章介绍使用Air001开发板驱动ST7735。\",\"提示\",\"ST7735是一款具有SPI接口的彩色TFT液晶显示驱动芯片。\"]},\"213\":{\"h\":\"硬件准备\",\"t\":[\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接。\",\"将ST7735模块与Air001开发板，按如下表格进行相连：\",\"ST7735\",\"Air001\",\"GND\",\"GND\",\"VCC\",\"3.3V\",\"CLK\",\"PA_5\",\"MOSI(DAT)\",\"PA_7\",\"RES\",\"PA_6\",\"DC\",\"PB_1\",\"CS\",\"PA_4\",\"BL\",\"PB_0\"]},\"214\":{\"h\":\"软件部分\",\"t\":[\"在Arduino的库管理中搜索并安装Adafruit ST7735 and ST7789 Library，并选择全部安装以安装所需依赖。\",\"打开Arduino管理库，进行安装\",\"搜索Adafruit ST7735 and ST7789 Library包\",\"全部安装\",\"首先引用这些库，并定义需要用的参数：\",\"#include <Adafruit_GFX.h> #include <Adafruit_ST7735.h> #include <SPI.h> #define TFT_CS PA_4 #define TFT_RST PA_6 #define TFT_DC PB_1 #define TFT_MOSI PA_7 #define TFT_SCLK PA_5 #define SerialDebugging true Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_MOSI, TFT_SCLK, TFT_RST); const uint8_t Button_pin = PB_6; \",\"开头我们用调用下载的Adafruit_GFX.h、Adafruit_ST7735.h包以及Arduino自带的SPI.h包。\",\"依据Air001的接线，定义相关引脚。\",\"实例化同时初始化Adafruit_ST7735的对象tft，后续仅需调用tft即可驱动ST7735。\",\"将Air001开发板上的BOOT按钮对应的引脚PB_6定义为屏幕响应按键。\",\"const uint16_t Display_Color_Black = 0x0000; //黑 const uint16_t Display_Color_Blue = 0x001F; //蓝 uint16_t Display_Text_Color = Display_Color_Black; uint16_t Display_Backround_Color = Display_Color_Blue; \",\"我们用cosnt定义颜色并防止其被更改。\",\"定义文本颜色和背景颜色。\",\"提示\",\"可以使用(包括但不限于)如下代码定义其他颜色：\",\"const uint16_t Display_Color_Red = 0xF800; //红 const uint16_t Display_Color_Cyan = 0x07FF; //青 const uint16_t Display_Color_Green = 0x07E0; //绿 const uint16_t Display_Color_White = 0xFFFF; //白 const uint16_t Display_Color_Yellow = 0xFFE0; //黄 const uint16_t Display_Color_Magenta = 0xF81F; //粉 \",\"这里的颜色格式为RGB565，每个像素用16比特位表示，占2个字节，RGB分量分别使用5位、6位、5位。\",\"const size_t MaxString = 32; char oldTimeString[MaxString] = { 0 }; \",\"定义字符串缓冲区大小。\",\"初始空的字符串，用于显示。\",\"我们在setup()函数中添加如下代码进行初始化操作。\",\"void setup() { //SerialDebugging在开头被定义为TRUE，这片宏定义区域生效 #if (SerialDebugging) //初始化串口，用于输出日志 Serial.begin(115200); while (!Serial); Serial.println(); #endif delay(250); //初始化屏幕 tft.initR(INITR_BLACKTAB); //初始化字体 tft.setFont(); //用蓝色填充屏幕 tft.fillScreen(Display_Backround_Color); //设定文字颜色 tft.setTextColor(Display_Text_Color); //设定文字大小 tft.setTextSize(2); } \",\"定义displayUpTime函数，内容如下：\",\"void displayUpTime() { unsigned long upSeconds = millis() / 1000; unsigned long days = upSeconds / 86400; upSeconds = upSeconds % 86400; unsigned long hours = upSeconds / 3600; upSeconds = upSeconds % 3600; unsigned long minutes = upSeconds / 60; upSeconds = upSeconds % 60; char newTimeString[MaxString] = { 0 }; sprintf( newTimeString, \\\"%lu %02lu:%02lu:%02lu\\\", days, hours, minutes, upSeconds ); if (strcmp(newTimeString,oldTimeString) != 0) { tft.setCursor(0,0); tft.setTextColor(Display_Backround_Color); tft.print(oldTimeString); tft.setCursor(0,0); tft.setTextColor(Display_Text_Color); tft.print(newTimeString); strcpy(oldTimeString,newTimeString); } } \",\"计算显示的天数、小时、分钟、秒钟,将其显示并刷新(每次刷新消耗约2.5s)。\",\"最后在loop()函数中添加代码。\",\"void loop() { //显示当前的时间 displayUpTime(); delay(100); } \",\"调用函数displayUpTime输出显示当前时间。\",\"延时\"]},\"215\":{\"h\":\"输出结果\",\"t\":[\"屏幕底色为蓝色，在最上方显示一行黑色的显示时长：\",\"注意，某些屏幕需要更改偏移值，不然会像这块屏幕一样有彩边\",\"同时在串口监视器中将波特率调为115200可观察到如下字样：\",\"日志\"]},\"216\":{\"h\":\"数码管 TM1637\"},\"217\":{\"h\":\"简介\",\"t\":[\"本文将介绍使用 Air001 开发板驱动TM1637四位数码管模块。\",\"提示\",\"TM1637LED数码管驱动芯片，是一种带键盘扫描接口的LED数码管驱动控制专用电路。\"]},\"218\":{\"h\":\"硬件准备\",\"t\":[\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接。\",\"将TM1637LED数码管驱动模块与Air001开发板，按如下表格进行相连：\",\"TM1637\",\"Air001\",\"CLK\",\"PA14\",\"DIO\",\"PA13\",\"VCC\",\"VBUS(5V)\",\"GND\",\"GND\"]},\"219\":{\"h\":\"软件部分\",\"t\":[\"我们需要使用Grove_4Digital_Display库来驱动数码管模块，导入这个包到Arduino IDE中。\",\"将库添加到Arduino IDE中\",\"首先下载Grove_4Digital_Display的ZIP包到本地目录。\",\"点击Arduino IDE上方菜单的项目选项。\",\"点击菜单中的导入库>。\",\"点击添加.ZIP库…。\",\"选择之前下载的zip压缩文件，即可完成添加库。\",\"开头添加如下代码。\",\"#include \\\"TM1637.h\\\" #define CLK PA_14 #define DIO PA_13 int i; TM1637 tm1637(CLK, DIO); \",\"首先通过#include调用下载的TM1637.h软件包。\",\"定义CLK和DIO的值，按照之前的接线方法，为Air001开发板上的对应pin脚PA_14和PA_13。\",\"初始化对象tm1637，传入刚刚定义的CLK和DIO，后续仅需调用tm1637对象即可操作数码管。\",\"在setup()函数中添加如下代码进行初始化操作。\",\"void setup() { tm1637.init(); tm1637.point(1); tm1637.set(2); } \",\"我们用init方法初始化tm1637。\",\"用point方法控制四位数码管中间的冒号显示，并设置为1为打开（若设置为0则关闭）。\",\"用set方法来调节数码管亮度，有0~7七个亮度等级，数字越大越亮。\",\"最后在loop()函数中添加代码。\",\"void loop() { tm1637.display(0, 1); tm1637.display(1, 2); tm1637.display(2, 3); tm1637.display(3, 4); } \",\"用display方法，来更改某一位显示的值。\",\"注意\",\"位数从0开始，即第一位为0，第二位为1，依此类推。\"]},\"220\":{\"h\":\"输出结果\",\"t\":[\"可观察到四位数码管显示12:34。\"]},\"221\":{\"h\":\"彩色灯珠 WS2812\"},\"222\":{\"h\":\"简介\",\"t\":[\"本章介绍使用Air001开发板驱动 WS2812 灯。\",\"提示\",\"WS2812 是一个三色 LED 驱动芯片，一般集成在 LED 灯珠中。 它仅需一个 IO 传输数据，可通过多个 LED 串联传递信号，实现批量控制。\"]},\"223\":{\"h\":\"硬件准备\",\"t\":[\"按☁️ Air001开发板入门，将Air001和DAPLink调试器使用排针排母连接。\",\"将Air001开发板的 USB 插入一根数据线，用向灯板提供 5V 电压。\",\"将WS2812LED 模块与Air001开发板，按如下表格进行相连：\",\"WS2812 模块\",\"Air001\",\"GND\",\"GND\",\"VCC\",\"VBUS(5V)\",\"DIN\",\"PA_7\",\"提示\",\"由于 WS2812 的时序要求相对严格，我们将使用 SPI 的 MOSI 引脚（PA_7）对其进行驱动。\"]},\"224\":{\"h\":\"软件部分\",\"t\":[\"查阅资料，我们可以得知WS2812需要严格的时序，我们将参考此处的代码，使用 SPI 进行驱动。\",\"WS2812 的控制时序，此处不作深入讲解\",\"文档时序内容\",\"首先，为了保证 SPI 频率在 8MHz，我们需要将芯片的主频设置为 16M，这样只要设置 SPI 二分频即可实现输出为 8MHz。\",\"在Arduino中设置芯片主频\",\"设置芯片主频\",\"我们在代码开头，引用库与定义需要使用的全局量：\",\"#include<SPI.h> //LED灯的个数 #define LED_N 64 //用于存储当前LED灯的状态，默认全为(0,0,0)不亮 unsigned char LED_T[LED_N][3] = {0}; \",\"这里的LED_T用于存储当前的LED灯颜色数据，可以在刷新时一次性将所有状态全部发给WS2812。\",\"在setup初始化函数中，我们初始化一下SPI，并将灯的状态初始化（全部熄灭）：\",\"void setup (void) { //初始化SPI SPI.begin(); SPI.setBitOrder(MSBFIRST); SPI.setDataMode(SPI_MODE1); // 这里需要让SPI处于8MHz // 所以芯片要设置16M，SPI配置为2分频： // 16/2=8MHz SPI.setClockDivider(SPI_CLOCK_DIV2); delay(10); //刷新一下所有灯的状态，函数见文档接下来的内容 WS2812_refresh(); } \",\"这里的重点是SPI.setClockDivider函数，它设置了 SPI 频率在 8MHz。SPI.setBitOrder和SPI.setDataMode的配置，也保证了后续模拟时序的正确性。\",\"接下来是真正模拟WS2812时序的函数，这个函数传入 RGB 值，转换为信号进行发送：\",\"void WS2812_send(unsigned char r, unsigned char g, unsigned char b) { unsigned char bits = 24; unsigned long value = 0x00000000; value = (((unsigned long)g << 16) | ((unsigned long)r << 8) | ((unsigned long)b)); while (bits > 0) { if ((value & 0x800000) != LOW) { SPI.transfer(0xF8);//1 asm(\\\"nop\\\"); asm(\\\"nop\\\"); } else { SPI.transfer(0xC0);//0 } value <<= 1; bits--; } } \",\"由于WS2812灯珠是串在一起进行通信的，当需要控制所有灯珠时，只要将颜色数据一个个发送出去就可以了。 所以WS2812_refresh刷新函数就像下面这样，依次发送颜色数据：\",\"void WS2812_refresh() { unsigned int n = 0; for (n = 0; n < LED_N; n++) { WS2812_send(LED_T[n][0], LED_T[n][1], LED_T[n][2]); } delayMicroseconds(60); } \",\"最后我们在loop函数中，简单写一个按顺序亮灯的小功能：\",\"int count = 0; void loop(void) { count++; //把上一次亮的灯灭了 LED_T[(count-1)%LED_N][0] = 0; LED_T[(count-1)%LED_N][1] = 0; LED_T[(count-1)%LED_N][2] = 0; //点亮这次的这个灯 //来个浅蓝色吧 //亮度低一点，不然刺眼 LED_T[count%LED_N][0] = 5; //R LED_T[count%LED_N][1] = 5; //G LED_T[count%LED_N][2] = 20;//B //刷新所有灯的状态 WS2812_refresh(); //延时一小会 delay(10); } \"]},\"225\":{\"h\":\"输出结果\",\"t\":[\"可以看到，灯会按顺序闪烁：\",\"灯按顺序亮起\"]},\"226\":{\"h\":\"高级参数\"},\"227\":{\"h\":\"-t, --trace\",\"t\":[\"如果加上了这个参数，表示会打印出详细的 DEBUG 信息。\"]},\"228\":{\"h\":\"--connect-attempts <次数>\",\"t\":[\"最大重试次数，默认为10次，0表示无限次。\"]},\"229\":{\"h\":\"--before <default_reset|direct_connect>\",\"t\":[\"下载前的操作，用于让芯片自动进入 BOOT 模式：\",\"default_reset：Air001 开发板的默认控制方式，由于需要兼容 Arduino IDE 的串口查看器，所以使用了特殊的 ISP 控制电路，进入 BOOT 时需要使用特殊的时序控制方法。\",\"direct_connect：串口的 DTR 连接 BOOT0 ，RTS 连接 RST，直接控制设备进入 BOOT 模式。\"]},\"230\":{\"h\":\"--after <default_reset|direct_connect>\",\"t\":[\"下载完成后的操作，用于让芯片自动重启运行代码：\",\"default_reset：Air001 开发板的默认控制方式，原因参考上一小节。\",\"direct_connect：串口的 RTS 连接 RST，直接控制设备重启。\"]},\"231\":{\"h\":\"环境变量\"},\"232\":{\"h\":\"ENG_LANG\",\"t\":[\"当ENG_LANG环境变量为1时，将强制将输出打印的信息更改为英文；否则将按系统语言自动判断为中文还是英文。\"]},\"233\":{\"h\":\"基础参数\",\"t\":[\"在获取AiISP工具后，我们就可以简单测试工具了，需要注意这几个基础参数。\"]},\"234\":{\"h\":\"-c, --chip <目标芯片型号>\",\"t\":[\"该参数用来指示当前的芯片型号，填上支持的芯片型号或者使用auto自动识别芯片。目前支持以下芯片：\",\"芯片名称\",\"是否支持\",\"air001\",\"✅\",\"air32f103\",\"🔨\"]},\"235\":{\"h\":\"-p, --port <串口名称>\",\"t\":[\"该参数用来指示是所有的串口名称，如COM12、/dev/ttyUSB2。\"]},\"236\":{\"h\":\"-b, --baud <串口波特率>\",\"t\":[\"该参数用来表示通信时需要使用的波特率，如若使用不带外置晶振的USB转串口芯片导致通信失败，可能需要降低波特率再试，比如9600。\"]},\"237\":{\"h\":\"工具命令\"},\"238\":{\"h\":\"chip_id\",\"t\":[\"获取芯片 ID\"]},\"239\":{\"h\":\"get\",\"t\":[\"获取芯片 ISP 版本和支持的命令列表。\"]},\"240\":{\"h\":\"get_version\",\"t\":[\"获取芯片 ISP 版本和芯片读保护状态。\"]},\"241\":{\"h\":\"write_flash <芯片FLASH地址> <固件文件>\",\"t\":[\"向 FLASH 的指定地址开始，刷入固件，固件文件可以为HEX或BIN文件。\"]},\"242\":{\"h\":\"write_flash 命令参数\",\"t\":[\"write_flash命令有如下参数：\",\"--erase-all或者-e，作用是在烧录的时候擦除全部flash，建议添加。\",\"--no-progress或者-p，作用是在下载的时候禁止显示进度条。\",\"提示\",\"若MCU中已刷入过其他固件，烧录新固件时请务必加上-e擦除参数。\"]},\"243\":{\"h\":\"read_unprotect\",\"t\":[\"关闭 FLASH 的读保护，此时将自动擦除 FLASH 上的所有内容。\"]},\"244\":{\"h\":\"read_protect\",\"t\":[\"开启 FLASH 的读保护，此时将无法读取或写入 FLASH 的内容。\"]},\"245\":{\"h\":\"read_flash <芯片FLASH地址> <读取长度> <固件文件>\",\"t\":[\"向 FLASH 的指定地址开始，读取固件存入对应文件，固件文件只能为BIN文件。\"]},\"246\":{\"h\":\"read_flash 命令参数\",\"t\":[\"read_flash命令有如下参数：\",\"--overwrite或者-o，作用是如果文件已存在，则覆盖文件，否则拒绝继续读取。\",\"--no-progress或者-p，作用是在下载的时候禁止显示进度条。\"]},\"247\":{\"h\":\"刷写固件\",\"t\":[\"AirISP支持烧录HEX或BIN格式的文件到芯片的 FLASH 中。\",\"我们可以使用write_flash命令来执行烧录操作，像下面这样：\",\"> .\\\\AirISP.exe -c air001 -p COM21 -b 115200 write_flash -e 0x08000000 gpio.hex AirISP v1.2.4.0 串口 COM21 连接中... Chip PID is: 0x04 0x40 擦除flash中（请耐心等待）... 擦除成功，耗时 39.5811 ms. Writing at 134219264... 100.00% Write 1536 bytes at 0x08000000 in 274.0526 ms Leaving... 通过RTS硬件复位... \"]},\"248\":{\"h\":\"write_flash 命令参数\",\"t\":[\"write_flash命令有如下参数：\",\"--erase-all或者-e，作用是在烧录的时候擦除全部flash，建议添加。\",\"--no-progress或者-p，作用是在下载的时候禁止显示进度条。\",\"提示\",\"若MCU中已刷入过其他固件，烧录新固件时请务必加上-e擦除参数。\",\"提示\",\"如若使用不带外置晶振的USB转串口芯片导致通信失败，可能需要降低波特率再试，比如9600。\"]},\"249\":{\"h\":\"安装\",\"t\":[\"我们可以前往GitHub Release页面下载最新版本的AirISP工具。\",\"Arch包管理安装\",\"Arch Linux 及其衍生版可以安装 AUR airisp-git。\",\"注：命令行名称按 Arch Linux 规范应该是小写，安装后命令行为：airisp。\",\"yay -Syu airisp \",\"AiISP工具内置了.NET运行时，所以无需手动安装额外的依赖。\",\"解压后可以得到AirISP.exe（其他系统上可能为AirISP）\",\"此时我们就可以直接使用这个工具了：\",\"> .\\\\AirISP.exe -h Description: AirISP 是一个flash烧录工具 Usage: AirISP [command] [options] Options: -c, --chip <chip> 目标芯片型号，auto/air001 -p, --port <port> 串口名称 -b, --baud <baud> 串口波特率 -t, --trace 启用trace日志输出 [default: False] --connect-attempts <connect-attempts> 最大重试次数，小于等于0表示无限次，默认为10次 [default: 10] --before <before> 下载前要执行的操作 [default: default_reset] --after <after> 下载后要执行的操作 [default: hard_reset] --version Show version information -?, -h, --help Show help and usage information Commands: chip_id 获取芯片ID get 获取ISP版本和支持的命令列表 get_version 获取ISP版本和芯片读保护状态 write_flash <address> <filename> 向flash刷入固件 read_unprotect 关闭读保护 read_protect 开启读保护 \"]},\"250\":{\"h\":\"读写保护\"},\"251\":{\"h\":\"解除读保护\",\"t\":[\"有时候我们会不小心将 MCU 的读保护打开，导致无法刷入固件，这是就需要去除读保护。\",\"我们可以使用read_unprotect命令来关闭 FLASH 的读保护，像下面这样：\",\"> .\\\\AirISP.exe -c air001 -p COM21 -b 115200 read_unprotect AirISP v1.2.4.0 串口 COM21 连接中... Leaving... 通过RTS硬件复位... \",\"注意\",\"解除读保护的操作会导致 FLASH 数据被全部擦除。\",\"提示\",\"如若使用劣质串口转USB芯片导致通信失败，需要降低波特率再试，比如9600。\"]},\"252\":{\"h\":\"启用读保护\",\"t\":[\"我们可以使用read_protect命令来开启 FLASH 的读保护，像下面这样：\",\"> .\\\\AirISP.exe -c air001 -p COM21 -b 115200 read_protect AirISP v1.2.4.0 串口 COM21 连接中... Leaving... 通过RTS硬件复位... \",\"注意\",\"开启读保护后，会导致无法使用 ISP 工具进行烧录操作，需要解除读保护后才可操作。\",\"提示\",\"如若使用劣质串口转USB芯片导致通信失败，需要降低波特率再试，比如9600。\"]},\"253\":{\"h\":\"Advanced\"},\"254\":{\"h\":\"F A Q\"},\"255\":{\"h\":\"Tutorial Advanced\"},\"256\":{\"h\":\"Tutorial Extras\"},\"257\":{\"h\":\"Docs\"}},\"dirtCount\":0,\"index\":[[\"q\",{\"0\":{\"254\":1}}],[\"quantity\",{\"1\":{\"88\":4}}],[\"导致无法刷入固件\",{\"1\":{\"251\":1}}],[\"导入这个包到arduino\",{\"1\":{\"219\":1}}],[\"像下面这样\",{\"1\":{\"247\":1,\"251\":1,\"252\":1}}],[\"否则拒绝继续读取\",{\"1\":{\"246\":1}}],[\"否则将按系统语言自动判断为中文还是英文\",{\"1\":{\"232\":1}}],[\"固件文件只能为bin文件\",{\"1\":{\"245\":1}}],[\"固件文件可以为hex或bin文件\",{\"1\":{\"241\":1}}],[\"作用是如果文件已存在\",{\"1\":{\"246\":1}}],[\"作用是在下载的时候禁止显示进度条\",{\"1\":{\"242\":1,\"246\":1,\"248\":1}}],[\"作用是在烧录的时候擦除全部flash\",{\"1\":{\"242\":1,\"248\":1}}],[\"作为从模式\",{\"1\":{\"91\":1}}],[\"作为例子\",{\"1\":{\"2\":1}}],[\"刷写固件\",{\"0\":{\"247\":1}}],[\"刷入固件\",{\"1\":{\"241\":1}}],[\"刷新所有灯的状态\",{\"1\":{\"224\":1}}],[\"刷新一下所有灯的状态\",{\"1\":{\"224\":1}}],[\"向\",{\"1\":{\"241\":1,\"245\":1}}],[\"向flash刷入固件\",{\"1\":{\"9\":1,\"249\":1}}],[\"版本和芯片读保护状态\",{\"1\":{\"240\":1}}],[\"版本和支持的命令列表\",{\"1\":{\"239\":1}}],[\"芯片名称\",{\"1\":{\"234\":1}}],[\"芯片型号我们以air001\",{\"1\":{\"6\":1}}],[\"填上支持的芯片型号或者使用auto自动识别芯片\",{\"1\":{\"234\":1}}],[\"基础参数\",{\"0\":{\"233\":1}}],[\"基本用法\",{\"0\":{\"83\":1,\"91\":1}}],[\"环境变量\",{\"0\":{\"231\":1}}],[\"环境的情况下\",{\"1\":{\"5\":1}}],[\"原因参考上一小节\",{\"1\":{\"230\":1}}],[\"原始值\",{\"1\":{\"35\":1}}],[\"控制电路\",{\"1\":{\"229\":1}}],[\"控制舵机\",{\"0\":{\"196\":1}}],[\"信息\",{\"1\":{\"227\":1}}],[\"表示会打印出详细的\",{\"1\":{\"227\":1}}],[\"高级参数\",{\"0\":{\"226\":1}}],[\"高电平\",{\"1\":{\"189\":1}}],[\"亮度低一点\",{\"1\":{\"224\":1}}],[\"把上一次亮的灯灭了\",{\"1\":{\"224\":1}}],[\"转换为信号进行发送\",{\"1\":{\"224\":1}}],[\"值\",{\"1\":{\"224\":1}}],[\"二分频即可实现输出为\",{\"1\":{\"224\":1}}],[\"查阅资料\",{\"1\":{\"224\":1}}],[\"查看效果\",{\"0\":{\"163\":1}}],[\"查看串口输出\",{\"0\":{\"157\":1}}],[\"电压\",{\"1\":{\"223\":1}}],[\"电阻支持内部上拉和下拉\",{\"1\":{\"63\":1}}],[\"驱动芯片\",{\"1\":{\"222\":1}}],[\"驱动程序自动清除\",{\"1\":{\"127\":1}}],[\"灯按顺序亮起\",{\"1\":{\"225\":1}}],[\"灯会按顺序闪烁\",{\"1\":{\"225\":1}}],[\"灯珠中\",{\"1\":{\"222\":1}}],[\"灯\",{\"1\":{\"222\":1}}],[\"灯正常闪烁\",{\"1\":{\"185\":1}}],[\"彩色灯珠\",{\"0\":{\"221\":1}}],[\"依次发送颜色数据\",{\"1\":{\"224\":1}}],[\"依此类推\",{\"1\":{\"219\":1}}],[\"依据air001的接线\",{\"1\":{\"214\":1}}],[\"依据加速度计和陀螺仪的量程设定精度\",{\"1\":{\"194\":1}}],[\"第二位为1\",{\"1\":{\"219\":1}}],[\"第一步是将\",{\"1\":{\"83\":1,\"91\":1}}],[\"日志\",{\"1\":{\"215\":1}}],[\"某些屏幕需要更改偏移值\",{\"1\":{\"215\":1}}],[\"屏幕底色为蓝色\",{\"1\":{\"215\":1}}],[\"屏幕显示效果\",{\"1\":{\"210\":1}}],[\"秒钟\",{\"1\":{\"214\":1}}],[\"内容如下\",{\"1\":{\"214\":1}}],[\"内部整合了三轴mems陀螺仪\",{\"1\":{\"192\":1}}],[\"内部地址大小\",{\"1\":{\"88\":1}}],[\"内部地址\",{\"1\":{\"88\":1}}],[\"内部上拉和下拉\",{\"0\":{\"63\":1}}],[\"内部参考电压\",{\"1\":{\"35\":1}}],[\"内部温度传感器\",{\"1\":{\"35\":1}}],[\"内部\",{\"1\":{\"17\":1}}],[\"初始空的字符串\",{\"1\":{\"214\":1}}],[\"初始化spi\",{\"1\":{\"224\":1}}],[\"初始化对象tm1637\",{\"1\":{\"219\":1}}],[\"初始化字体\",{\"1\":{\"214\":1}}],[\"初始化屏幕\",{\"1\":{\"214\":1}}],[\"初始化了一个ssd1306型号的显示器\",{\"1\":{\"209\":1}}],[\"初始化i²c\",{\"1\":{\"204\":1}}],[\"初始化i²c接口\",{\"1\":{\"194\":1}}],[\"初始化加速度计参数\",{\"1\":{\"194\":1}}],[\"初始化陀螺仪参数\",{\"1\":{\"194\":1}}],[\"初始化传感器库\",{\"1\":{\"177\":1}}],[\"初始化一个传感器对象\",{\"1\":{\"177\":1}}],[\"初始化一个单总线对象\",{\"1\":{\"177\":1}}],[\"初始化设备\",{\"1\":{\"172\":1}}],[\"初始化串口为9600波特率用于输出日志\",{\"1\":{\"209\":1}}],[\"初始化串口为9600波特率\",{\"1\":{\"182\":1,\"184\":1}}],[\"初始化串口\",{\"1\":{\"172\":1,\"177\":1,\"194\":1,\"214\":1}}],[\"初始化\",{\"1\":{\"116\":1,\"118\":1}}],[\"占2个字节\",{\"1\":{\"214\":1}}],[\"占空比以百分比为单位\",{\"1\":{\"127\":1}}],[\"占空比\",{\"1\":{\"103\":1}}],[\"粉\",{\"1\":{\"214\":1}}],[\"黄\",{\"1\":{\"214\":1}}],[\"黄色\",{\"1\":{\"198\":1}}],[\"白\",{\"1\":{\"214\":1}}],[\"绿\",{\"1\":{\"214\":1}}],[\"青\",{\"1\":{\"214\":1}}],[\"红\",{\"1\":{\"214\":1}}],[\"红色\",{\"1\":{\"198\":1}}],[\"蓝\",{\"1\":{\"214\":1}}],[\"黑\",{\"1\":{\"214\":1}}],[\"效果图\",{\"1\":{\"210\":1}}],[\"清空屏幕信息\",{\"1\":{\"209\":1}}],[\"显示当前的时间\",{\"1\":{\"214\":1}}],[\"显示出来\",{\"1\":{\"209\":1}}],[\"显示数据\",{\"1\":{\"209\":1}}],[\"显示器\",{\"1\":{\"73\":1}}],[\"使该显示器具screen\",{\"1\":{\"209\":1}}],[\"使用write方法\",{\"1\":{\"199\":1}}],[\"使用display\",{\"1\":{\"209\":2}}],[\"使用digitalwrite函数来控制这三个gpio的数出状态\",{\"1\":{\"189\":1}}],[\"使用delay函数延时1秒\",{\"1\":{\"199\":1}}],[\"使用delay\",{\"1\":{\"189\":2}}],[\"使用attachinterrupt函数初始化一个中断事件\",{\"1\":{\"184\":1}}],[\"使用pinmode函数初始化pb6这个gpio\",{\"1\":{\"182\":1}}],[\"使用sensors\",{\"1\":{\"177\":2}}],[\"使用刚新建的单总线对象\",{\"1\":{\"177\":1}}],[\"使用1wire\",{\"1\":{\"175\":1}}],[\"使用bmp\",{\"1\":{\"172\":3}}],[\"使用i²c通信接口\",{\"1\":{\"170\":1}}],[\"使用i2c\",{\"1\":{\"87\":1}}],[\"使用串口下载\",{\"1\":{\"154\":1}}],[\"使用串口连接上板子usb另一头的串口引脚\",{\"1\":{\"154\":1}}],[\"使用之前有用\",{\"1\":{\"140\":1}}],[\"使用方式\",{\"0\":{\"127\":1}}],[\"使用该库假设您对\",{\"1\":{\"125\":1}}],[\"使用多个\",{\"1\":{\"118\":1}}],[\"使用的频率\",{\"1\":{\"105\":1}}],[\"使用函数\",{\"1\":{\"87\":1}}],[\"使用这种方法可以直接读写\",{\"1\":{\"55\":1}}],[\"使用\",{\"0\":{\"1\":1,\"149\":1},\"1\":{\"118\":1,\"127\":1,\"224\":1}}],[\"空\",{\"1\":{\"208\":1}}],[\"平台上点亮ssd1306屏幕的使用方法\",{\"1\":{\"207\":1}}],[\"平台上实现驱动舵机的方法\",{\"1\":{\"197\":1}}],[\"湿度\",{\"1\":{\"204\":1}}],[\"公式参考下方说明\",{\"1\":{\"204\":1}}],[\"公共仓库\",{\"1\":{\"17\":1}}],[\"成功读取\",{\"1\":{\"204\":1}}],[\"判断是否成功读取到6个字节\",{\"1\":{\"204\":1}}],[\"传入刚刚定义的clk和dio\",{\"1\":{\"219\":1}}],[\"传入对应的从机地址\",{\"1\":{\"204\":1}}],[\"传输数据\",{\"1\":{\"222\":1}}],[\"传输\",{\"1\":{\"86\":1}}],[\"温湿度计算公式可以参考官方文档\",{\"1\":{\"204\":1}}],[\"温湿度计\",{\"0\":{\"201\":1}}],[\"温度传感器\",{\"0\":{\"174\":1}}],[\"温度\",{\"1\":{\"172\":1,\"194\":1,\"204\":1}}],[\"舵机旋转\",{\"1\":{\"200\":1}}],[\"顺时针旋转90°两次\",{\"1\":{\"199\":1}}],[\"软件包自带\",{\"1\":{\"199\":1}}],[\"软件部分\",{\"0\":{\"167\":1,\"172\":1,\"177\":1,\"182\":1,\"189\":1,\"194\":1,\"199\":1,\"204\":1,\"209\":1,\"214\":1,\"219\":1,\"224\":1}}],[\"你也可以使用其他可通过pwm控制的舵机型号\",{\"1\":{\"198\":1}}],[\"你需要为dq进行上拉操作\",{\"1\":{\"176\":1}}],[\"你需要保证项目文件的路径也不能包含中文或空格\",{\"1\":{\"148\":1}}],[\"你需要确保\",{\"1\":{\"145\":1}}],[\"棕色\",{\"1\":{\"198\":1}}],[\"适用于需要角度不断变化并可以保持的控制系统\",{\"1\":{\"197\":1}}],[\"伺服的驱动器\",{\"1\":{\"197\":1}}],[\"角度\",{\"1\":{\"197\":1}}],[\"延时一小会\",{\"1\":{\"224\":1}}],[\"延时一秒\",{\"1\":{\"189\":2}}],[\"延时\",{\"1\":{\"194\":1,\"204\":3,\"214\":1}}],[\"换行\",{\"1\":{\"194\":1}}],[\"声明双精度实型变量三轴加速度\",{\"1\":{\"194\":1}}],[\"设定文字大小\",{\"1\":{\"214\":1}}],[\"设定文字颜色\",{\"1\":{\"214\":1}}],[\"设定波特率为9600\",{\"1\":{\"204\":1}}],[\"设定scl和sda引脚\",{\"1\":{\"204\":1}}],[\"设定scl\",{\"1\":{\"194\":1}}],[\"设置显示的文本信息\",{\"1\":{\"209\":1}}],[\"设置打印的起始坐标10\",{\"1\":{\"209\":1}}],[\"设置屏幕颜色为白色\",{\"1\":{\"209\":1}}],[\"设置文本字体大小为2\",{\"1\":{\"209\":1}}],[\"设置i²c从机地址\",{\"1\":{\"204\":1}}],[\"设置舵机旋转\",{\"1\":{\"199\":1}}],[\"设置管脚为输入\",{\"1\":{\"184\":1}}],[\"设置使用pa\",{\"1\":{\"177\":1}}],[\"设置芯片主频\",{\"1\":{\"177\":1,\"224\":1}}],[\"设置波特率\",{\"1\":{\"131\":1}}],[\"设置\",{\"1\":{\"117\":1,\"118\":1}}],[\"设置为\",{\"1\":{\"88\":3}}],[\"|\",{\"1\":{\"194\":1,\"224\":2}}],[\"赋值\",{\"1\":{\"194\":2}}],[\"结束传输\",{\"1\":{\"194\":1}}],[\"°\",{\"1\":{\"194\":4}}],[\"±2000可选\",{\"1\":{\"194\":1}}],[\"±1000\",{\"1\":{\"194\":1}}],[\"±500\",{\"1\":{\"194\":1}}],[\"陀螺仪的范围有±250\",{\"1\":{\"194\":1}}],[\"陀螺仪方向示意\",{\"1\":{\"193\":1}}],[\"加速度计的范围有2g\",{\"1\":{\"194\":1}}],[\"加速度计方向示意\",{\"1\":{\"193\":1}}],[\"小时\",{\"1\":{\"214\":1}}],[\"小球的位置偏向x轴的负向\",{\"1\":{\"193\":1}}],[\"小于等于0表示无限次\",{\"1\":{\"9\":1,\"249\":1}}],[\"假想一个不受任何外力作用的球漂浮在正方体盒子中心\",{\"1\":{\"193\":1}}],[\"竖直向上的为z轴正方向\",{\"1\":{\"193\":1}}],[\"水平指向外侧的为y轴正方向\",{\"1\":{\"193\":1}}],[\"水平向右的为x轴正方向\",{\"1\":{\"193\":1}}],[\"朝上\",{\"1\":{\"193\":1}}],[\"令芯片表面\",{\"1\":{\"193\":1}}],[\"剩余的xda\",{\"1\":{\"193\":1}}],[\"三轴加速度和温度\",{\"1\":{\"194\":1}}],[\"三轴加速度以及当前温度\",{\"1\":{\"192\":1}}],[\"三轴mems加速度计和一个内置温度传感器\",{\"1\":{\"192\":1}}],[\"低电平\",{\"1\":{\"189\":1}}],[\"分钟\",{\"1\":{\"214\":1}}],[\"分别由pb1\",{\"1\":{\"188\":1}}],[\"分支的即可\",{\"1\":{\"5\":1}}],[\"板载的三个led灯\",{\"1\":{\"188\":1}}],[\"点亮这次的这个灯\",{\"1\":{\"224\":1}}],[\"点灯\",{\"0\":{\"186\":1}}],[\"点击添加\",{\"1\":{\"219\":1}}],[\"点击菜单中的导入库>\",{\"1\":{\"219\":1}}],[\"点击电脑上的烧录按键\",{\"1\":{\"183\":1}}],[\"点击上传按钮\",{\"1\":{\"156\":1,\"162\":1}}],[\"点击arduino\",{\"1\":{\"25\":1,\"219\":1}}],[\"点击右下角ok\",{\"1\":{\"23\":1}}],[\"点击我同意\",{\"1\":{\"21\":1}}],[\"点击如图所示的区域\",{\"1\":{\"21\":1,\"22\":1}}],[\"点击f1按钮\",{\"1\":{\"6\":1,\"7\":1}}],[\"优化后的结果\",{\"0\":{\"185\":1}}],[\"优先执行中断的操作\",{\"1\":{\"184\":1}}],[\"触发标志设置为change\",{\"1\":{\"184\":1}}],[\"触发中断\",{\"1\":{\"184\":4}}],[\"会导致无法使用\",{\"1\":{\"252\":1}}],[\"会触发的中断\",{\"1\":{\"184\":1}}],[\"会将\",{\"1\":{\"60\":1}}],[\"再逆时针旋转90°两次\",{\"1\":{\"199\":1}}],[\"再继续运行当前代码\",{\"1\":{\"184\":1}}],[\"再重新插入\",{\"1\":{\"162\":1}}],[\"松开boot按键\",{\"1\":{\"183\":1}}],[\"松开时打印key\",{\"1\":{\"183\":1}}],[\"插入一根数据线\",{\"1\":{\"223\":1}}],[\"插入\",{\"1\":{\"183\":1}}],[\"插件\",{\"0\":{\"1\":1}}],[\"断开\",{\"1\":{\"183\":1}}],[\"打印ssd1306\",{\"1\":{\"209\":1}}],[\"打印key\",{\"1\":{\"183\":1}}],[\"打开串口\",{\"1\":{\"184\":1}}],[\"打开arduino管理库\",{\"1\":{\"172\":1,\"177\":1,\"209\":1,\"214\":1}}],[\"打开arduino\",{\"1\":{\"148\":1}}],[\"打开文件管理器\",{\"1\":{\"147\":1,\"148\":1}}],[\"打开\",{\"1\":{\"17\":1}}],[\"退出这次检测\",{\"1\":{\"182\":1}}],[\"存入state变量中\",{\"1\":{\"182\":1}}],[\"轮询当前\",{\"1\":{\"182\":1}}],[\"定义clk和dio的值\",{\"1\":{\"219\":1}}],[\"定义displayuptime函数\",{\"1\":{\"214\":1}}],[\"定义字符串缓冲区大小\",{\"1\":{\"214\":1}}],[\"定义文本颜色和背景颜色\",{\"1\":{\"214\":1}}],[\"定义相关引脚\",{\"1\":{\"214\":1}}],[\"定义\",{\"1\":{\"209\":2}}],[\"定义数组以存储获取的6个数据\",{\"1\":{\"204\":1}}],[\"定义数组用于存放测量的三轴角度\",{\"1\":{\"194\":1}}],[\"定义getdata函数来读取mpu6050测量的数据并依次赋给数组data\",{\"1\":{\"194\":1}}],[\"定义buttonstate变量\",{\"1\":{\"182\":1}}],[\"定时器时钟将除以该因子\",{\"1\":{\"127\":1}}],[\"尝试获取温度\",{\"1\":{\"177\":1}}],[\"尝试调低串口烧录波特率后再试\",{\"1\":{\"151\":1}}],[\"检查一下是不是真的获取成功了\",{\"1\":{\"177\":1}}],[\"发送测量命令0x2c06\",{\"1\":{\"204\":1}}],[\"发送的字节数\",{\"1\":{\"135\":2}}],[\"发出获取温度的请求\",{\"1\":{\"177\":1}}],[\"引用库与定义需要使用的全局量\",{\"1\":{\"224\":1}}],[\"引用之前定义的函数读取数据\",{\"1\":{\"194\":1}}],[\"引用必要的库\",{\"1\":{\"177\":1}}],[\"引脚名称\",{\"1\":{\"140\":2}}],[\"引脚用于发送和接收\",{\"1\":{\"140\":1}}],[\"引脚而不是第一个找到的引脚\",{\"1\":{\"138\":1}}],[\"引脚实例化\",{\"1\":{\"138\":1}}],[\"引脚管理的示例\",{\"1\":{\"123\":1}}],[\"引脚管理的可能性\",{\"1\":{\"114\":1}}],[\"引脚保持启用状态\",{\"1\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1}}],[\"引脚复位\",{\"1\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1}}],[\"引脚时要小心\",{\"1\":{\"118\":1}}],[\"引脚将保持启用状态\",{\"1\":{\"118\":1}}],[\"引脚将保持在高阻抗模式\",{\"1\":{\"63\":1}}],[\"引脚调用以下函数\",{\"1\":{\"118\":1}}],[\"引脚和关联的\",{\"1\":{\"118\":1}}],[\"引脚上\",{\"1\":{\"117\":1}}],[\"引脚的\",{\"1\":{\"115\":1}}],[\"引脚号\",{\"1\":{\"115\":4,\"116\":1,\"117\":1,\"118\":1,\"140\":2}}],[\"引脚在传输数据之前由用户代码直接管理\",{\"1\":{\"114\":1}}],[\"引脚状态从高电平变为低电平时触发中断\",{\"1\":{\"67\":1}}],[\"引脚状态从低电平变为高电平时触发中断\",{\"1\":{\"67\":1}}],[\"引脚状态发生变化时触发中断\",{\"1\":{\"67\":1}}],[\"引脚状态为低电平时触发中断\",{\"1\":{\"67\":1}}],[\"引脚状态为低电平\",{\"1\":{\"65\":1}}],[\"引脚状态为高电平时触发中断\",{\"1\":{\"67\":1}}],[\"引脚状态为高电平\",{\"1\":{\"65\":1}}],[\"引脚状态\",{\"1\":{\"65\":1}}],[\"引脚\",{\"0\":{\"98\":1},\"1\":{\"39\":1,\"77\":2,\"78\":2,\"85\":1,\"114\":2,\"115\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"141\":2,\"166\":1,\"223\":1}}],[\"引脚或\",{\"1\":{\"35\":1}}],[\"器件可以工作在\",{\"1\":{\"175\":1}}],[\"粗略计算当前的海拔高度\",{\"1\":{\"172\":1}}],[\"粗略计算海拔高度\",{\"1\":{\"172\":1}}],[\"方法\",{\"1\":{\"172\":1}}],[\"方向如图所示\",{\"1\":{\"154\":1}}],[\"米\",{\"1\":{\"172\":1}}],[\"气压\",{\"1\":{\"172\":1}}],[\"气压传感器\",{\"0\":{\"169\":1}}],[\"℃\",{\"1\":{\"172\":1,\"177\":1}}],[\"找到adafruit\",{\"1\":{\"172\":1,\"177\":1,\"209\":1}}],[\"海拔\",{\"1\":{\"172\":1}}],[\"海拔9000m至\",{\"1\":{\"170\":1}}],[\"海外用户可以使用这个\",{\"1\":{\"25\":1}}],[\"正极接引脚\",{\"1\":{\"166\":1}}],[\"地\",{\"1\":{\"166\":1}}],[\"负极接\",{\"1\":{\"166\":1}}],[\"负责控制或读取数字世界中特定引脚的状态\",{\"1\":{\"59\":1}}],[\"☁️\",{\"1\":{\"166\":1}}],[\"按照之前的接线方法\",{\"1\":{\"219\":1}}],[\"按住boot按键\",{\"1\":{\"183\":1}}],[\"按住开发板上的按键\",{\"1\":{\"162\":1}}],[\"按键输入\",{\"0\":{\"179\":1}}],[\"按如下表格进行相连\",{\"1\":{\"171\":1,\"176\":1,\"193\":1,\"203\":1,\"208\":1,\"213\":1,\"218\":1,\"223\":1}}],[\"按☁️\",{\"1\":{\"171\":1,\"176\":1,\"188\":1,\"193\":1,\"198\":1,\"203\":1,\"208\":1,\"213\":1,\"218\":1,\"223\":1}}],[\"按前文下载arduino\",{\"1\":{\"189\":1}}],[\"按前文下载\",{\"1\":{\"167\":1}}],[\"按\",{\"1\":{\"166\":1}}],[\"本例中观察到的现象应为\",{\"1\":{\"199\":1}}],[\"本章介绍使用arduino烧录air001开发板控制其上3个led灯闪烁\",{\"1\":{\"187\":1}}],[\"本章介绍使用air001开发板驱动st7735\",{\"1\":{\"212\":1}}],[\"本章介绍使用air001开发板驱动sht30\",{\"1\":{\"202\":1}}],[\"本章介绍使用air001开发板驱动mpu6050\",{\"1\":{\"192\":1}}],[\"本章介绍使用air001开发板驱动\",{\"1\":{\"170\":1,\"175\":1,\"222\":1}}],[\"本章介绍使用\",{\"1\":{\"165\":1,\"197\":1,\"207\":1}}],[\"本文将介绍使用\",{\"1\":{\"180\":1,\"217\":1}}],[\"本文将演示如何为合宙rp2040开发板进行配置与上手\",{\"1\":{\"158\":1}}],[\"本文档基于\",{\"1\":{\"29\":1}}],[\"本文仅介绍windows下的安装方式\",{\"1\":{\"20\":1}}],[\"测量\",{\"0\":{\"164\":1}}],[\"测试更多的例子\",{\"1\":{\"157\":1,\"163\":1}}],[\"测试\",{\"1\":{\"148\":6}}],[\"说明进入烧录模式成功\",{\"1\":{\"162\":1}}],[\"树莓派\",{\"0\":{\"158\":1}}],[\"那么按键打印将变得不够及时\",{\"1\":{\"184\":1}}],[\"那么可观察到led在十分快速地闪烁\",{\"1\":{\"163\":1}}],[\"那么打开串口监视器\",{\"1\":{\"157\":1}}],[\"那我们将无法接受\",{\"1\":{\"16\":1}}],[\"连接\",{\"1\":{\"229\":2,\"230\":1}}],[\"连接移除\",{\"1\":{\"162\":1}}],[\"连接后\",{\"1\":{\"154\":1}}],[\"连接中\",{\"1\":{\"9\":1,\"247\":1,\"251\":1,\"252\":1}}],[\"连上开发板\",{\"0\":{\"154\":1}}],[\"若mcu中已刷入过其他固件\",{\"1\":{\"242\":1,\"248\":1}}],[\"若设置为0则关闭\",{\"1\":{\"219\":1}}],[\"若无法自动进入\",{\"1\":{\"152\":1}}],[\"若你的用户名文件夹为中文\",{\"1\":{\"149\":1}}],[\"重新打开\",{\"1\":{\"149\":1}}],[\"重新定义i2c引脚\",{\"0\":{\"99\":1}}],[\"重新定义\",{\"1\":{\"35\":1}}],[\"保证开发板有供电\",{\"1\":{\"154\":1}}],[\"保存配置\",{\"1\":{\"148\":1}}],[\"保留此功能只是为了与现有的基于\",{\"1\":{\"36\":1}}],[\"移动后\",{\"1\":{\"147\":1}}],[\"全部熄灭\",{\"1\":{\"224\":1}}],[\"全部安装\",{\"1\":{\"177\":1,\"214\":1}}],[\"全选这里的所有文件\",{\"1\":{\"147\":1}}],[\"全双工的通信协议\",{\"1\":{\"129\":1}}],[\"回车\",{\"1\":{\"147\":1,\"148\":1}}],[\"回调\",{\"1\":{\"138\":1}}],[\"迁移当前的包文件\",{\"0\":{\"147\":1}}],[\"新建一个中断回调函数\",{\"1\":{\"184\":1}}],[\"新建一个你需要放置temp的文件夹路径\",{\"1\":{\"149\":1}}],[\"新建一个你需要放置文件的文件夹路径\",{\"1\":{\"146\":1}}],[\"新建一个不带中文路径的文件夹\",{\"0\":{\"146\":1}}],[\"处于关闭状态\",{\"1\":{\"145\":1}}],[\"解除读保护的操作会导致\",{\"1\":{\"251\":1}}],[\"解除读保护\",{\"0\":{\"251\":1}}],[\"解压后可以得到airisp\",{\"1\":{\"249\":1}}],[\"解压或安装后可以得到\",{\"1\":{\"9\":1}}],[\"解决方案\",{\"0\":{\"145\":1}}],[\"需要解除读保护后才可操作\",{\"1\":{\"252\":1}}],[\"需要降低波特率再试\",{\"1\":{\"251\":1,\"252\":1}}],[\"需要注意这几个基础参数\",{\"1\":{\"233\":1}}],[\"需要注意的是其中需要包含\",{\"1\":{\"7\":1}}],[\"需要注意的是\",{\"1\":{\"6\":1,\"138\":1}}],[\"需要将此包放置到英文路径下\",{\"1\":{\"144\":1}}],[\"报错信息\",{\"1\":{\"143\":1}}],[\"实现批量控制\",{\"1\":{\"222\":1}}],[\"实际应为中文路径名\",{\"1\":{\"143\":1}}],[\"实例化同时初始化adafruit\",{\"1\":{\"214\":1}}],[\"实例上启用\",{\"1\":{\"141\":1}}],[\"实例来定义\",{\"1\":{\"138\":1}}],[\"实例可映射到通用\",{\"1\":{\"138\":1}}],[\"实例可用\",{\"1\":{\"97\":1}}],[\"实例作为参数实例化一个对象\",{\"1\":{\"127\":1}}],[\"实例使用的默认引脚\",{\"1\":{\"124\":1,\"139\":1}}],[\"实例引脚\",{\"0\":{\"124\":1,\"139\":1}}],[\"实例后\",{\"1\":{\"118\":1}}],[\"实例都受此编译开关更改的影响\",{\"1\":{\"100\":1}}],[\"实例\",{\"1\":{\"100\":1,\"138\":2}}],[\"阶段报错\",{\"1\":{\"143\":1}}],[\"链接\",{\"1\":{\"143\":1}}],[\"问题原因\",{\"0\":{\"144\":1}}],[\"问题描述\",{\"0\":{\"143\":1}}],[\"问题报告中重复或产生不必要的噪音\",{\"1\":{\"32\":1}}],[\"问题报告\",{\"0\":{\"32\":1}}],[\"当eng\",{\"1\":{\"232\":1}}],[\"当需要控制所有灯珠时\",{\"1\":{\"224\":1}}],[\"当小球偏向任何一个方向时\",{\"1\":{\"193\":1}}],[\"当使用中断方式编写代码时\",{\"1\":{\"184\":1}}],[\"当引脚由高电平变为低电平时\",{\"1\":{\"184\":1}}],[\"当引脚由低电平变为高电平时\",{\"1\":{\"184\":1}}],[\"当引脚电平发生改变时\",{\"1\":{\"184\":1}}],[\"当引脚为低电平时\",{\"1\":{\"184\":1}}],[\"当这个函数运行完毕后\",{\"1\":{\"184\":1}}],[\"当触发onchange函数后\",{\"1\":{\"184\":1}}],[\"当中断处理完后\",{\"1\":{\"184\":1}}],[\"当按下按键时\",{\"1\":{\"183\":1}}],[\"当实例未以半双工模式实例化时\",{\"1\":{\"140\":1}}],[\"当然\",{\"1\":{\"131\":1,\"135\":1}}],[\"扩展\",{\"1\":{\"140\":1}}],[\"线路在内部连接\",{\"1\":{\"140\":1}}],[\"线需要上拉电阻\",{\"1\":{\"73\":1}}],[\"启用读保护\",{\"0\":{\"252\":1}}],[\"启用硬件流控制\",{\"0\":{\"141\":1}}],[\"启用实例的半双工模式\",{\"1\":{\"140\":1}}],[\"启用半双工模式\",{\"0\":{\"140\":1}}],[\"启用trace日志输出\",{\"1\":{\"9\":1,\"249\":1}}],[\"数据被全部擦除\",{\"1\":{\"251\":1}}],[\"数据读取失败\",{\"1\":{\"177\":1}}],[\"数字越大越亮\",{\"1\":{\"219\":1}}],[\"数字状态更改为特定设备\",{\"1\":{\"60\":1}}],[\"数码管\",{\"0\":{\"216\":1}}],[\"数组中找到的第一个\",{\"1\":{\"138\":1}}],[\"另一个解决方案是在主\",{\"1\":{\"138\":1}}],[\"另外\",{\"1\":{\"127\":1}}],[\"代码如下\",{\"1\":{\"194\":1,\"199\":1,\"204\":1}}],[\"代码中应中在\",{\"1\":{\"138\":1}}],[\"代码是否有足够的注释并且人们可以理解它的结构吗\",{\"1\":{\"16\":1}}],[\"名称\",{\"1\":{\"138\":1}}],[\"名称可以在\",{\"1\":{\"13\":1}}],[\"编号可以由digitalpintointerrupt函数获取\",{\"1\":{\"184\":1}}],[\"编号为pb6\",{\"1\":{\"181\":1}}],[\"编号用于定义\",{\"1\":{\"138\":1}}],[\"编译下载\",{\"0\":{\"156\":1,\"162\":1}}],[\"编译器\",{\"1\":{\"30\":1}}],[\"编译并上传代码\",{\"1\":{\"7\":1}}],[\"下一个字节\",{\"1\":{\"137\":1}}],[\"下载完成后的操作\",{\"1\":{\"230\":1}}],[\"下载完成以后直接解压即可\",{\"1\":{\"22\":1}}],[\"下载前的操作\",{\"1\":{\"229\":1}}],[\"下载前要执行的操作\",{\"1\":{\"9\":1,\"249\":1}}],[\"下载zip版本免安装包\",{\"1\":{\"22\":1}}],[\"下载exe版本安装包\",{\"1\":{\"21\":1}}],[\"下载地址为software\",{\"1\":{\"20\":1}}],[\"下载后要执行的操作\",{\"1\":{\"9\":1,\"249\":1}}],[\"波特率9600\",{\"1\":{\"172\":1}}],[\"波特率\",{\"1\":{\"131\":1}}],[\"具体可参考air001\",{\"1\":{\"188\":1}}],[\"具体可参考\",{\"1\":{\"181\":1}}],[\"具体可以参考\",{\"1\":{\"154\":1}}],[\"具体可以参考开发板的手册\",{\"1\":{\"97\":1}}],[\"具体的通用\",{\"1\":{\"130\":1}}],[\"异步\",{\"1\":{\"129\":1}}],[\"无需在外部跟踪它\",{\"1\":{\"127\":1}}],[\"无需配置引脚模式\",{\"1\":{\"127\":1}}],[\"出于性能原因\",{\"1\":{\"127\":1}}],[\"出于通用性目的\",{\"1\":{\"125\":1}}],[\"次数不限\",{\"1\":{\"127\":1}}],[\"允许检索配置\",{\"1\":{\"127\":1}}],[\"允许使用其他参数配置spi\",{\"1\":{\"117\":1}}],[\"计算显示的天数\",{\"1\":{\"214\":1}}],[\"计算公式\",{\"1\":{\"204\":1}}],[\"计算得到的数据将其转化为直观的温度和湿度\",{\"1\":{\"204\":1}}],[\"计时器将启动禁用中断\",{\"1\":{\"127\":1}}],[\"计时器启动\",{\"1\":{\"127\":1}}],[\"计时器可以暂停然后恢复\",{\"1\":{\"127\":1}}],[\"计数\",{\"1\":{\"127\":1}}],[\"用向灯板提供\",{\"1\":{\"223\":1}}],[\"用display方法\",{\"1\":{\"219\":1}}],[\"用set方法来调节数码管亮度\",{\"1\":{\"219\":1}}],[\"用point方法控制四位数码管中间的冒号显示\",{\"1\":{\"219\":1}}],[\"用蓝色填充屏幕\",{\"1\":{\"214\":1}}],[\"用来闪灯\",{\"1\":{\"184\":1}}],[\"用来判断时按下还是松开\",{\"1\":{\"184\":1}}],[\"用户回调无需显式清除\",{\"1\":{\"127\":1}}],[\"用于让芯片自动重启运行代码\",{\"1\":{\"230\":1}}],[\"用于让芯片自动进入\",{\"1\":{\"229\":1}}],[\"用于显示\",{\"1\":{\"214\":1}}],[\"用于打印数据\",{\"1\":{\"209\":1}}],[\"用于打印按键状态\",{\"1\":{\"182\":1,\"184\":1}}],[\"用于输出日志\",{\"1\":{\"194\":1,\"214\":1}}],[\"用于存储当前led灯的状态\",{\"1\":{\"224\":1}}],[\"用于存储上一次的按键状态\",{\"1\":{\"182\":1}}],[\"用于存放样式相关的文件\",{\"1\":{\"12\":1}}],[\"用于半双工的\",{\"1\":{\"140\":4}}],[\"用于初始化\",{\"1\":{\"115\":1}}],[\"用于短距离连接设备\",{\"1\":{\"73\":1}}],[\"用于将中断附加到定义的引脚\",{\"1\":{\"67\":1}}],[\"用于将电压等模拟信号转换为数字形式\",{\"1\":{\"33\":1}}],[\"翻转\",{\"1\":{\"127\":1}}],[\"范围\",{\"1\":{\"127\":1}}],[\"范围为\",{\"1\":{\"38\":1,\"106\":1}}],[\"寄存器的地址为0x3b\",{\"1\":{\"194\":1}}],[\"寄存器\",{\"1\":{\"127\":1}}],[\"key\",{\"1\":{\"182\":2,\"183\":8,\"184\":2}}],[\"kept\",{\"1\":{\"127\":1}}],[\"khz\",{\"1\":{\"127\":1}}],[\"溢出\",{\"1\":{\"127\":1}}],[\"溢出范围\",{\"1\":{\"127\":1}}],[\"溢出是所有通道共有的\",{\"1\":{\"127\":1}}],[\"建议添加\",{\"1\":{\"242\":1,\"248\":1}}],[\"建议使用最大值\",{\"1\":{\"127\":1}}],[\"建立完成之后\",{\"1\":{\"6\":1}}],[\"建立工程\",{\"0\":{\"6\":1}}],[\"硬件手册\",{\"1\":{\"181\":1}}],[\"硬件准备\",{\"0\":{\"166\":1,\"171\":1,\"176\":1,\"181\":1,\"188\":1,\"193\":1,\"198\":1,\"203\":1,\"208\":1,\"213\":1,\"218\":1,\"223\":1}}],[\"硬件寄存器的范围为\",{\"1\":{\"127\":1}}],[\"硬件寄存器范围为\",{\"1\":{\"127\":1}}],[\"硬件定时器架构有一些基本了解\",{\"1\":{\"125\":1}}],[\"硬件定时器\",{\"0\":{\"125\":1}}],[\"预分频器因子范围\",{\"1\":{\"127\":1}}],[\"预分频器因子为\",{\"1\":{\"127\":1}}],[\"预分频器用于定时器计数器\",{\"1\":{\"127\":1}}],[\"预分频器的配置是自动的\",{\"1\":{\"127\":2}}],[\"与\",{\"1\":{\"127\":2}}],[\"只要将颜色数据一个个发送出去就可以了\",{\"1\":{\"224\":1}}],[\"只要确保与您自己的使用没有冲突即可\",{\"1\":{\"127\":1}}],[\"只是叫做异常\",{\"1\":{\"184\":1}}],[\"只需要一条数据线\",{\"1\":{\"175\":1}}],[\"只用使用这种解决方案才能在代码中使用\",{\"1\":{\"138\":1}}],[\"只有一个\",{\"1\":{\"97\":1,\"138\":1}}],[\"频率在\",{\"1\":{\"224\":2}}],[\"频率以赫兹为单位\",{\"1\":{\"127\":1}}],[\"频率\",{\"1\":{\"125\":1}}],[\"频率对于指定定时器的所有通道是通用的\",{\"1\":{\"105\":1}}],[\"还可以使用下列\",{\"1\":{\"124\":1,\"139\":1}}],[\"还是已经根据\",{\"1\":{\"16\":1}}],[\"更进一步\",{\"0\":{\"190\":1}}],[\"更新中断标志\",{\"1\":{\"127\":1}}],[\"更改配置文件中的包文件路径\",{\"0\":{\"148\":1}}],[\"更改\",{\"1\":{\"124\":1,\"139\":1}}],[\"更改默认\",{\"0\":{\"124\":1,\"139\":1}}],[\"更多信息请见其他章节内容\",{\"1\":{\"9\":1}}],[\"指向要读取的数据的指针\",{\"1\":{\"122\":1}}],[\"指向要写入的数据的指针\",{\"1\":{\"121\":1,\"122\":1}}],[\"读写保护\",{\"0\":{\"250\":1}}],[\"读半字\",{\"1\":{\"120\":1}}],[\"读取固件存入对应文件\",{\"1\":{\"245\":1}}],[\"读取失败则打印\",{\"1\":{\"204\":1}}],[\"读取到的字节\",{\"1\":{\"134\":1}}],[\"读取几个字节\",{\"1\":{\"121\":1,\"122\":1}}],[\"读取一个值\",{\"1\":{\"51\":1}}],[\"读取一个字节\",{\"1\":{\"45\":1,\"119\":1}}],[\"读取的数据数量\",{\"1\":{\"121\":1,\"122\":1}}],[\"读取的字节\",{\"1\":{\"45\":1}}],[\"读取的分辨率\",{\"1\":{\"38\":1}}],[\"读取内部通道时需要最小\",{\"1\":{\"35\":1}}],[\"写\",{\"1\":{\"120\":1}}],[\"写入\",{\"1\":{\"119\":1,\"121\":1,\"122\":1}}],[\"返回接收到的数据\",{\"1\":{\"119\":1,\"120\":1}}],[\"返回值\",{\"1\":{\"45\":1,\"51\":1,\"53\":1,\"55\":1,\"57\":1,\"65\":1,\"133\":1,\"134\":1,\"135\":2,\"137\":1}}],[\"直到调用\",{\"1\":{\"118\":1}}],[\"直接控制设备重启\",{\"1\":{\"230\":1}}],[\"直接控制设备进入\",{\"1\":{\"229\":1}}],[\"直接点击安装\",{\"1\":{\"21\":1}}],[\"直接输入\",{\"1\":{\"5\":1}}],[\"必须在\",{\"1\":{\"140\":1}}],[\"必须在调用\",{\"1\":{\"124\":1}}],[\"必须调用以下函数\",{\"1\":{\"118\":1}}],[\"必须通过传递从机地址来使用\",{\"1\":{\"93\":1}}],[\"删除\",{\"1\":{\"118\":1}}],[\"片选将由\",{\"1\":{\"115\":1}}],[\"片选线路可以从多个从机选择一个来响应主机的请求\",{\"1\":{\"112\":1}}],[\"构造函数接受可选的\",{\"1\":{\"141\":1}}],[\"构造函数\",{\"1\":{\"115\":1,\"140\":1}}],[\"构建输出目录\",{\"1\":{\"12\":1}}],[\"号提供给库\",{\"1\":{\"114\":1}}],[\"种关于\",{\"1\":{\"114\":1}}],[\"于此相对地\",{\"1\":{\"112\":1}}],[\"虽然ssi也是一个四线式同步通信协议\",{\"1\":{\"112\":1}}],[\"类\",{\"1\":{\"127\":1}}],[\"类似i²c\",{\"1\":{\"112\":1}}],[\"类型为unsigned\",{\"1\":{\"57\":1}}],[\"不然刺眼\",{\"1\":{\"224\":1}}],[\"不然会像这块屏幕一样有彩边\",{\"1\":{\"215\":1}}],[\"不亮\",{\"1\":{\"224\":1}}],[\"不一定真的运行异常\",{\"1\":{\"184\":1}}],[\"不一定有互操作性\",{\"1\":{\"112\":1}}],[\"不要松开\",{\"1\":{\"183\":1}}],[\"不包含空格\",{\"1\":{\"146\":1,\"149\":1}}],[\"不支持\",{\"1\":{\"108\":1}}],[\"不管是新建一个工程还是用之前老的工程都行\",{\"1\":{\"6\":1}}],[\"❌\",{\"1\":{\"108\":4}}],[\"🔨\",{\"1\":{\"108\":15,\"234\":1}}],[\"备注\",{\"1\":{\"108\":1}}],[\"参数为\",{\"1\":{\"115\":1}}],[\"参数的分辨率\",{\"1\":{\"106\":1}}],[\"参见下面的示例\",{\"1\":{\"114\":1}}],[\"参考\",{\"0\":{\"113\":1},\"1\":{\"29\":1}}],[\"参考https\",{\"1\":{\"13\":1}}],[\"工具进行烧录操作\",{\"1\":{\"252\":1}}],[\"工具命令\",{\"0\":{\"237\":1}}],[\"工控等方面\",{\"1\":{\"101\":1}}],[\"工作流配置\",{\"1\":{\"12\":1}}],[\"广泛应用在测量\",{\"1\":{\"101\":1}}],[\"脉宽调制\",{\"1\":{\"101\":1}}],[\"静态重新定义\",{\"1\":{\"100\":1}}],[\"静态资源目录\",{\"1\":{\"12\":1}}],[\"借助开关\",{\"1\":{\"100\":1}}],[\"彼此独立\",{\"1\":{\"100\":1}}],[\"个计数器\",{\"1\":{\"127\":1}}],[\"个通道\",{\"1\":{\"125\":1}}],[\"个互补通道\",{\"1\":{\"125\":1}}],[\"个输出通道\",{\"1\":{\"125\":1}}],[\"个字节\",{\"1\":{\"100\":1}}],[\"个设备\",{\"1\":{\"73\":1}}],[\"字节\",{\"1\":{\"100\":1}}],[\"缓冲区大小\",{\"1\":{\"100\":1}}],[\"缓冲区将在需要时自动增长\",{\"1\":{\"100\":1}}],[\"缓冲区都在\",{\"1\":{\"100\":1}}],[\"缓冲区管理\",{\"0\":{\"100\":1}}],[\"禁用内部上拉电阻\",{\"1\":{\"99\":1}}],[\"所以无需手动安装额外的依赖\",{\"1\":{\"249\":1}}],[\"所以使用了特殊的\",{\"1\":{\"229\":1}}],[\"所以ws2812\",{\"1\":{\"224\":1}}],[\"所以芯片要设置16m\",{\"1\":{\"224\":1}}],[\"所以这里我们用空函数实现\",{\"1\":{\"209\":1}}],[\"所以您可以在代码文件中重新定义它们\",{\"1\":{\"99\":1}}],[\"所有定时器并不等同\",{\"1\":{\"125\":1}}],[\"所有\",{\"1\":{\"100\":1}}],[\"所有设置都将使用默认值完成\",{\"1\":{\"83\":1,\"91\":1}}],[\"所有图片添加前都要经过此网站的压缩\",{\"1\":{\"13\":1}}],[\"8mhz\",{\"1\":{\"224\":3}}],[\"86400\",{\"1\":{\"214\":2}}],[\"8lsb\",{\"1\":{\"194\":1}}],[\"8g\",{\"1\":{\"194\":1}}],[\"8o2\",{\"1\":{\"131\":1}}],[\"8o1serial\",{\"1\":{\"131\":1}}],[\"8e2serial\",{\"1\":{\"131\":1}}],[\"8e1serial\",{\"1\":{\"131\":1}}],[\"8n1\",{\"1\":{\"131\":1}}],[\"8n1serial\",{\"1\":{\"131\":1}}],[\"8n2serial\",{\"1\":{\"131\":1}}],[\"8b\",{\"1\":{\"127\":1}}],[\"8\",{\"1\":{\"98\":3,\"106\":1,\"127\":2,\"194\":1,\"224\":1}}],[\"90\",{\"1\":{\"199\":2}}],[\"9999\",{\"1\":{\"127\":1}}],[\"9\",{\"1\":{\"98\":2}}],[\"9600\",{\"1\":{\"46\":1,\"52\":1,\"54\":1,\"96\":1,\"172\":1,\"177\":1,\"182\":1,\"184\":1,\"194\":1,\"204\":1,\"209\":1}}],[\"应在代码中在\",{\"1\":{\"97\":1}}],[\"应用示例\",{\"1\":{\"12\":1}}],[\"端口选择连接的串口\",{\"1\":{\"154\":1}}],[\"端口\",{\"1\":{\"97\":1}}],[\"60\",{\"1\":{\"214\":2,\"224\":1}}],[\"6位\",{\"1\":{\"214\":1}}],[\"6定义为屏幕响应按键\",{\"1\":{\"214\":1}}],[\"64\",{\"1\":{\"209\":1,\"224\":1}}],[\"6轴传感器\",{\"0\":{\"191\":1}}],[\"6\",{\"1\":{\"96\":1,\"98\":1,\"182\":2,\"184\":2,\"194\":1,\"204\":3,\"213\":1,\"214\":2}}],[\"65535\",{\"1\":{\"204\":2}}],[\"65\",{\"1\":{\"54\":1,\"194\":1}}],[\"之前完成\",{\"1\":{\"127\":1}}],[\"之前调用\",{\"1\":{\"124\":1,\"139\":1,\"140\":1}}],[\"之前\",{\"1\":{\"91\":1}}],[\"则覆盖文件\",{\"1\":{\"246\":1}}],[\"则将数据存入data数组\",{\"1\":{\"204\":1}}],[\"则可能依旧报错\",{\"1\":{\"149\":1}}],[\"则采用半双工模式\",{\"1\":{\"140\":1}}],[\"则返回\",{\"1\":{\"134\":1,\"137\":1}}],[\"则\",{\"1\":{\"127\":1}}],[\"则用户回调将附加到更新事件\",{\"1\":{\"127\":1}}],[\"则定时器将以\",{\"1\":{\"127\":1}}],[\"则禁用时钟拉伸\",{\"1\":{\"93\":1}}],[\"则启用广播地址\",{\"1\":{\"93\":1}}],[\"则发送停止位\",{\"1\":{\"87\":1,\"88\":1}}],[\"则不会重写该值\",{\"1\":{\"53\":1}}],[\"来个浅蓝色吧\",{\"1\":{\"224\":1}}],[\"来更改某一位显示的值\",{\"1\":{\"219\":1}}],[\"来发送多个字节\",{\"1\":{\"135\":1}}],[\"来进行初始化\",{\"1\":{\"131\":1}}],[\"来调用此函数\",{\"1\":{\"86\":1}}],[\"来模拟\",{\"1\":{\"43\":1}}],[\"主要应用于单片机系统中\",{\"1\":{\"112\":1}}],[\"主机负责初始化帧\",{\"1\":{\"112\":1}}],[\"主机\",{\"0\":{\"84\":1},\"1\":{\"84\":1}}],[\"主模式\",{\"0\":{\"82\":1},\"1\":{\"74\":1,\"83\":1}}],[\"为air001开发板上的对应pin脚pa\",{\"1\":{\"219\":1}}],[\"为什么烧录提示无法进入boot模式\",{\"0\":{\"152\":1}}],[\"为什么烧录到一半就显示失败\",{\"0\":{\"151\":1}}],[\"为\",{\"1\":{\"138\":5}}],[\"为方便起见\",{\"1\":{\"138\":1}}],[\"为一个通道设置频率将影响同一定时器的所有其他通道\",{\"1\":{\"105\":1}}],[\"为此\",{\"1\":{\"83\":1}}],[\"为了保证\",{\"1\":{\"224\":1}}],[\"为了保证单总线的时序保持正常\",{\"1\":{\"177\":1}}],[\"为了保持静止\",{\"1\":{\"193\":1}}],[\"为了演示不影响按键响应\",{\"1\":{\"184\":1}}],[\"为了简化基本\",{\"1\":{\"127\":1}}],[\"为了方便日后使用\",{\"1\":{\"22\":1}}],[\"为了观察方便\",{\"1\":{\"13\":1}}],[\"而对应的精度分别是131lsb\",{\"1\":{\"194\":1}}],[\"而其他定时器则没有互补通道\",{\"1\":{\"125\":1}}],[\"而其余的\",{\"1\":{\"12\":1}}],[\"而无需再次调用\",{\"1\":{\"118\":1}}],[\"而且仅提供一个单工通信信道\",{\"1\":{\"112\":1}}],[\"而不是更改\",{\"1\":{\"99\":1}}],[\"而是添加到i2c缓冲区\",{\"1\":{\"83\":1}}],[\"现在可以启动定时器了\",{\"1\":{\"127\":1}}],[\"现在您可以请求从从设备读取数据\",{\"1\":{\"83\":1}}],[\"现在\",{\"1\":{\"83\":1,\"91\":1}}],[\"现在大部分电脑都是64位因此可以直接下载最新版本\",{\"1\":{\"21\":1,\"22\":1}}],[\"头文件引入到你的代码中\",{\"1\":{\"83\":1,\"91\":1}}],[\"您也可以使用\",{\"1\":{\"131\":1,\"135\":1}}],[\"您还可以在\",{\"1\":{\"141\":1}}],[\"您还可以通过该方法知道是否已经附加了回调\",{\"1\":{\"127\":1}}],[\"您还可以使用\",{\"1\":{\"99\":1}}],[\"您需要使用\",{\"1\":{\"83\":1}}],[\"您需要再次使用\",{\"1\":{\"81\":1}}],[\"您可以指定\",{\"1\":{\"138\":1}}],[\"您可以指定您使用的\",{\"1\":{\"85\":1}}],[\"您可以通过\",{\"1\":{\"127\":1}}],[\"您可以在以下网站找到\",{\"1\":{\"110\":1}}],[\"您可以使用不同的\",{\"1\":{\"118\":1}}],[\"您可以使用不带任何参数的\",{\"1\":{\"85\":1}}],[\"您可以使用\",{\"1\":{\"83\":1,\"88\":2}}],[\"您可以驱动\",{\"1\":{\"60\":1}}],[\"调试器使用排针排母连接\",{\"1\":{\"166\":1}}],[\"调试配置\",{\"0\":{\"7\":1}}],[\"调用函数displayuptime输出显示当前时间\",{\"1\":{\"214\":1}}],[\"调用showtext函数\",{\"1\":{\"209\":1}}],[\"调用\",{\"1\":{\"81\":1,\"83\":2}}],[\"时需要使用特殊的时序控制方法\",{\"1\":{\"229\":1}}],[\"时钟频率\",{\"1\":{\"79\":2}}],[\"时钟由主设备产生\",{\"1\":{\"74\":1}}],[\"时才使用此函数\",{\"1\":{\"64\":1}}],[\"生成时钟信号并发起与从设备的通信\",{\"1\":{\"74\":1}}],[\"库自动完成\",{\"1\":{\"127\":1}}],[\"库自行管理\",{\"1\":{\"114\":1}}],[\"库使用所有定时器\",{\"1\":{\"125\":1}}],[\"库管理器中的\",{\"1\":{\"172\":1,\"177\":1,\"209\":1}}],[\"库管理\",{\"1\":{\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1}}],[\"库已经过修改\",{\"1\":{\"114\":1}}],[\"库\",{\"1\":{\"73\":1,\"114\":1}}],[\"库基于\",{\"1\":{\"73\":1}}],[\"串联传递信号\",{\"1\":{\"222\":1}}],[\"串行外设接口\",{\"1\":{\"112\":1}}],[\"串行时钟线\",{\"1\":{\"73\":1}}],[\"串行数据线\",{\"1\":{\"73\":1}}],[\"串口的\",{\"1\":{\"229\":1,\"230\":1}}],[\"串口打印\",{\"1\":{\"195\":1,\"205\":1}}],[\"串口接收缓冲区中的字节数\",{\"1\":{\"133\":1}}],[\"串口\",{\"1\":{\"9\":1,\"247\":1,\"251\":1,\"252\":1}}],[\"串口波特率\",{\"1\":{\"9\":1,\"249\":1}}],[\"串口名称\",{\"1\":{\"9\":1,\"249\":1}}],[\"7k电阻\",{\"1\":{\"176\":1}}],[\"7o2serial\",{\"1\":{\"131\":1}}],[\"7o1serial\",{\"1\":{\"131\":1}}],[\"7e2serial\",{\"1\":{\"131\":1}}],[\"7n1serial\",{\"1\":{\"131\":1}}],[\"7\",{\"1\":{\"73\":1,\"98\":2,\"194\":1,\"213\":1,\"214\":1,\"223\":2}}],[\"多个设备可以连接在同一条两线总线上\",{\"1\":{\"73\":1}}],[\"rgb\",{\"1\":{\"224\":1}}],[\"rgb分量分别使用5位\",{\"1\":{\"214\":1}}],[\"rst\",{\"1\":{\"214\":2,\"229\":1,\"230\":1}}],[\"rh\",{\"1\":{\"204\":1}}],[\"r\",{\"1\":{\"194\":1,\"224\":3}}],[\"rp2的u盘设备\",{\"1\":{\"162\":1}}],[\"rp2040\",{\"0\":{\"158\":1},\"1\":{\"159\":1}}],[\"runs\",{\"1\":{\"161\":2}}],[\"run\",{\"1\":{\"155\":2}}],[\"running\",{\"1\":{\"126\":2}}],[\"rts\",{\"1\":{\"141\":8,\"229\":1,\"230\":1}}],[\"rtc\",{\"1\":{\"73\":1}}],[\"rollover\",{\"1\":{\"126\":3,\"127\":1}}],[\"right\",{\"1\":{\"123\":1}}],[\"rising\",{\"1\":{\"67\":1,\"127\":3,\"184\":1}}],[\"rxtx\",{\"1\":{\"140\":2}}],[\"rxpin\",{\"1\":{\"139\":2}}],[\"rx=pa1\",{\"1\":{\"138\":1}}],[\"rx\",{\"1\":{\"100\":2,\"138\":6,\"140\":5,\"141\":2}}],[\"red\",{\"1\":{\"214\":1}}],[\"repeatedly\",{\"1\":{\"155\":1}}],[\"required\",{\"1\":{\"127\":1}}],[\"requesttemperatures方法\",{\"1\":{\"177\":1}}],[\"requesttemperatures\",{\"1\":{\"177\":1}}],[\"requested\",{\"1\":{\"96\":1}}],[\"requestevent\",{\"1\":{\"96\":2}}],[\"request\",{\"1\":{\"95\":1}}],[\"requestfrom\",{\"0\":{\"88\":1},\"1\":{\"83\":2,\"88\":6,\"89\":2,\"194\":1,\"204\":1}}],[\"requests\",{\"1\":{\"15\":1}}],[\"reach\",{\"1\":{\"127\":1}}],[\"reason\",{\"1\":{\"127\":1}}],[\"readaltitude\",{\"1\":{\"172\":2}}],[\"readpressure方法\",{\"1\":{\"172\":1}}],[\"readpressure\",{\"1\":{\"172\":1}}],[\"readtemperature方法\",{\"1\":{\"172\":1}}],[\"readtemperature\",{\"1\":{\"172\":1}}],[\"readbytes\",{\"1\":{\"83\":2,\"89\":1}}],[\"reading\",{\"1\":{\"52\":1}}],[\"readme\",{\"1\":{\"12\":1}}],[\"read\",{\"0\":{\"45\":1,\"134\":1,\"243\":1,\"244\":1,\"245\":1,\"246\":1},\"1\":{\"9\":2,\"45\":1,\"46\":1,\"52\":4,\"56\":1,\"89\":1,\"96\":2,\"134\":1,\"140\":1,\"194\":2,\"204\":1,\"246\":1,\"249\":2,\"251\":1,\"252\":1}}],[\"related\",{\"1\":{\"126\":1}}],[\"releases\",{\"1\":{\"25\":1}}],[\"release页面下载最新版本的airisp工具\",{\"1\":{\"9\":1,\"249\":1}}],[\"refresh刷新函数就像下面这样\",{\"1\":{\"224\":1}}],[\"refresh\",{\"1\":{\"126\":2,\"224\":3}}],[\"reference\",{\"1\":{\"113\":1}}],[\"remove\",{\"1\":{\"126\":2}}],[\"remaining\",{\"1\":{\"50\":1}}],[\"returns\",{\"1\":{\"126\":2}}],[\"return\",{\"1\":{\"126\":5,\"182\":1,\"204\":1}}],[\"retrieve\",{\"1\":{\"54\":1,\"126\":1,\"127\":2}}],[\"res\",{\"1\":{\"208\":1,\"213\":1}}],[\"resolution\",{\"1\":{\"127\":2}}],[\"resumechannel\",{\"1\":{\"126\":1}}],[\"resume\",{\"1\":{\"126\":3,\"127\":1}}],[\"respond\",{\"1\":{\"96\":1}}],[\"reset|direct\",{\"0\":{\"229\":1,\"230\":1}}],[\"resetand\",{\"1\":{\"127\":1}}],[\"reset\",{\"1\":{\"9\":2,\"161\":1,\"209\":2,\"229\":1,\"230\":1,\"249\":2}}],[\"registers\",{\"1\":{\"126\":2}}],[\"registered\",{\"1\":{\"96\":2}}],[\"register\",{\"1\":{\"96\":2,\"126\":4}}],[\"receiver\",{\"1\":{\"129\":1}}],[\"receiveevent\",{\"1\":{\"96\":2}}],[\"receive\",{\"1\":{\"94\":1,\"96\":2}}],[\"received\",{\"1\":{\"89\":1,\"96\":1}}],[\"外设管理\",{\"1\":{\"115\":1}}],[\"外设的引脚号\",{\"1\":{\"115\":1}}],[\"外设的硬件\",{\"1\":{\"114\":1}}],[\"外设的常用函数\",{\"1\":{\"61\":1}}],[\"外设\",{\"1\":{\"108\":1,\"115\":1,\"116\":1,\"138\":1}}],[\"外设支持中断\",{\"1\":{\"66\":1}}],[\"上对齐\",{\"1\":{\"100\":1}}],[\"上使用\",{\"1\":{\"83\":1,\"91\":1}}],[\"上的所有内容\",{\"1\":{\"243\":1}}],[\"上的\",{\"1\":{\"66\":1}}],[\"上报新的问题或框架中的错误\",{\"1\":{\"32\":1}}],[\"仅\",{\"1\":{\"140\":1}}],[\"仅适用于一个通道\",{\"1\":{\"127\":1}}],[\"仅使用一个缓冲区来写入和读取数据\",{\"1\":{\"121\":1}}],[\"仅当\",{\"1\":{\"64\":1}}],[\"仅为自己安装即可\",{\"1\":{\"21\":1}}],[\"函数见文档接下来的内容\",{\"1\":{\"224\":1}}],[\"函数见下方\",{\"1\":{\"209\":1}}],[\"函数更改为下面这样\",{\"1\":{\"190\":1}}],[\"函数中设置my\",{\"1\":{\"199\":1}}],[\"函数中的延时将不会对按键状态变化时的相应造成影响\",{\"1\":{\"184\":1}}],[\"函数中只进行了轮询按键的判断\",{\"1\":{\"184\":1}}],[\"函数中添加代码\",{\"1\":{\"214\":1,\"219\":1}}],[\"函数中添加剩下的代码\",{\"1\":{\"182\":1,\"184\":1,\"189\":1}}],[\"函数中添加如下代码进行初始化操作\",{\"1\":{\"214\":1,\"219\":1}}],[\"函数中添加如下代码\",{\"1\":{\"172\":1,\"177\":1,\"199\":1}}],[\"函数中\",{\"1\":{\"182\":1,\"184\":1,\"189\":1,\"209\":1}}],[\"函数中初始化串口与sensors对象\",{\"1\":{\"177\":1}}],[\"函数中初始化串口与bmp180\",{\"1\":{\"172\":1}}],[\"函数之前声明\",{\"1\":{\"97\":1,\"138\":1}}],[\"函数之前调用\",{\"1\":{\"78\":1}}],[\"函数用于定义要发送到主机的数据的回调\",{\"1\":{\"95\":1}}],[\"函数用于定义从主机接收到的数据的回调\",{\"1\":{\"94\":1}}],[\"函数用于定义特定引脚的gpio操作模式\",{\"1\":{\"62\":1}}],[\"函数上定义的从设备地址\",{\"1\":{\"87\":1}}],[\"函数将缓冲的字节发送到从设备\",{\"1\":{\"83\":1}}],[\"函数不会直接写入从设备\",{\"1\":{\"83\":1}}],[\"函数传递不同的数据类型\",{\"1\":{\"83\":1}}],[\"函数来使用所有默认值\",{\"1\":{\"85\":1}}],[\"函数来开始外设配置\",{\"1\":{\"83\":1,\"91\":1}}],[\"函数来分离\",{\"1\":{\"68\":1}}],[\"函数必须在\",{\"1\":{\"78\":1}}],[\"函数\",{\"1\":{\"64\":1,\"67\":1,\"83\":2,\"88\":1,\"93\":1,\"115\":1}}],[\"输出温度\",{\"1\":{\"194\":1}}],[\"输出三轴角度\",{\"1\":{\"194\":1}}],[\"输出三轴加速度\",{\"1\":{\"194\":1}}],[\"输出结果\",{\"0\":{\"168\":1,\"173\":1,\"178\":1,\"183\":1,\"195\":1,\"200\":1,\"205\":1,\"210\":1,\"215\":1,\"220\":1,\"225\":1}}],[\"输出\",{\"1\":{\"127\":1}}],[\"输出引脚\",{\"1\":{\"103\":1}}],[\"输出的占空比\",{\"1\":{\"103\":1}}],[\"输出模式\",{\"1\":{\"60\":1,\"62\":2}}],[\"输入\",{\"1\":{\"127\":1}}],[\"输入和输出模式\",{\"0\":{\"70\":1}}],[\"输入模式\",{\"1\":{\"60\":1,\"62\":3}}],[\"输入debug\",{\"1\":{\"7\":1}}],[\"输入arduino\",{\"1\":{\"6\":1}}],[\"将强制将输出打印的信息更改为英文\",{\"1\":{\"232\":1}}],[\"将ws2812led\",{\"1\":{\"223\":1}}],[\"将库添加到arduino\",{\"1\":{\"219\":1}}],[\"将tm1637led数码管驱动模块与air001开发板\",{\"1\":{\"218\":1}}],[\"将其显示并刷新\",{\"1\":{\"214\":1}}],[\"将其表面文字转至正向自己\",{\"1\":{\"193\":1}}],[\"将air001开发板的\",{\"1\":{\"223\":1}}],[\"将air001开发板上的boot按钮对应的引脚pb\",{\"1\":{\"214\":1}}],[\"将air001和daplink调试器使用排针排母连接\",{\"1\":{\"171\":1,\"176\":1,\"188\":1,\"193\":1,\"198\":1,\"203\":1,\"208\":1,\"213\":1,\"218\":1,\"223\":1}}],[\"将st7735模块与air001开发板\",{\"1\":{\"213\":1}}],[\"将sht30模块与air001开发板\",{\"1\":{\"203\":1}}],[\"将屏幕缓冲区数据刷到屏幕上\",{\"1\":{\"209\":1}}],[\"将oled屏幕模块与air001开发板\",{\"1\":{\"208\":1}}],[\"将mpu6050模块与air001开发板\",{\"1\":{\"193\":1}}],[\"将button的值定义为pb\",{\"1\":{\"182\":1,\"184\":1}}],[\"将bmp180模块与air001开发板\",{\"1\":{\"171\":1}}],[\"将温度值打印出来\",{\"1\":{\"177\":1}}],[\"将ds18b20模块与air001开发板\",{\"1\":{\"176\":1}}],[\"将波特率调为\",{\"1\":{\"168\":1}}],[\"将\",{\"1\":{\"166\":1}}],[\"将开发板的\",{\"1\":{\"162\":1}}],[\"将你的环境变量的temp与tmp值改为你新建的文件夹路径即可\",{\"1\":{\"149\":1}}],[\"将他们全部移动到你最开始新建的文件夹\",{\"1\":{\"147\":1}}],[\"将被启用\",{\"1\":{\"138\":1}}],[\"将无法稍后附加中断\",{\"1\":{\"127\":1}}],[\"将方法\",{\"1\":{\"127\":2}}],[\"将处理对主设备的应答\",{\"1\":{\"91\":1}}],[\"将根据从属设备读取请求处理来自主设备的请求\",{\"1\":{\"91\":1}}],[\"将消息发送到\",{\"1\":{\"87\":1}}],[\"将读取它\",{\"1\":{\"83\":1}}],[\"将要求通过提供地址和大小来读取所选设备的数据\",{\"1\":{\"83\":1}}],[\"将引脚状态设置为低电平\",{\"1\":{\"64\":1}}],[\"将引脚状态设置为高电平\",{\"1\":{\"64\":1}}],[\"将所选\",{\"1\":{\"64\":1}}],[\"将从特定设备接收数字状态\",{\"1\":{\"60\":1}}],[\"将一个值写入\",{\"1\":{\"53\":1}}],[\"将一个字节写入\",{\"1\":{\"47\":1,\"49\":1}}],[\"欲了解更多信息\",{\"1\":{\"59\":1}}],[\"并设置为1为打开\",{\"1\":{\"219\":1}}],[\"并阻塞代码\",{\"1\":{\"209\":1}}],[\"并定义需要用的参数\",{\"1\":{\"214\":1}}],[\"并定义\",{\"1\":{\"209\":1}}],[\"并实例化对象my\",{\"1\":{\"199\":1}}],[\"并实例化对象sensors\",{\"1\":{\"177\":1}}],[\"并实例化对象bmp\",{\"1\":{\"172\":1}}],[\"并实现了更多\",{\"1\":{\"73\":1}}],[\"并选择全部安装以安装所需依赖\",{\"1\":{\"172\":1,\"177\":2,\"214\":1}}],[\"并选择接口和air001\",{\"1\":{\"189\":1}}],[\"并选择接口和\",{\"1\":{\"167\":1}}],[\"并可观察到led以1秒的间隔闪烁\",{\"1\":{\"157\":1}}],[\"并且串口监视器中的按键事件打印也很及时\",{\"1\":{\"185\":1}}],[\"并且设置为output输出模式\",{\"1\":{\"184\":1,\"189\":1}}],[\"并且设置为input\",{\"1\":{\"182\":1}}],[\"并且保证路径纯英文\",{\"1\":{\"146\":1,\"149\":1}}],[\"并且报错信息的路径包含乱码\",{\"1\":{\"143\":1}}],[\"并且独立于其他\",{\"1\":{\"100\":1}}],[\"并在执行用户回调之前由\",{\"1\":{\"127\":1}}],[\"并在参数中包含不同的\",{\"1\":{\"118\":1}}],[\"并将灯的状态初始化\",{\"1\":{\"224\":1}}],[\"并将\",{\"1\":{\"88\":3}}],[\"并传递\",{\"1\":{\"83\":1}}],[\"并非所有\",{\"1\":{\"59\":1}}],[\"并使用了vuepress\",{\"1\":{\"11\":1}}],[\"闪烁或读取简单的按钮\",{\"1\":{\"59\":1}}],[\"单总线\",{\"1\":{\"175\":1}}],[\"单元\",{\"1\":{\"55\":1}}],[\"单位为\",{\"1\":{\"131\":1}}],[\"单位为赫兹\",{\"1\":{\"105\":1}}],[\"单位为摄氏度\",{\"1\":{\"40\":1}}],[\"单位为毫伏\",{\"1\":{\"39\":1,\"41\":1}}],[\"运算符\",{\"1\":{\"55\":1}}],[\"执行写入\",{\"1\":{\"53\":1}}],[\"对其进行驱动\",{\"1\":{\"223\":1}}],[\"对象\",{\"1\":{\"97\":1,\"138\":1}}],[\"对传入数据的引用\",{\"1\":{\"51\":1,\"53\":1}}],[\"对于加速度计\",{\"1\":{\"193\":1}}],[\"对于陀螺仪\",{\"1\":{\"193\":1}}],[\"对于输入捕获\",{\"1\":{\"127\":1}}],[\"对于输出\",{\"1\":{\"127\":1}}],[\"对于输出模式\",{\"1\":{\"60\":1}}],[\"对于文件\",{\"1\":{\"98\":1}}],[\"对于32位的电脑可以在页面下翻\",{\"1\":{\"21\":1,\"22\":1}}],[\"对于\",{\"1\":{\"6\":1,\"138\":1}}],[\"5v\",{\"1\":{\"218\":1,\"223\":2}}],[\"5s\",{\"1\":{\"214\":1}}],[\"5位\",{\"1\":{\"214\":1}}],[\"53\",{\"1\":{\"194\":1}}],[\"5lsb\",{\"1\":{\"194\":1}}],[\"5引脚进行通信\",{\"1\":{\"177\":1}}],[\"5°c\",{\"1\":{\"175\":1}}],[\"55°c至+125°c范围\",{\"1\":{\"175\":1}}],[\"5\",{\"1\":{\"127\":3,\"154\":1,\"176\":1,\"177\":1,\"194\":1,\"204\":1,\"213\":1,\"214\":1,\"224\":2}}],[\"50\",{\"1\":{\"127\":12,\"194\":1}}],[\"500m\",{\"1\":{\"170\":1}}],[\"5000\",{\"1\":{\"89\":1}}],[\"500\",{\"1\":{\"46\":1,\"167\":1,\"172\":1,\"177\":1,\"184\":2,\"204\":2}}],[\"5khz\",{\"1\":{\"127\":1}}],[\"512\",{\"1\":{\"46\":1}}],[\"5811\",{\"1\":{\"9\":1,\"247\":1}}],[\"+=\",{\"1\":{\"54\":1}}],[\"+\",{\"1\":{\"46\":1,\"204\":2}}],[\"=0x68\",{\"1\":{\"194\":1}}],[\"==\",{\"1\":{\"46\":1,\"56\":1,\"127\":19,\"140\":1,\"155\":1,\"182\":1,\"184\":1,\"204\":1}}],[\"=\",{\"0\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1},\"1\":{\"46\":4,\"48\":1,\"50\":2,\"52\":3,\"54\":3,\"56\":2,\"70\":4,\"71\":4,\"87\":2,\"89\":3,\"96\":2,\"98\":2,\"126\":11,\"127\":4,\"140\":1,\"141\":4,\"155\":1,\"177\":2,\"182\":3,\"194\":10,\"204\":4,\"214\":23,\"224\":14}}],[\"示例应用程序\",{\"0\":{\"89\":1,\"96\":1}}],[\"示例代码\",{\"0\":{\"69\":1}}],[\"示例\",{\"0\":{\"46\":1,\"48\":1,\"50\":1,\"52\":1,\"54\":1,\"56\":1},\"1\":{\"98\":1}}],[\"开头添加如下代码\",{\"1\":{\"219\":1}}],[\"开头我们用调用下载的adafruit\",{\"1\":{\"214\":1}}],[\"开头通过\",{\"1\":{\"199\":1}}],[\"开头引用onewire包与dallastemperature包\",{\"1\":{\"177\":1}}],[\"开头引用adafruit\",{\"1\":{\"172\":1}}],[\"开启\",{\"1\":{\"244\":1}}],[\"开启mpu6050的传输\",{\"1\":{\"194\":1}}],[\"开启读保护后\",{\"1\":{\"252\":1}}],[\"开启读保护\",{\"1\":{\"9\":1,\"249\":1}}],[\"开发板的默认控制方式\",{\"1\":{\"229\":1,\"230\":1}}],[\"开发板驱动tm1637四位数码管模块\",{\"1\":{\"217\":1}}],[\"开发板在\",{\"1\":{\"197\":1,\"207\":1}}],[\"开发板pinout\",{\"1\":{\"188\":1}}],[\"开发板上\",{\"1\":{\"181\":1}}],[\"开发板按键打印按键状态\",{\"1\":{\"180\":1}}],[\"开发板入门\",{\"1\":{\"166\":1}}],[\"开发板测量\",{\"1\":{\"165\":1}}],[\"开发板选择选择其他开发板和端口\",{\"1\":{\"160\":1}}],[\"开发板选择airmcu\",{\"1\":{\"154\":1}}],[\"开发板列表\",{\"1\":{\"159\":1}}],[\"开发中\",{\"1\":{\"108\":1}}],[\"开始传输\",{\"1\":{\"204\":1}}],[\"开始烧录\",{\"1\":{\"183\":1}}],[\"开始获取温度信息\",{\"1\":{\"177\":1,\"178\":6}}],[\"开始之前\",{\"1\":{\"145\":1}}],[\"开始\",{\"1\":{\"45\":1,\"47\":1,\"49\":1,\"51\":1,\"53\":1,\"55\":1}}],[\"要指定应使用哪个\",{\"1\":{\"138\":1}}],[\"要发送的字节数\",{\"1\":{\"135\":1}}],[\"要发送的字节缓冲区\",{\"1\":{\"135\":1}}],[\"要发送的字节\",{\"1\":{\"135\":1}}],[\"要做的第一件事是以\",{\"1\":{\"127\":1}}],[\"要写入\",{\"1\":{\"121\":1,\"122\":1}}],[\"要写入的参数\",{\"1\":{\"119\":1,\"120\":1}}],[\"要写入的数据数量\",{\"1\":{\"80\":1}}],[\"要写入的数据\",{\"1\":{\"80\":2}}],[\"要写入的值\",{\"1\":{\"47\":1,\"49\":1}}],[\"要写入的地址\",{\"1\":{\"47\":1,\"49\":1,\"53\":1}}],[\"要使用中断回调\",{\"1\":{\"127\":1}}],[\"要使用第二个串行端口\",{\"1\":{\"138\":1}}],[\"要使用第二个\",{\"1\":{\"97\":1}}],[\"要使用此库\",{\"1\":{\"44\":1}}],[\"要从从设备读取\",{\"1\":{\"88\":1}}],[\"要从特定引脚分离中断\",{\"1\":{\"68\":1}}],[\"要结束传输\",{\"1\":{\"83\":1}}],[\"要将一些字节写入从设备\",{\"1\":{\"83\":1}}],[\"要开始在\",{\"1\":{\"83\":1,\"91\":1}}],[\"要分离的引脚号\",{\"1\":{\"68\":1}}],[\"要读取的字节数\",{\"1\":{\"88\":1}}],[\"要读取的地址\",{\"1\":{\"45\":1,\"51\":1,\"55\":1}}],[\"要读取配置为\",{\"1\":{\"65\":1}}],[\"要设置的分辨率\",{\"1\":{\"106\":1}}],[\"要设置的频率\",{\"1\":{\"105\":1}}],[\"要设置的\",{\"1\":{\"103\":1}}],[\"要设置的值\",{\"1\":{\"64\":1}}],[\"要设置的模式\",{\"1\":{\"62\":1}}],[\"要配置的引脚号\",{\"1\":{\"62\":1,\"64\":1,\"65\":1,\"67\":1}}],[\"从而允许多个ds18b20挂接在同一条1\",{\"1\":{\"175\":1}}],[\"从而实现擦除\",{\"1\":{\"8\":1}}],[\"从应用程序的角度来看无事可做\",{\"1\":{\"100\":1}}],[\"从设备地址\",{\"1\":{\"88\":1}}],[\"从机地址\",{\"1\":{\"93\":1}}],[\"从机地址来开始传输\",{\"1\":{\"83\":1}}],[\"从机\",{\"0\":{\"92\":1}}],[\"从机模式\",{\"0\":{\"90\":1},\"1\":{\"74\":1}}],[\"从模式\",{\"1\":{\"74\":1}}],[\"从\",{\"1\":{\"45\":2,\"47\":1,\"49\":1,\"51\":2,\"53\":1,\"55\":1}}],[\"扇区\",{\"1\":{\"43\":1}}],[\"模块\",{\"1\":{\"223\":1}}],[\"模块与air001开发板\",{\"1\":{\"223\":1}}],[\"模式下启用串行\",{\"1\":{\"140\":1}}],[\"模式时启用\",{\"1\":{\"63\":1}}],[\"模式配置为\",{\"1\":{\"63\":1}}],[\"模式\",{\"0\":{\"60\":1,\"74\":1},\"1\":{\"229\":2}}],[\"模拟输入模式\",{\"1\":{\"62\":1}}],[\"模拟\",{\"1\":{\"43\":1}}],[\"模数转换器\",{\"1\":{\"33\":1}}],[\"没有输出的引脚\",{\"1\":{\"125\":1}}],[\"没有内置的\",{\"1\":{\"43\":1}}],[\"没有拼写或语法错误\",{\"1\":{\"16\":1}}],[\"中途会安装驱动\",{\"1\":{\"159\":1}}],[\"中文路径导致编译报错\",{\"0\":{\"142\":1}}],[\"中请求的外设的第一个tx引脚\",{\"1\":{\"140\":1}}],[\"中定义\",{\"1\":{\"138\":1}}],[\"中找到的第一个\",{\"1\":{\"138\":1}}],[\"中的\",{\"1\":{\"98\":1,\"138\":1}}],[\"中的单元数\",{\"1\":{\"57\":2}}],[\"中断就是当\",{\"1\":{\"184\":1}}],[\"中断就是\",{\"1\":{\"184\":1}}],[\"中断来摆脱这种轮询逻辑造成的问题\",{\"1\":{\"184\":1}}],[\"中断触发模式\",{\"1\":{\"67\":1}}],[\"中断回调函数是这个中断被触发后会被调用的函数\",{\"1\":{\"184\":1}}],[\"中断回调函数\",{\"1\":{\"67\":1}}],[\"中断\",{\"0\":{\"66\":1,\"71\":1}}],[\"中\",{\"1\":{\"43\":1,\"130\":1,\"138\":2,\"247\":1}}],[\"简单写一个按顺序亮灯的小功能\",{\"1\":{\"224\":1}}],[\"简介\",{\"0\":{\"43\":1,\"165\":1,\"170\":1,\"175\":1,\"180\":1,\"187\":1,\"192\":1,\"197\":1,\"202\":1,\"207\":1,\"212\":1,\"217\":1,\"222\":1}}],[\"简体\",{\"1\":{\"23\":1}}],[\"至\",{\"1\":{\"38\":1,\"106\":1}}],[\"位数从0开始\",{\"1\":{\"219\":1}}],[\"位定时器\",{\"1\":{\"125\":1}}],[\"位顺序和数据模式\",{\"1\":{\"117\":1}}],[\"位地址\",{\"1\":{\"73\":1}}],[\"位\",{\"1\":{\"38\":1,\"106\":1}}],[\"位于github中\",{\"1\":{\"11\":1}}],[\"专用api\",{\"0\":{\"114\":1,\"138\":1}}],[\"专用\",{\"0\":{\"37\":1,\"104\":1}}],[\"即第一位为0\",{\"1\":{\"219\":1}}],[\"即可完成添加库\",{\"1\":{\"219\":1}}],[\"即可与处理器进行数据传输\",{\"1\":{\"175\":1}}],[\"即可看到输出的相关日志\",{\"1\":{\"157\":1}}],[\"即可正常编译\",{\"1\":{\"148\":1,\"149\":2}}],[\"即universal\",{\"1\":{\"129\":1}}],[\"即使有些定时器的位数更多\",{\"1\":{\"125\":1}}],[\"即serial\",{\"1\":{\"112\":1}}],[\"即pulse\",{\"1\":{\"101\":1}}],[\"即用作输入范围上限的值\",{\"1\":{\"36\":1}}],[\"即analog\",{\"1\":{\"33\":1}}],[\"配置\",{\"1\":{\"127\":1,\"131\":1}}],[\"配置的示例\",{\"1\":{\"127\":1}}],[\"配置为\",{\"1\":{\"64\":1}}],[\"配置有两种不同的模式\",{\"1\":{\"60\":1}}],[\"配置模拟输入所用的基准电压\",{\"1\":{\"36\":1}}],[\"配置文件\",{\"1\":{\"12\":1}}],[\"配置文件的入口文件\",{\"1\":{\"12\":1}}],[\"配置文件夹\",{\"1\":{\"12\":1}}],[\"配置文件存放路径\",{\"1\":{\"12\":1}}],[\"也保证了后续模拟时序的正确性\",{\"1\":{\"224\":1}}],[\"也称为翻转或更新\",{\"1\":{\"127\":1}}],[\"也不支持相同的功能\",{\"1\":{\"125\":1}}],[\"也就是说这种规范没有对应的技术标准\",{\"1\":{\"112\":1}}],[\"也可以通过变体或使用\",{\"1\":{\"35\":1}}],[\"也欢迎提供示例贡献\",{\"1\":{\"16\":1}}],[\"和三轴角度\",{\"1\":{\"194\":1}}],[\"和地线\",{\"1\":{\"175\":1}}],[\"和scl\",{\"1\":{\"73\":2}}],[\"和\",{\"1\":{\"35\":1,\"78\":1,\"85\":1,\"88\":2,\"91\":1,\"100\":2,\"125\":2,\"127\":4,\"138\":2,\"140\":1,\"166\":1}}],[\"到所需的\",{\"1\":{\"35\":1}}],[\"因为每个定时器只有\",{\"1\":{\"127\":1}}],[\"因为它们被定义为\",{\"1\":{\"99\":1}}],[\"因为大多数传感器\",{\"1\":{\"33\":1}}],[\"因此分开发两次\",{\"1\":{\"204\":1}}],[\"因此x轴的加速度读数应为正\",{\"1\":{\"193\":1}}],[\"因此对所有通道都是通用的\",{\"1\":{\"127\":1}}],[\"因此具有相同的周期\",{\"1\":{\"125\":1}}],[\"因此各个厂家生产的spi器件配置不一样\",{\"1\":{\"112\":1}}],[\"因此如果值没有更改\",{\"1\":{\"53\":1}}],[\"因此默认将其设置为最大可能值\",{\"1\":{\"35\":1}}],[\"采样时间\",{\"1\":{\"35\":2}}],[\"此处不作深入讲解\",{\"1\":{\"224\":1}}],[\"此时我们就可以直接使用这个工具了\",{\"1\":{\"249\":1}}],[\"此时将无法读取或写入\",{\"1\":{\"244\":1}}],[\"此时将自动擦除\",{\"1\":{\"243\":1}}],[\"此时三轴加速度为0\",{\"1\":{\"193\":1}}],[\"此时led灯熄灭\",{\"1\":{\"189\":1}}],[\"此时led灯亮起\",{\"1\":{\"189\":1}}],[\"此时电脑会识别到一个名为rpi\",{\"1\":{\"162\":1}}],[\"此时需要更改你的temp环境变量路径\",{\"1\":{\"149\":1}}],[\"此时配置为serial\",{\"1\":{\"131\":1}}],[\"此函数将调用\",{\"1\":{\"88\":2}}],[\"此函数将返回\",{\"1\":{\"76\":1}}],[\"此函数使用\",{\"1\":{\"53\":1}}],[\"此函数用于查看串口接收缓冲区中的下一个字节\",{\"1\":{\"137\":1}}],[\"此函数用于清空串口接收缓冲区\",{\"1\":{\"136\":1}}],[\"此函数用于向串口发送数据\",{\"1\":{\"135\":1}}],[\"此函数用于从串口接收缓冲区中读取一个字节\",{\"1\":{\"134\":1}}],[\"此函数用于关闭串口\",{\"1\":{\"132\":1}}],[\"此函数用于初始化串口\",{\"1\":{\"131\":1}}],[\"此函数用于获取串口接收缓冲区中的字节数\",{\"1\":{\"133\":1}}],[\"此函数用于获取内部参考电压的实际电压值\",{\"1\":{\"41\":1}}],[\"此函数用于获取内部温度传感器的实际温度值\",{\"1\":{\"40\":1}}],[\"此函数用于获取给定引脚上的实际电压值\",{\"1\":{\"39\":1}}],[\"此函数用于获取给定引脚\",{\"1\":{\"35\":1}}],[\"此函数用于设置\",{\"1\":{\"38\":1,\"103\":1,\"105\":1,\"106\":1}}],[\"此文档旨在介绍关于\",{\"1\":{\"19\":1}}],[\"通过\",{\"1\":{\"108\":1}}],[\"通过传递从属\",{\"1\":{\"86\":1}}],[\"通过使用不带任何参数的\",{\"1\":{\"83\":1,\"91\":1}}],[\"通过rts硬件复位\",{\"1\":{\"9\":1,\"247\":1,\"251\":1,\"252\":1}}],[\"通信接口\",{\"1\":{\"175\":1}}],[\"通信\",{\"1\":{\"81\":1,\"101\":1}}],[\"通常用于写入和读取引脚状态\",{\"1\":{\"59\":1}}],[\"通道特定的\",{\"1\":{\"127\":1}}],[\"通道范围\",{\"1\":{\"127\":1}}],[\"通道\",{\"1\":{\"35\":1}}],[\"通道的\",{\"1\":{\"35\":1}}],[\"通用api\",{\"0\":{\"130\":1}}],[\"通用异步收发器\",{\"1\":{\"129\":1}}],[\"通用\",{\"0\":{\"34\":1,\"75\":1,\"102\":1}}],[\"或捕获\",{\"1\":{\"127\":1}}],[\"或\",{\"1\":{\"64\":1,\"100\":1,\"118\":2,\"125\":1,\"127\":2,\"138\":2}}],[\"或自定义结构\",{\"1\":{\"51\":1,\"53\":1}}],[\"或模块都有不同数量的\",{\"1\":{\"33\":1}}],[\"或者只有\",{\"1\":{\"125\":1}}],[\"或者用户使用链接到\",{\"1\":{\"114\":1}}],[\"或者用户将\",{\"1\":{\"114\":1}}],[\"或者\",{\"1\":{\"77\":1,\"78\":1,\"80\":1,\"85\":1,\"88\":2}}],[\"或者是其它可擦写的最小单位\",{\"1\":{\"43\":1}}],[\"或者是直接按f5\",{\"1\":{\"7\":1}}],[\"或者在https\",{\"1\":{\"4\":1}}],[\"都可以通过开发板访问\",{\"1\":{\"59\":1}}],[\"都可以开启一个新的pr\",{\"1\":{\"16\":1}}],[\"都会产生模拟输出电压\",{\"1\":{\"33\":1}}],[\"力\",{\"1\":{\"33\":1}}],[\"压力\",{\"1\":{\"33\":1}}],[\"以像素为单位\",{\"1\":{\"209\":2}}],[\"以芯片内部中心为原点\",{\"1\":{\"193\":1}}],[\"以在\",{\"1\":{\"140\":1}}],[\"以避免在捕获发生之前发生翻转\",{\"1\":{\"127\":1}}],[\"以再次初始化i2c驱动程序\",{\"1\":{\"81\":1}}],[\"以及\",{\"1\":{\"166\":1,\"170\":1}}],[\"以及许多其他设备和微控制器的最常见外设之一\",{\"1\":{\"73\":1}}],[\"以及不同数量的可用通道和引脚\",{\"1\":{\"33\":1}}],[\"以下是完整\",{\"1\":{\"127\":1}}],[\"以下是如何在从模式下使用\",{\"1\":{\"96\":1}}],[\"以下是如何在主模式下使用\",{\"1\":{\"89\":1}}],[\"以下是主模式和从模式下使用的常用功能\",{\"1\":{\"75\":1}}],[\"以下是\",{\"1\":{\"61\":1,\"84\":1}}],[\"以便微控制器可以读取和处理\",{\"1\":{\"33\":1}}],[\"以节省您解决常见问题的时间\",{\"1\":{\"32\":1}}],[\"列表中提前搜索\",{\"1\":{\"32\":1}}],[\"社区支持\",{\"1\":{\"31\":1}}],[\"由于需要兼容\",{\"1\":{\"229\":1}}],[\"由于ws2812灯珠是串在一起进行通信的\",{\"1\":{\"224\":1}}],[\"由于\",{\"1\":{\"223\":1}}],[\"由于只是演示\",{\"1\":{\"209\":1}}],[\"由于一次只能发一个8位数据\",{\"1\":{\"204\":1}}],[\"由于使用了boot按键\",{\"1\":{\"183\":1}}],[\"由\",{\"1\":{\"31\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1}}],[\"相关支持\",{\"0\":{\"31\":1}}],[\"包括但不限于\",{\"1\":{\"214\":1}}],[\"包括速率\",{\"1\":{\"117\":1}}],[\"包\",{\"1\":{\"30\":1}}],[\"包管理安装\",{\"1\":{\"9\":1}}],[\"官方文档\",{\"1\":{\"29\":1,\"130\":1}}],[\"余下的接口\",{\"1\":{\"29\":1}}],[\"同时在串口监视器中将波特率调为115200可观察到如下字样\",{\"1\":{\"215\":1}}],[\"同时也可以调用芯片专用的接口如hal库\",{\"1\":{\"29\":1}}],[\"同一定时器的所有通道同时启动\",{\"1\":{\"127\":1}}],[\"同步串行接口\",{\"1\":{\"112\":1}}],[\"同样\",{\"1\":{\"4\":1}}],[\"兼容\",{\"1\":{\"36\":1}}],[\"兼容官方的\",{\"1\":{\"29\":1}}],[\"兼容的开源许可证获得了许可\",{\"1\":{\"16\":1}}],[\"核心参考\",{\"0\":{\"29\":1}}],[\"有时候我们会不小心将\",{\"1\":{\"251\":1}}],[\"有时spi接口被称作四线式接口\",{\"1\":{\"112\":1}}],[\"有0~7七个亮度等级\",{\"1\":{\"219\":1}}],[\"有文字的一面\",{\"1\":{\"193\":1}}],[\"有概率会影响到自动进入boot模式的逻辑\",{\"1\":{\"183\":1}}],[\"有多个\",{\"1\":{\"138\":1}}],[\"有特殊限制\",{\"1\":{\"59\":1}}],[\"有些实例由\",{\"1\":{\"127\":1}}],[\"有些定时器有多达\",{\"1\":{\"125\":1}}],[\"有些\",{\"1\":{\"59\":1}}],[\"有关电阻值和工作电压的更多详细信息\",{\"1\":{\"73\":1}}],[\"有关详细信息\",{\"1\":{\"33\":1}}],[\"有关开发板的更多资料\",{\"1\":{\"28\":1}}],[\"有一个专用于文档的仓库\",{\"1\":{\"11\":1}}],[\"有一个支持的调试器\",{\"1\":{\"2\":1}}],[\"✅\",{\"1\":{\"28\":3,\"30\":9,\"108\":11,\"234\":1}}],[\"详细链接\",{\"1\":{\"28\":1}}],[\"目前支持以下芯片\",{\"1\":{\"234\":1}}],[\"目前\",{\"1\":{\"108\":1,\"110\":1}}],[\"目前我们支持的\",{\"1\":{\"28\":1}}],[\"目标芯片型号\",{\"1\":{\"9\":1,\"249\":1}}],[\"框架\",{\"1\":{\"27\":1}}],[\"系统\",{\"1\":{\"30\":1}}],[\"系统中进行\",{\"1\":{\"17\":1}}],[\"系列通过内部大约\",{\"1\":{\"63\":1}}],[\"系列\",{\"1\":{\"27\":1,\"28\":1}}],[\"旨在适配上海合宙通信有限公司的\",{\"1\":{\"27\":1}}],[\"进入\",{\"1\":{\"229\":1}}],[\"进一步优化\",{\"0\":{\"184\":1}}],[\"进行驱动\",{\"1\":{\"224\":1}}],[\"进行调用\",{\"1\":{\"184\":1}}],[\"进行安装\",{\"1\":{\"172\":1,\"177\":1,\"209\":1,\"214\":1}}],[\"进行开发测试\",{\"1\":{\"26\":1}}],[\"进阶用法\",{\"0\":{\"97\":1}}],[\"进阶教程\",{\"1\":{\"12\":1}}],[\"可能需要降低波特率再试\",{\"1\":{\"236\":1,\"248\":1}}],[\"可能会稍慢\",{\"1\":{\"26\":1,\"159\":1}}],[\"可通过多个\",{\"1\":{\"222\":1}}],[\"可观察到四位数码管显示12\",{\"1\":{\"220\":1}}],[\"可观察到当前温湿度\",{\"1\":{\"205\":1}}],[\"可观察到当前状态和温度\",{\"1\":{\"195\":1}}],[\"可观察到当前的信息\",{\"1\":{\"173\":1,\"178\":1}}],[\"可尝试下面的步骤进行烧录\",{\"1\":{\"183\":1}}],[\"可控电压源\",{\"1\":{\"166\":1}}],[\"可配置为遵循单线半双工协议\",{\"1\":{\"140\":1}}],[\"可选值为serial\",{\"1\":{\"131\":1}}],[\"可选\",{\"1\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1}}],[\"可用于两种不同的模式\",{\"1\":{\"74\":1}}],[\"可在将\",{\"1\":{\"63\":1}}],[\"可以看到\",{\"1\":{\"225\":1}}],[\"可以看到当前的配置\",{\"1\":{\"148\":1}}],[\"可以读取三轴角度\",{\"1\":{\"192\":1}}],[\"可以实现三个灯依次被点亮的效果\",{\"1\":{\"190\":1}}],[\"可以打开arduino管理库\",{\"1\":{\"172\":1,\"177\":1,\"209\":1}}],[\"可以直接通过排针排母相连\",{\"1\":{\"154\":1}}],[\"可以通过hal\",{\"1\":{\"125\":1}}],[\"可以多次调用\",{\"1\":{\"118\":1}}],[\"可以在刷新时一次性将所有状态全部发给ws2812\",{\"1\":{\"224\":1}}],[\"可以在开发板上观察到测试结果\",{\"1\":{\"189\":1}}],[\"可以在串口监视器中看到\",{\"1\":{\"183\":1}}],[\"可以在更新中断\",{\"1\":{\"127\":1}}],[\"可以在不停止\",{\"1\":{\"114\":1}}],[\"可以在github上获取该项目的源码\",{\"1\":{\"8\":1}}],[\"可以使用\",{\"1\":{\"100\":1,\"140\":1,\"214\":1}}],[\"可以像数组一样使用\",{\"1\":{\"55\":1}}],[\"可以参考这篇文章\",{\"1\":{\"149\":1}}],[\"可以参考\",{\"1\":{\"29\":1,\"130\":1}}],[\"可以参考左侧的\",{\"1\":{\"29\":1}}],[\"可以点击file\",{\"1\":{\"23\":1}}],[\"可以右键添加到开始菜单或者在桌面创建快捷方式\",{\"1\":{\"22\":1}}],[\"可以是以下值之一\",{\"1\":{\"62\":1,\"64\":1,\"65\":1,\"67\":1}}],[\"可以是原始类型\",{\"1\":{\"51\":1,\"53\":1}}],[\"可以是\",{\"1\":{\"2\":1}}],[\"34\",{\"1\":{\"220\":1}}],[\"340+36\",{\"1\":{\"194\":1}}],[\"3600\",{\"1\":{\"214\":2}}],[\"300\",{\"1\":{\"204\":1}}],[\"3来输出pwm\",{\"1\":{\"199\":1}}],[\"3v\",{\"1\":{\"171\":1,\"176\":1,\"193\":1,\"198\":1,\"203\":1,\"208\":1,\"213\":1}}],[\"32\",{\"1\":{\"100\":1,\"194\":1,\"214\":1}}],[\"3\",{\"1\":{\"25\":1,\"50\":2,\"52\":1,\"54\":1,\"98\":1,\"114\":1,\"123\":10,\"171\":1,\"176\":1,\"189\":3,\"190\":2,\"193\":1,\"194\":1,\"198\":1,\"199\":1,\"203\":1,\"204\":1,\"208\":1,\"213\":1,\"219\":2,\"224\":1}}],[\"39\",{\"1\":{\"9\":1,\"247\":1}}],[\"首先通过\",{\"1\":{\"219\":1}}],[\"首先下载grove\",{\"1\":{\"219\":1}}],[\"首先引用这些库\",{\"1\":{\"209\":1,\"214\":1}}],[\"首先将gpio设置为high\",{\"1\":{\"189\":1}}],[\"首先\",{\"1\":{\"146\":1,\"149\":1,\"172\":1,\"177\":1,\"182\":1,\"184\":1,\"209\":1,\"224\":1}}],[\"首先提醒一下\",{\"1\":{\"125\":1}}],[\"首选项\",{\"1\":{\"25\":1}}],[\"首次安装默认语言为英文\",{\"1\":{\"23\":1}}],[\"支持模式有\",{\"1\":{\"127\":1}}],[\"支持\",{\"1\":{\"108\":1}}],[\"支持以下外设\",{\"1\":{\"108\":1}}],[\"支持的外设\",{\"0\":{\"108\":1}}],[\"支持的操作系统\",{\"0\":{\"30\":1}}],[\"支持芯片的相关数据手册\",{\"1\":{\"110\":1}}],[\"支持芯片\",{\"0\":{\"28\":1}}],[\"支持包\",{\"0\":{\"24\":1}}],[\"支持跨平台\",{\"1\":{\"8\":1}}],[\"语言将切换为中文\",{\"1\":{\"23\":1}}],[\"双击解压后的文件夹中的arduino\",{\"1\":{\"22\":1}}],[\"双击安装包进行安装\",{\"1\":{\"21\":1}}],[\"稍等一会就可以安装好了\",{\"1\":{\"21\":1}}],[\"默认全为\",{\"1\":{\"224\":1}}],[\"默认值为\",{\"1\":{\"105\":1}}],[\"默认\",{\"0\":{\"98\":1},\"1\":{\"98\":1}}],[\"默认情况下\",{\"1\":{\"97\":1,\"100\":1,\"138\":1}}],[\"默认为\",{\"1\":{\"38\":1,\"106\":1}}],[\"默认为10次\",{\"1\":{\"9\":1,\"228\":1,\"249\":1}}],[\"默认安装位置不用动\",{\"1\":{\"21\":1}}],[\"根据网速等待片刻即可下载完成\",{\"1\":{\"21\":1}}],[\"选择之前下载的zip压缩文件\",{\"1\":{\"219\":1}}],[\"选择其他开发板和端口\",{\"1\":{\"160\":1}}],[\"选择raspberry\",{\"1\":{\"160\":1}}],[\"选择开发板\",{\"0\":{\"160\":1}}],[\"选择语言为中文\",{\"1\":{\"23\":1}}],[\"选择just\",{\"1\":{\"21\":1}}],[\"选择老版本进行下载安装\",{\"1\":{\"21\":1,\"22\":1}}],[\"选项中一定要选择有带\",{\"1\":{\"6\":1}}],[\"但会避免执行读取\",{\"1\":{\"140\":1}}],[\"但不会将其从缓冲区中删除\",{\"1\":{\"137\":1}}],[\"但不会在桌面建立ide启动图标\",{\"1\":{\"20\":1}}],[\"但并非所有定时器都支持4个通道\",{\"1\":{\"127\":1}}],[\"但仅在使用时使用\",{\"1\":{\"127\":1}}],[\"但仅在值不同的情况下才写入\",{\"1\":{\"49\":1}}],[\"但是\",{\"1\":{\"127\":1}}],[\"但是重要的是要理解同一定时器的所有通道共享相同的计数器\",{\"1\":{\"125\":1}}],[\"但是它使用差分信号\",{\"1\":{\"112\":1}}],[\"但是它又与同步串行接口协议\",{\"1\":{\"112\":1}}],[\"但是我们最多可以传输\",{\"1\":{\"100\":1}}],[\"但是在引脚上启用开漏输出\",{\"1\":{\"62\":1}}],[\"但是在引脚上启用内部下拉电阻\",{\"1\":{\"62\":1}}],[\"但是在引脚上启用内部上拉电阻\",{\"1\":{\"62\":1}}],[\"但是可以使用\",{\"1\":{\"43\":1}}],[\"但是为了方便编写\",{\"1\":{\"13\":1}}],[\"zip库\",{\"1\":{\"219\":1}}],[\"zip压缩包免安装版解压后即可使用\",{\"1\":{\"20\":1}}],[\"zero\",{\"1\":{\"89\":1}}],[\"zh\",{\"1\":{\"13\":1}}],[\"提供给下一次读取使用\",{\"1\":{\"182\":1}}],[\"提供了专用的一体化\",{\"1\":{\"127\":1}}],[\"提供了一些独特的\",{\"1\":{\"109\":1}}],[\"提交前请务必在\",{\"1\":{\"32\":1}}],[\"提示\",{\"1\":{\"20\":1,\"21\":1,\"22\":1,\"25\":1,\"26\":1,\"29\":1,\"32\":1,\"138\":1,\"146\":1,\"148\":1,\"159\":1,\"170\":1,\"175\":1,\"181\":1,\"184\":2,\"188\":1,\"192\":1,\"193\":1,\"194\":1,\"197\":1,\"198\":1,\"199\":1,\"202\":1,\"203\":1,\"208\":1,\"212\":1,\"214\":1,\"217\":1,\"222\":1,\"223\":1,\"242\":1,\"248\":2,\"251\":1,\"252\":1}}],[\"提高美观度\",{\"1\":{\"13\":1}}],[\"xcl\",{\"1\":{\"193\":1}}],[\"x\",{\"1\":{\"96\":2}}],[\"x及linux等平台\",{\"1\":{\"20\":1}}],[\"xserial=generic\",{\"1\":{\"7\":1}}],[\"贡献流程\",{\"0\":{\"18\":1}}],[\"贡献指南\",{\"0\":{\"14\":1},\"1\":{\"12\":1}}],[\"后续仅需调用tm1637对象即可操作数码管\",{\"1\":{\"219\":1}}],[\"后续仅需调用tft即可驱动st7735\",{\"1\":{\"214\":1}}],[\"后续仅需调用my\",{\"1\":{\"199\":1}}],[\"后续仅需调用sensors对象即可使用ds18b20\",{\"1\":{\"177\":1}}],[\"后续仅需调用bmp对象即可使用bmp180\",{\"1\":{\"172\":1}}],[\"后发展成了行业规范\",{\"1\":{\"112\":1}}],[\"后者无须管理员权限也可运行使用\",{\"1\":{\"20\":1}}],[\"后\",{\"1\":{\"17\":1,\"81\":1,\"83\":2}}],[\"后文中我们将其称之为\",{\"1\":{\"15\":1}}],[\"它设置了\",{\"1\":{\"224\":1}}],[\"它仅需一个\",{\"1\":{\"222\":1}}],[\"它自身将具有相反方向的加速度\",{\"1\":{\"193\":1}}],[\"它可以打断当前代码的运行\",{\"1\":{\"184\":1}}],[\"它可以通过定义更精确地定义\",{\"1\":{\"35\":1}}],[\"它对应于周期或频率\",{\"1\":{\"127\":1}}],[\"它们被用于实现\",{\"1\":{\"125\":1}}],[\"它们是否被归类为逻辑变更\",{\"1\":{\"16\":1}}],[\"它的典型应用有闪存\",{\"1\":{\"112\":1}}],[\"它将由\",{\"1\":{\"127\":1}}],[\"它将被合并到\",{\"1\":{\"17\":1}}],[\"它将首先被合并到我们的内部\",{\"1\":{\"17\":1}}],[\"它使用了默认的i2c引脚\",{\"1\":{\"97\":1}}],[\"它使用\",{\"1\":{\"8\":1}}],[\"风格指南和下面的示例指南\",{\"1\":{\"16\":1}}],[\"是数字温度传感器\",{\"1\":{\"175\":1}}],[\"是专为测量大气压力而设计的基本传感器\",{\"1\":{\"170\":1}}],[\"是串行实例的编号\",{\"1\":{\"138\":1}}],[\"是完全不同的两种协议\",{\"1\":{\"112\":1}}],[\"是是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术\",{\"1\":{\"101\":1}}],[\"是微控制器中最常用和通用的外设之一\",{\"1\":{\"59\":1}}],[\"是一种带键盘扫描接口的led数码管驱动控制专用电路\",{\"1\":{\"217\":1}}],[\"是一种串行\",{\"1\":{\"129\":1}}],[\"是一种用于芯片通信的同步串行通信接口规范\",{\"1\":{\"112\":1}}],[\"是一种广泛使用的串行通信\",{\"1\":{\"73\":1}}],[\"是一种存储器\",{\"1\":{\"43\":1}}],[\"是一种非常常见的外设\",{\"1\":{\"33\":1}}],[\"是一个三色\",{\"1\":{\"222\":1}}],[\"是一个\",{\"1\":{\"127\":1}}],[\"是一个主机和一个或多个从机的主从模式\",{\"1\":{\"112\":1}}],[\"是一个重载了eeprom类的operator\",{\"1\":{\"55\":1}}],[\"是一个由社区推动\",{\"1\":{\"27\":1}}],[\"是一个flash烧录工具\",{\"1\":{\"9\":1,\"249\":1}}],[\"是一个通过串口与芯片isp功能进行交互\",{\"1\":{\"8\":1}}],[\"是否支持\",{\"1\":{\"28\":1,\"234\":1}}],[\"是否有名称为\",{\"1\":{\"16\":1}}],[\"是否有与代码贡献相关的文档或示例\",{\"1\":{\"16\":1}}],[\"如若使用劣质串口转usb芯片导致通信失败\",{\"1\":{\"251\":1,\"252\":1}}],[\"如若使用不带外置晶振的usb转串口芯片导致通信失败\",{\"1\":{\"236\":1,\"248\":1}}],[\"如若无法进入boot模式导致无法烧录\",{\"1\":{\"183\":1}}],[\"如com12\",{\"1\":{\"235\":1}}],[\"如\",{\"1\":{\"114\":1,\"125\":1,\"146\":1,\"149\":1}}],[\"如本节所述\",{\"1\":{\"109\":1}}],[\"如本文档中所述\",{\"1\":{\"73\":1}}],[\"如需自行设置值\",{\"1\":{\"83\":1,\"91\":1}}],[\"如下代码定义其他颜色\",{\"1\":{\"214\":1}}],[\"如下图\",{\"1\":{\"173\":1,\"195\":1,\"205\":1}}],[\"如下图所示\",{\"1\":{\"143\":1}}],[\"如下\",{\"1\":{\"28\":1,\"178\":1}}],[\"如果加上了这个参数\",{\"1\":{\"227\":1}}],[\"如果初始化失败\",{\"1\":{\"209\":1}}],[\"如果这个函数中添加了其他耗时的操作\",{\"1\":{\"184\":1}}],[\"如果有变化\",{\"1\":{\"182\":1}}],[\"如果没变化\",{\"1\":{\"182\":1}}],[\"如果没有可读取的字节\",{\"1\":{\"134\":1,\"137\":1}}],[\"如果没有\",{\"1\":{\"16\":1}}],[\"如果成功获取\",{\"1\":{\"177\":1}}],[\"如果你是直接连接的ds18b20元器件\",{\"1\":{\"176\":1}}],[\"如果代码编译上传正常\",{\"1\":{\"157\":1,\"163\":1}}],[\"如果是购买的小白板和合宙的daplink调试器\",{\"1\":{\"154\":1}}],[\"如果是有关核心库部分\",{\"1\":{\"18\":1}}],[\"如果是有关\",{\"1\":{\"18\":1}}],[\"如果购买了合宙的daplink调试器\",{\"1\":{\"154\":1}}],[\"如果依旧报错\",{\"1\":{\"149\":1}}],[\"如果在定时器运行时分离和附加中断\",{\"1\":{\"127\":1}}],[\"如果第一个\",{\"1\":{\"127\":1}}],[\"如果未指定通道\",{\"1\":{\"127\":1}}],[\"如果未定义上拉或下拉模式\",{\"1\":{\"63\":1}}],[\"如果定时器时钟为\",{\"1\":{\"127\":1}}],[\"如果需要其他功能\",{\"1\":{\"125\":1}}],[\"如果\",{\"1\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"140\":2}}],[\"如果模式设置为\",{\"1\":{\"118\":1}}],[\"如果要管理多个设备\",{\"1\":{\"118\":1}}],[\"如果配置该引脚\",{\"1\":{\"115\":1}}],[\"如果为\",{\"1\":{\"87\":1,\"88\":1,\"93\":2}}],[\"如果外设正确初始化\",{\"1\":{\"76\":1}}],[\"如果目的地址与目的设备相同则响应主设备\",{\"1\":{\"74\":1}}],[\"如果测试通过\",{\"1\":{\"17\":1}}],[\"如果您在\",{\"1\":{\"138\":1}}],[\"如果您有任何新想法或者功能建议\",{\"1\":{\"32\":1}}],[\"如果您对上述任何一点不确定\",{\"1\":{\"16\":1}}],[\"如果您通过添加新示例进行贡献\",{\"1\":{\"16\":1}}],[\"如果贡献包含多个提交\",{\"1\":{\"16\":1}}],[\"如何贡献\",{\"0\":{\"15\":1}}],[\"请确认外接的sht30模块上有相应处理\",{\"1\":{\"203\":1}}],[\"请全部点击安装\",{\"1\":{\"159\":1}}],[\"请尝试手动进入boot模式\",{\"1\":{\"152\":1}}],[\"请注意\",{\"1\":{\"127\":1}}],[\"请勿在参数中使用带有\",{\"1\":{\"115\":1}}],[\"请在代码顶部包含头文件\",{\"1\":{\"44\":1}}],[\"请参阅\",{\"1\":{\"127\":1}}],[\"请参阅您的\",{\"1\":{\"125\":1}}],[\"请参阅函数说明\",{\"1\":{\"83\":1,\"91\":1}}],[\"请参阅器件数据表\",{\"1\":{\"73\":1}}],[\"请参阅相应的板引脚布局信息\",{\"1\":{\"59\":1}}],[\"请参阅每个板的数据手册\",{\"1\":{\"33\":1}}],[\"请参考下面的流程\",{\"1\":{\"18\":1}}],[\"请参考文档贡献指南\",{\"1\":{\"18\":1}}],[\"请前往功能请求模板\",{\"1\":{\"32\":1}}],[\"请前往问题模板\",{\"1\":{\"32\":1}}],[\"请查看所述链接中的开发板内容\",{\"1\":{\"28\":1}}],[\"请读者自行研究\",{\"1\":{\"20\":1}}],[\"请求获取6字节的数据\",{\"1\":{\"204\":1}}],[\"请求本身的注释栏中可能会有一些讨论\",{\"1\":{\"17\":1}}],[\"请求流程\",{\"0\":{\"17\":1}}],[\"请求之前\",{\"1\":{\"16\":1}}],[\"请使用函数\",{\"1\":{\"65\":1}}],[\"请使用\",{\"1\":{\"16\":1,\"68\":1,\"83\":2,\"88\":1}}],[\"请考虑以下事项\",{\"1\":{\"16\":1}}],[\"请耐心等待\",{\"1\":{\"9\":1,\"26\":1,\"159\":1,\"247\":1}}],[\"前置要求\",{\"0\":{\"16\":1}}],[\"前往github\",{\"1\":{\"9\":1}}],[\"接线示意如下\",{\"1\":{\"198\":1}}],[\"接着声明showtext函数\",{\"1\":{\"209\":1}}],[\"接着对比这一次的电平是否变化\",{\"1\":{\"182\":1}}],[\"接着\",{\"1\":{\"182\":1,\"184\":1,\"189\":1,\"209\":1}}],[\"接口\",{\"1\":{\"162\":1}}],[\"接口的情况下管理多个\",{\"1\":{\"114\":1}}],[\"接口引脚在\",{\"1\":{\"98\":1}}],[\"接受贡献\",{\"1\":{\"15\":1}}],[\"接下来是真正模拟ws2812时序的函数\",{\"1\":{\"224\":1}}],[\"接下来可以继续查看应用示例\",{\"1\":{\"157\":1,\"163\":1}}],[\"接下来可以继续查看下一章节\",{\"1\":{\"26\":1}}],[\"接下来针对两种方式分别介绍如何安装\",{\"1\":{\"20\":1}}],[\"接下来\",{\"1\":{\"7\":1}}],[\"修正了拼写错误\",{\"1\":{\"16\":1}}],[\"修复错误\",{\"1\":{\"15\":1}}],[\"修改后重新启动\",{\"1\":{\"149\":1}}],[\"修改完后\",{\"1\":{\"148\":1}}],[\"修改语言\",{\"0\":{\"23\":1}}],[\"修改读保护等功能的一个小工具\",{\"1\":{\"8\":1}}],[\"修改runtoentrypoint属性\",{\"1\":{\"7\":1}}],[\"修改executable属性\",{\"1\":{\"7\":1}}],[\"做出贡献\",{\"1\":{\"15\":1}}],[\"欢迎对\",{\"1\":{\"15\":1}}],[\"项目做出任何贡献\",{\"1\":{\"14\":1}}],[\"项目主页\",{\"1\":{\"12\":1}}],[\"图标名\",{\"1\":{\"13\":1}}],[\"图标列表找到\",{\"1\":{\"13\":1}}],[\"标题\",{\"1\":{\"13\":1}}],[\"标准语法\",{\"1\":{\"13\":1}}],[\"一块\",{\"1\":{\"208\":1}}],[\"一旦计时器启动并启用回调\",{\"1\":{\"127\":1}}],[\"一旦拉取请求准备好合并\",{\"1\":{\"17\":1}}],[\"一些额外的\",{\"1\":{\"127\":1}}],[\"一些例子\",{\"1\":{\"125\":1}}],[\"一起使用时\",{\"1\":{\"127\":2}}],[\"一个用于输入数据的缓冲区\",{\"1\":{\"122\":1}}],[\"一个用于输出数据的缓冲区\",{\"1\":{\"122\":1}}],[\"一个典型的配置如下\",{\"1\":{\"7\":1}}],[\"一般集成在\",{\"1\":{\"222\":1}}],[\"一般我们习惯上使用serial1来作为全局的serial对象\",{\"1\":{\"138\":1}}],[\"一般来说\",{\"1\":{\"43\":1}}],[\"一般习惯上来说\",{\"1\":{\"13\":1}}],[\"句末需要加上中文句号\",{\"1\":{\"13\":1}}],[\"例子\",{\"0\":{\"123\":1},\"1\":{\"13\":1}}],[\"例如温度\",{\"1\":{\"33\":1}}],[\"例如docs\",{\"1\":{\"13\":1}}],[\"例如例子\",{\"1\":{\"13\":1}}],[\"例如\",{\"1\":{\"6\":1,\"51\":1,\"53\":1,\"59\":1,\"60\":1,\"138\":1}}],[\"英文与汉字之间需要添加空格\",{\"1\":{\"13\":1}}],[\"减小文件体积\",{\"1\":{\"13\":1}}],[\"其他系统上可能为airisp\",{\"1\":{\"249\":1}}],[\"其他系统大同小异\",{\"1\":{\"20\":1}}],[\"其他代码会继续执行\",{\"1\":{\"184\":1}}],[\"其值在电路板断电时保留\",{\"1\":{\"43\":1}}],[\"其余参考\",{\"1\":{\"13\":1}}],[\"其中变量即为旋转角度\",{\"1\":{\"199\":1}}],[\"其中有\",{\"1\":{\"125\":1}}],[\"其中包含\",{\"1\":{\"57\":1}}],[\"其中\",{\"1\":{\"12\":1,\"138\":1,\"140\":1}}],[\"每次刷新消耗约2\",{\"1\":{\"214\":1}}],[\"每个像素用16比特位表示\",{\"1\":{\"214\":1}}],[\"每个两位\",{\"1\":{\"194\":1}}],[\"每个ds18b20具有唯一的64位序列号\",{\"1\":{\"175\":1}}],[\"每个定时器可以提供多个通道\",{\"1\":{\"125\":1}}],[\"每个设备都有一个唯一的\",{\"1\":{\"73\":1}}],[\"每个\",{\"1\":{\"33\":1}}],[\"每个拉取请求一个主要变更\",{\"1\":{\"16\":1}}],[\"每个文件夹下的readme\",{\"1\":{\"12\":1}}],[\"每篇文档的头部类似如下的写法\",{\"1\":{\"13\":1}}],[\"每篇文档的头部应当加上一个\",{\"1\":{\"13\":1}}],[\"格式要求\",{\"0\":{\"13\":1}}],[\"常见问题\",{\"1\":{\"12\":1}}],[\"客户端文件\",{\"1\":{\"12\":1}}],[\"自由禁用和启用回调\",{\"1\":{\"127\":1}}],[\"自身的引用\",{\"1\":{\"55\":1}}],[\"自动boot模式需要连接dtr与rts才能实现\",{\"1\":{\"152\":1}}],[\"自动测试\",{\"1\":{\"17\":1}}],[\"自动部署文档的工作流\",{\"1\":{\"12\":1}}],[\"自带的\",{\"1\":{\"7\":1}}],[\"yellow\",{\"1\":{\"214\":1}}],[\"yaml\",{\"1\":{\"148\":1}}],[\"yay\",{\"1\":{\"9\":1,\"249\":1}}],[\"your\",{\"1\":{\"155\":2}}],[\"you\",{\"1\":{\"54\":1,\"161\":1}}],[\"yml\",{\"1\":{\"12\":1}}],[\"└──\",{\"1\":{\"12\":5}}],[\"│\",{\"1\":{\"12\":53}}],[\"→\",{\"1\":{\"12\":18}}],[\"├──\",{\"1\":{\"12\":13}}],[\"该参数用来表示通信时需要使用的波特率\",{\"1\":{\"236\":1}}],[\"该参数用来指示是所有的串口名称\",{\"1\":{\"235\":1}}],[\"该参数用来指示当前的芯片型号\",{\"1\":{\"234\":1}}],[\"该引脚必须是硬件\",{\"1\":{\"115\":1}}],[\"该模式用于接受来自主机的通信\",{\"1\":{\"90\":1}}],[\"该模式用于启动与从机的通信\",{\"1\":{\"82\":1}}],[\"该设备可以是按钮或开关\",{\"1\":{\"60\":1}}],[\"该外设广泛用于创建\",{\"1\":{\"59\":1}}],[\"该函数将返回错误代码\",{\"1\":{\"87\":1}}],[\"该函数将返回模拟温度值\",{\"1\":{\"40\":1}}],[\"该函数将返回模拟电压值\",{\"1\":{\"39\":1,\"41\":1}}],[\"该函数将返回模拟原始值\",{\"1\":{\"35\":1}}],[\"该函数将数据写入缓冲区\",{\"1\":{\"80\":1}}],[\"该函数用于触发中断后\",{\"1\":{\"184\":1}}],[\"该函数用于启动与从设备的通信过程\",{\"1\":{\"86\":1}}],[\"该函数用于启动\",{\"1\":{\"86\":1}}],[\"该函数用于停止\",{\"1\":{\"81\":1}}],[\"该函数用于设置\",{\"1\":{\"77\":1,\"78\":1,\"79\":1}}],[\"该函数用于使用默认配置启动外设\",{\"1\":{\"76\":1}}],[\"该函数返回一个无符号整数\",{\"1\":{\"57\":1}}],[\"该运算符允许像数组一样使用标识符\",{\"1\":{\"55\":1}}],[\"该贡献完全是您自己的作品吗\",{\"1\":{\"16\":1}}],[\"该文档使用了vuepress进行配置\",{\"1\":{\"11\":1}}],[\"该属性为调试时自动运行到入口点\",{\"1\":{\"7\":1}}],[\"该属性的含义是一个arm\",{\"1\":{\"7\":1}}],[\"关闭\",{\"1\":{\"243\":1}}],[\"关闭读保护\",{\"1\":{\"9\":1,\"249\":1}}],[\"关于mpu6050的方向\",{\"1\":{\"193\":1}}],[\"关于\",{\"0\":{\"11\":1,\"27\":1,\"73\":1,\"112\":1,\"129\":1}}],[\"文件\",{\"1\":{\"138\":1}}],[\"文件旁边添加一个\",{\"1\":{\"138\":1}}],[\"文件中的值\",{\"1\":{\"99\":1}}],[\"文件中配置\",{\"1\":{\"98\":1}}],[\"文件的地址\",{\"1\":{\"7\":1}}],[\"文章的顺序序列号\",{\"1\":{\"13\":1}}],[\"文档时序内容\",{\"1\":{\"224\":1}}],[\"文档概述\",{\"0\":{\"107\":1}}],[\"文档部分\",{\"1\":{\"18\":1}}],[\"文档排版需要合理\",{\"1\":{\"13\":1}}],[\"文档文件夹\",{\"1\":{\"12\":1}}],[\"文档结构\",{\"0\":{\"12\":1}}],[\"文档编写规范\",{\"0\":{\"10\":1}}],[\"mpu\",{\"1\":{\"194\":5}}],[\"mpu6050的总线地址是0x68\",{\"1\":{\"194\":1}}],[\"mpu6050使用i²c通信接口\",{\"1\":{\"192\":1}}],[\"mpu6050\",{\"0\":{\"191\":1},\"1\":{\"193\":1}}],[\"mv\",{\"1\":{\"167\":3}}],[\"mbed\",{\"1\":{\"159\":1}}],[\"minutes\",{\"1\":{\"214\":2}}],[\"millis\",{\"1\":{\"214\":1}}],[\"milliseconds\",{\"1\":{\"127\":1}}],[\"microseconds\",{\"1\":{\"127\":3}}],[\"microsec\",{\"1\":{\"127\":6}}],[\"miso\",{\"0\":{\"115\":1},\"1\":{\"115\":2,\"123\":1,\"124\":2}}],[\"method\",{\"1\":{\"127\":1}}],[\"measurement\",{\"1\":{\"127\":2}}],[\"message\",{\"1\":{\"89\":1,\"96\":1}}],[\"must\",{\"1\":{\"127\":2}}],[\"my\",{\"1\":{\"199\":7}}],[\"mytim\",{\"1\":{\"127\":27}}],[\"myobject\",{\"1\":{\"52\":2,\"54\":2}}],[\"mosi\",{\"0\":{\"115\":1},\"1\":{\"115\":2,\"123\":1,\"124\":2,\"213\":1,\"214\":2,\"223\":1}}],[\"modulation\",{\"1\":{\"101\":1}}],[\"module\",{\"1\":{\"98\":2}}],[\"mode1\",{\"1\":{\"224\":1}}],[\"mode\",{\"0\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1},\"1\":{\"60\":2,\"67\":2,\"98\":16,\"119\":3,\"120\":3,\"121\":3,\"122\":3,\"126\":4,\"127\":2}}],[\"more\",{\"1\":{\"89\":1,\"126\":1}}],[\"move\",{\"1\":{\"52\":1,\"54\":1}}],[\"mcu\",{\"1\":{\"26\":1,\"27\":1,\"28\":2,\"33\":1,\"125\":1,\"127\":1,\"189\":1,\"251\":1}}],[\"maxstring\",{\"1\":{\"214\":3}}],[\"magenta\",{\"1\":{\"214\":1}}],[\"making\",{\"1\":{\"161\":1}}],[\"main\",{\"1\":{\"155\":1}}],[\"match\",{\"1\":{\"126\":3}}],[\"master\",{\"1\":{\"96\":3}}],[\"may\",{\"1\":{\"52\":1}}],[\"macos\",{\"1\":{\"30\":1}}],[\"mac\",{\"1\":{\"20\":1}}],[\"markdown\",{\"1\":{\"13\":2}}],[\"marketplace\",{\"1\":{\"4\":1}}],[\"md文档将被添加二级目录\",{\"1\":{\"12\":1}}],[\"md将被作为主页\",{\"1\":{\"12\":1}}],[\"md和index\",{\"1\":{\"12\":1}}],[\"md\",{\"1\":{\"12\":1}}],[\"msbfirst\",{\"1\":{\"224\":1}}],[\"ms\",{\"1\":{\"9\":2,\"247\":2}}],[\"耗时\",{\"1\":{\"9\":1,\"247\":1}}],[\"擦除成功\",{\"1\":{\"9\":1,\"247\":1}}],[\"擦除flash中\",{\"1\":{\"9\":1,\"247\":1}}],[\"0表示无限次\",{\"1\":{\"228\":1}}],[\"02lu\",{\"1\":{\"214\":3}}],[\"0526\",{\"1\":{\"9\":1,\"247\":1}}],[\"00f\",{\"1\":{\"52\":1}}],[\"00\",{\"1\":{\"9\":1,\"247\":1}}],[\"0xc0\",{\"1\":{\"224\":1}}],[\"0x800000\",{\"1\":{\"224\":1}}],[\"0xf8\",{\"1\":{\"224\":1}}],[\"0xf81f\",{\"1\":{\"214\":1}}],[\"0xf800\",{\"1\":{\"214\":1}}],[\"0xffe0\",{\"1\":{\"214\":1}}],[\"0xffff\",{\"1\":{\"127\":4,\"214\":1}}],[\"0x3c\",{\"1\":{\"209\":1}}],[\"0x3b\",{\"1\":{\"194\":1}}],[\"0x2c\",{\"1\":{\"204\":1}}],[\"0x44\",{\"1\":{\"204\":1}}],[\"0x40\",{\"1\":{\"9\":1,\"247\":1}}],[\"0x1c\",{\"1\":{\"194\":1}}],[\"0x10000\",{\"1\":{\"127\":3}}],[\"0x6b\",{\"1\":{\"194\":1}}],[\"0xa4\",{\"1\":{\"123\":1}}],[\"0x52\",{\"1\":{\"123\":1}}],[\"0x55\",{\"1\":{\"89\":1}}],[\"0x71\",{\"1\":{\"97\":1}}],[\"0x07e0\",{\"1\":{\"214\":1}}],[\"0x07ff\",{\"1\":{\"214\":1}}],[\"0x001f\",{\"1\":{\"214\":1}}],[\"0x00000000\",{\"1\":{\"224\":1}}],[\"0x0000\",{\"1\":{\"214\":1}}],[\"0x06\",{\"1\":{\"204\":1}}],[\"0x08\",{\"1\":{\"194\":1}}],[\"0x08000000\",{\"1\":{\"9\":2,\"247\":2}}],[\"0x04\",{\"1\":{\"9\":1,\"247\":1}}],[\"0\",{\"1\":{\"9\":1,\"38\":1,\"45\":1,\"46\":2,\"47\":1,\"48\":1,\"49\":1,\"50\":2,\"51\":1,\"52\":2,\"53\":1,\"54\":1,\"55\":1,\"56\":3,\"70\":1,\"88\":2,\"89\":1,\"98\":3,\"106\":1,\"127\":6,\"155\":5,\"171\":1,\"177\":1,\"189\":3,\"190\":2,\"193\":1,\"194\":3,\"199\":2,\"203\":1,\"204\":3,\"213\":1,\"214\":7,\"219\":1,\"224\":15,\"247\":1,\"251\":1,\"252\":1}}],[\"4digital\",{\"1\":{\"219\":2}}],[\"45\",{\"1\":{\"204\":1}}],[\"456f\",{\"1\":{\"54\":1}}],[\"4g\",{\"1\":{\"194\":1}}],[\"48m\",{\"1\":{\"177\":1}}],[\"40°c至85°c的温度\",{\"1\":{\"170\":1}}],[\"4095\",{\"1\":{\"127\":1}}],[\"40k\",{\"1\":{\"63\":1}}],[\"4\",{\"1\":{\"9\":1,\"26\":1,\"96\":1,\"125\":2,\"127\":1,\"194\":2,\"204\":1,\"209\":1,\"213\":1,\"214\":1,\"219\":1,\"247\":1,\"251\":1,\"252\":1}}],[\"24\",{\"1\":{\"224\":1}}],[\"2=8mhz\",{\"1\":{\"224\":1}}],[\"20\",{\"1\":{\"224\":1}}],[\"200\",{\"1\":{\"190\":3}}],[\"20230612140452011\",{\"1\":{\"23\":1}}],[\"20230612140357459\",{\"1\":{\"23\":1}}],[\"20230612140840851\",{\"1\":{\"22\":1}}],[\"20230617205905523\",{\"1\":{\"22\":1}}],[\"20230609165202809\",{\"1\":{\"21\":1}}],[\"20230609164926761\",{\"1\":{\"21\":1}}],[\"20230609164900031\",{\"1\":{\"21\":1}}],[\"20230609164821984\",{\"1\":{\"21\":1}}],[\"20230609164252675\",{\"1\":{\"21\":1}}],[\"20230609164109637\",{\"1\":{\"21\":1}}],[\"27\",{\"1\":{\"178\":5}}],[\"274\",{\"1\":{\"9\":1,\"247\":1}}],[\"250\",{\"1\":{\"214\":1}}],[\"256\",{\"1\":{\"204\":2}}],[\"25℃\",{\"1\":{\"178\":2}}],[\"254\",{\"1\":{\"50\":1}}],[\"255\",{\"1\":{\"48\":1,\"50\":2,\"100\":1,\"106\":1,\"127\":1}}],[\"2\",{\"1\":{\"9\":1,\"16\":1,\"25\":1,\"96\":1,\"98\":1,\"123\":2,\"125\":1,\"127\":2,\"155\":1,\"157\":1,\"194\":1,\"209\":1,\"214\":1,\"219\":3,\"224\":3,\"247\":1,\"251\":1,\"252\":1}}],[\"比如9600\",{\"1\":{\"236\":1,\"248\":1,\"251\":1,\"252\":1}}],[\"比如进行了delay操作\",{\"1\":{\"184\":1}}],[\"比如在vcc与dq之间连接一颗4\",{\"1\":{\"176\":1}}],[\"比如我们这里举例的\",{\"1\":{\"147\":1}}],[\"比如下面这样\",{\"1\":{\"9\":1}}],[\"比较中断上附加用户回调\",{\"1\":{\"127\":1}}],[\"比较简单\",{\"1\":{\"5\":1}}],[\"freq\",{\"1\":{\"105\":2,\"126\":1,\"127\":1}}],[\"frequency\",{\"1\":{\"79\":2,\"105\":1,\"126\":3,\"127\":1}}],[\"from\",{\"1\":{\"52\":6,\"89\":1,\"96\":1,\"127\":1}}],[\"function\",{\"1\":{\"67\":1,\"94\":1,\"95\":1,\"96\":4,\"126\":7,\"127\":1,\"161\":2}}],[\"f\",{\"0\":{\"254\":1},\"1\":{\"52\":4,\"54\":3,\"209\":1}}],[\"fillscreen\",{\"1\":{\"214\":1}}],[\"field2\",{\"1\":{\"52\":2,\"54\":1}}],[\"field1\",{\"1\":{\"52\":2,\"54\":1}}],[\"first\",{\"1\":{\"50\":1,\"54\":1,\"56\":2,\"123\":1}}],[\"flush\",{\"0\":{\"136\":1},\"1\":{\"136\":1}}],[\"float\",{\"1\":{\"51\":1,\"52\":7,\"53\":1,\"54\":5,\"177\":1}}],[\"flash命令来执行烧录操作\",{\"1\":{\"247\":1}}],[\"flash命令有如下参数\",{\"1\":{\"242\":1,\"246\":1,\"248\":1}}],[\"flash\",{\"0\":{\"241\":1,\"242\":1,\"245\":1,\"246\":1,\"248\":1},\"1\":{\"9\":2,\"43\":2,\"241\":1,\"243\":2,\"244\":2,\"245\":1,\"247\":2,\"249\":1,\"251\":2,\"252\":1}}],[\"following\",{\"1\":{\"126\":1}}],[\"forever\",{\"1\":{\"161\":1}}],[\"forced\",{\"1\":{\"127\":4}}],[\"force\",{\"1\":{\"126\":1}}],[\"format\",{\"1\":{\"126\":18,\"127\":23}}],[\"for\",{\"1\":{\"48\":1,\"50\":2,\"52\":2,\"54\":3,\"96\":1,\"126\":2,\"127\":6,\"161\":2,\"194\":1,\"204\":1,\"224\":1}}],[\"fontawesome\",{\"1\":{\"13\":1}}],[\"failed\",{\"1\":{\"172\":1,\"209\":2}}],[\"factor\",{\"1\":{\"126\":1}}],[\"falling\",{\"1\":{\"67\":1,\"127\":3,\"184\":1}}],[\"false\",{\"1\":{\"9\":1,\"194\":1,\"249\":1}}],[\"faq\",{\"1\":{\"12\":1}}],[\"ws2812\",{\"0\":{\"221\":1},\"1\":{\"222\":2,\"223\":2,\"224\":6}}],[\"when\",{\"1\":{\"127\":6,\"161\":1}}],[\"whenever\",{\"1\":{\"96\":2}}],[\"white\",{\"1\":{\"209\":1,\"214\":1}}],[\"which\",{\"1\":{\"126\":7}}],[\"while\",{\"1\":{\"52\":1,\"54\":1,\"96\":1,\"126\":1,\"172\":1,\"209\":1,\"214\":1,\"224\":1}}],[\"was\",{\"1\":{\"126\":2}}],[\"want\",{\"1\":{\"54\":1}}],[\"wait\",{\"1\":{\"52\":1,\"54\":1,\"161\":2}}],[\"weak\",{\"1\":{\"98\":2,\"99\":1}}],[\"we\",{\"1\":{\"54\":1,\"127\":1}}],[\"width和screen\",{\"1\":{\"209\":1}}],[\"width\",{\"1\":{\"101\":1,\"209\":3}}],[\"wire总线\",{\"1\":{\"175\":1}}],[\"wire2\",{\"1\":{\"97\":5}}],[\"wire\",{\"1\":{\"73\":2,\"83\":7,\"89\":7,\"91\":4,\"96\":7,\"97\":1,\"194\":17,\"204\":10,\"209\":1}}],[\"without\",{\"1\":{\"127\":2}}],[\"with\",{\"1\":{\"52\":1,\"54\":2,\"96\":2,\"123\":3,\"126\":1,\"127\":5}}],[\"will\",{\"1\":{\"50\":1,\"126\":4,\"127\":2}}],[\"windows\",{\"1\":{\"30\":1}}],[\"windows下zip版本安装\",{\"0\":{\"22\":1}}],[\"windows下exe版本安装\",{\"0\":{\"21\":1}}],[\"windows系统下的ide有exe安装版和zip压缩包免安装版\",{\"1\":{\"20\":1}}],[\"written\",{\"1\":{\"54\":2}}],[\"writing\",{\"1\":{\"9\":1,\"247\":1}}],[\"write方法中传入的变量为绝对角度\",{\"1\":{\"199\":1}}],[\"write写入缓冲区后\",{\"1\":{\"87\":1}}],[\"write\",{\"0\":{\"47\":1,\"80\":1,\"135\":1,\"241\":1,\"242\":1,\"248\":1},\"1\":{\"9\":3,\"47\":1,\"48\":1,\"50\":3,\"56\":1,\"80\":2,\"83\":4,\"89\":1,\"96\":1,\"97\":1,\"135\":2,\"194\":5,\"199\":5,\"204\":2,\"242\":1,\"247\":2,\"248\":1,\"249\":1}}],[\"working\",{\"1\":{\"54\":1}}],[\"workflow\",{\"1\":{\"12\":1}}],[\"workspaceroot\",{\"1\":{\"7\":1}}],[\"world\",{\"1\":{\"6\":1,\"89\":1,\"138\":1}}],[\"获取芯片\",{\"1\":{\"238\":1,\"239\":1,\"240\":1}}],[\"获取芯片id\",{\"1\":{\"9\":1,\"249\":1}}],[\"获取7个数据\",{\"1\":{\"194\":1}}],[\"获取一下当前的gpio状态\",{\"1\":{\"184\":1}}],[\"获取到第一个设备的温度值\",{\"1\":{\"177\":1}}],[\"获取到的温度为\",{\"1\":{\"177\":1,\"178\":5}}],[\"获取完成\",{\"1\":{\"177\":1,\"178\":5}}],[\"获取当前气压\",{\"1\":{\"172\":1}}],[\"获取当前温度\",{\"1\":{\"172\":1}}],[\"获取用于半双工的\",{\"1\":{\"140\":1}}],[\"获取isp版本和芯片读保护状态\",{\"1\":{\"9\":1,\"249\":1}}],[\"获取isp版本和支持的命令列表\",{\"1\":{\"9\":1,\"249\":1}}],[\"最多\",{\"1\":{\"73\":1}}],[\"最大重试次数\",{\"1\":{\"9\":1,\"228\":1,\"249\":1}}],[\"最后我们在loop函数中\",{\"1\":{\"224\":1}}],[\"最后我们可以在我们在loop\",{\"1\":{\"184\":1}}],[\"最后在loop\",{\"1\":{\"214\":1,\"219\":1}}],[\"最后在loop函数中添加其余代码\",{\"1\":{\"194\":1}}],[\"最后加上loop函数\",{\"1\":{\"209\":1}}],[\"最后将当前的电平状态存入buttonstate\",{\"1\":{\"182\":1}}],[\"最后点击完成即可\",{\"1\":{\"21\":1}}],[\"最后\",{\"1\":{\"7\":1,\"182\":1}}],[\"ttyusb2\",{\"1\":{\"235\":1}}],[\"t用于存储当前的led灯颜色数据\",{\"1\":{\"224\":1}}],[\"tm1637led数码管驱动芯片\",{\"1\":{\"217\":1}}],[\"tm1637\",{\"0\":{\"216\":1},\"1\":{\"218\":1,\"219\":10}}],[\"text\",{\"1\":{\"214\":3}}],[\"tempc\",{\"1\":{\"177\":3}}],[\"temp\",{\"1\":{\"83\":1,\"89\":3,\"149\":1,\"167\":1}}],[\"tft\",{\"1\":{\"214\":22}}],[\"turn\",{\"1\":{\"161\":2}}],[\"tutorial\",{\"0\":{\"255\":1,\"256\":1},\"1\":{\"12\":2}}],[\"taken\",{\"1\":{\"126\":1}}],[\"target\",{\"1\":{\"7\":1}}],[\"txpin\",{\"1\":{\"139\":2}}],[\"tx=pa0\",{\"1\":{\"138\":1}}],[\"txrx\",{\"1\":{\"100\":1}}],[\"tx\",{\"1\":{\"100\":2,\"138\":6,\"140\":9,\"141\":2}}],[\"transmitter\",{\"1\":{\"129\":1}}],[\"transfers\",{\"1\":{\"123\":2}}],[\"transfer16\",{\"0\":{\"120\":1}}],[\"transfer\",{\"0\":{\"119\":1,\"121\":1,\"122\":1},\"1\":{\"123\":2,\"224\":2}}],[\"trace\",{\"0\":{\"227\":1},\"1\":{\"9\":1,\"249\":1}}],[\"true\",{\"1\":{\"76\":1,\"87\":3,\"88\":2,\"89\":2,\"93\":2,\"126\":2,\"194\":3,\"214\":1}}],[\"twowire\",{\"1\":{\"93\":1,\"97\":2}}],[\"two\",{\"1\":{\"73\":1}}],[\"twi\",{\"1\":{\"73\":1}}],[\"typedef\",{\"1\":{\"127\":1}}],[\"type\",{\"1\":{\"54\":2}}],[\"ticks\",{\"1\":{\"127\":2}}],[\"tick\",{\"1\":{\"126\":6,\"127\":4}}],[\"timing\",{\"1\":{\"127\":1}}],[\"tim3\",{\"1\":{\"127\":2}}],[\"tim\",{\"1\":{\"126\":4,\"127\":14}}],[\"tim7\",{\"1\":{\"125\":1}}],[\"tim6\",{\"1\":{\"125\":1}}],[\"timerhandledeinit\",{\"1\":{\"126\":1}}],[\"timercompareformat\",{\"1\":{\"126\":2}}],[\"timermodes\",{\"1\":{\"126\":3,\"127\":1}}],[\"timerformat\",{\"1\":{\"126\":4}}],[\"timer\",{\"1\":{\"126\":11,\"127\":22}}],[\"times\",{\"1\":{\"50\":1}}],[\"time\",{\"1\":{\"50\":1}}],[\"title\",{\"1\":{\"13\":1}}],[\"through\",{\"1\":{\"96\":1}}],[\"that\",{\"1\":{\"96\":2}}],[\"than\",{\"1\":{\"89\":1}}],[\"thecaptured\",{\"1\":{\"127\":1}}],[\"the\",{\"1\":{\"50\":3,\"52\":5,\"54\":6,\"89\":2,\"96\":3,\"123\":7,\"126\":3,\"127\":2,\"161\":7}}],[\"theme\",{\"1\":{\"11\":1,\"13\":1}}],[\"this\",{\"1\":{\"50\":1,\"52\":1,\"96\":2,\"127\":4,\"155\":1}}],[\"toggles\",{\"1\":{\"127\":1}}],[\"toggle\",{\"1\":{\"127\":2}}],[\"tone\",{\"1\":{\"125\":1,\"127\":2}}],[\"too\",{\"1\":{\"52\":1}}],[\"to\",{\"1\":{\"33\":1,\"50\":1,\"52\":5,\"54\":6,\"89\":1,\"123\":2,\"126\":7,\"127\":6,\"155\":2}}],[\"ts\",{\"1\":{\"12\":2}}],[\"t\",{\"0\":{\"115\":4,\"116\":1,\"117\":1,\"118\":1,\"119\":2,\"120\":3,\"121\":2,\"122\":1,\"227\":1},\"1\":{\"9\":1,\"35\":2,\"38\":1,\"39\":2,\"40\":1,\"41\":1,\"46\":1,\"62\":2,\"64\":2,\"65\":1,\"67\":3,\"68\":1,\"70\":1,\"77\":1,\"78\":1,\"79\":1,\"80\":5,\"85\":2,\"86\":1,\"87\":2,\"88\":13,\"89\":4,\"93\":1,\"94\":1,\"95\":1,\"103\":2,\"105\":1,\"124\":4,\"126\":48,\"127\":2,\"135\":5,\"139\":2,\"140\":4,\"141\":8,\"194\":7,\"214\":12,\"224\":10,\"249\":1}}],[\"<读取长度>\",{\"0\":{\"245\":1}}],[\"<固件文件>\",{\"0\":{\"241\":1,\"245\":1}}],[\"<芯片flash地址>\",{\"0\":{\"241\":1,\"245\":1}}],[\"<串口波特率>\",{\"0\":{\"236\":1}}],[\"<串口名称>\",{\"0\":{\"235\":1}}],[\"<目标芯片型号>\",{\"0\":{\"234\":1}}],[\"<default\",{\"0\":{\"229\":1,\"230\":1}}],[\"<dallastemperature\",{\"1\":{\"177\":1}}],[\"<次数>\",{\"0\":{\"228\":1}}],[\"<=\",{\"1\":{\"204\":1}}],[\"<servo\",{\"1\":{\"199\":1}}],[\"<spi\",{\"1\":{\"123\":1,\"209\":1,\"214\":1}}],[\"<<=\",{\"1\":{\"224\":1}}],[\"<<\",{\"1\":{\"194\":1,\"224\":2}}],[\"<onewire\",{\"1\":{\"177\":1}}],[\"<wire\",{\"1\":{\"83\":1,\"91\":1,\"96\":1,\"97\":1,\"204\":1,\"209\":1}}],[\"<\",{\"1\":{\"48\":1,\"50\":2,\"96\":1,\"127\":2,\"224\":1}}],[\"<eeprom\",{\"1\":{\"44\":1,\"46\":1,\"48\":1,\"50\":1,\"52\":1,\"54\":1,\"56\":1}}],[\"<>\",{\"1\":{\"18\":1}}],[\"<filename>\",{\"1\":{\"9\":1,\"249\":1}}],[\"<adafruit\",{\"1\":{\"172\":1,\"209\":2,\"214\":2}}],[\"<address>\",{\"1\":{\"9\":1,\"249\":1}}],[\"<after>\",{\"1\":{\"9\":1,\"249\":1}}],[\"<before>\",{\"1\":{\"9\":1,\"249\":1}}],[\"<baud>\",{\"1\":{\"9\":1,\"249\":1}}],[\"<connect\",{\"1\":{\"9\":1,\"249\":1}}],[\"<chip>\",{\"1\":{\"9\":1,\"249\":1}}],[\"<port>\",{\"1\":{\"9\":1,\"249\":1}}],[\">pause\",{\"1\":{\"127\":1}}],[\">resume\",{\"1\":{\"127\":3}}],[\">attachinterrupt\",{\"1\":{\"127\":4}}],[\">setpwm\",{\"1\":{\"127\":2}}],[\">setprescalefactor\",{\"1\":{\"127\":2}}],[\">setcapturecompare\",{\"1\":{\"127\":7}}],[\">setoverflow\",{\"1\":{\"127\":5}}],[\">setmode\",{\"1\":{\"127\":2}}],[\">\",{\"1\":{\"9\":2,\"20\":1,\"21\":1,\"22\":1,\"127\":1,\"224\":1,\"247\":1,\"249\":1,\"251\":1,\"252\":1}}],[\"规范应该是小写\",{\"1\":{\"9\":1,\"249\":1}}],[\"命令参数\",{\"0\":{\"242\":1,\"246\":1,\"248\":1}}],[\"命令行名称按\",{\"1\":{\"9\":1,\"249\":1}}],[\"命令安装最新版的\",{\"1\":{\"5\":1}}],[\"注意\",{\"1\":{\"53\":1,\"78\":1,\"124\":1,\"125\":1,\"139\":1,\"145\":1,\"176\":1,\"183\":1,\"199\":1,\"215\":1,\"219\":1,\"251\":1,\"252\":1}}],[\"注释和文档是否用清晰的英语或者中文编写\",{\"1\":{\"16\":1}}],[\"注\",{\"1\":{\"9\":1,\"21\":1,\"22\":1,\"33\":1,\"53\":1,\"59\":1,\"73\":1,\"83\":1,\"105\":1,\"118\":2,\"127\":10,\"249\":1}}],[\"及其衍生版可以安装\",{\"1\":{\"9\":1,\"249\":1}}],[\"快速开始\",{\"0\":{\"9\":1},\"1\":{\"12\":1}}],[\"烧录新固件时请务必加上\",{\"1\":{\"242\":1,\"248\":1}}],[\"烧录问题\",{\"0\":{\"150\":1}}],[\"烧录\",{\"1\":{\"8\":1,\"162\":1,\"165\":1}}],[\"烧录工具\",{\"0\":{\"8\":1},\"1\":{\"30\":1}}],[\"享受调试的乐趣吧\",{\"1\":{\"7\":1}}],[\"就可以开始调试了\",{\"1\":{\"7\":1}}],[\"左边的运行与调试图标\",{\"1\":{\"7\":1}}],[\"e擦除参数\",{\"1\":{\"242\":1,\"248\":1}}],[\"erase\",{\"1\":{\"242\":1,\"248\":1}}],[\"error\",{\"1\":{\"83\":1,\"89\":2,\"204\":2}}],[\"else\",{\"1\":{\"155\":1,\"177\":1,\"182\":1,\"184\":1,\"204\":1,\"224\":1}}],[\"elf\",{\"1\":{\"7\":2}}],[\"eng\",{\"0\":{\"232\":1}}],[\"enum\",{\"1\":{\"127\":2}}],[\"enablehalfduplexrx\",{\"1\":{\"140\":1}}],[\"enable\",{\"1\":{\"126\":1}}],[\"enables\",{\"1\":{\"123\":1}}],[\"enabled\",{\"1\":{\"98\":2,\"140\":1}}],[\"endtransaction\",{\"0\":{\"118\":1},\"1\":{\"118\":1}}],[\"endtransmission\",{\"0\":{\"87\":1},\"1\":{\"83\":4,\"87\":3,\"89\":2,\"97\":1,\"194\":3,\"204\":1}}],[\"endif\",{\"1\":{\"98\":2,\"126\":1,\"214\":1}}],[\"end\",{\"0\":{\"81\":1,\"132\":1},\"1\":{\"81\":2,\"118\":1,\"123\":1,\"132\":1}}],[\"event\",{\"1\":{\"96\":4,\"126\":5}}],[\"empty\",{\"1\":{\"52\":1,\"54\":1,\"56\":1,\"96\":1}}],[\"eeaddress\",{\"1\":{\"52\":5,\"54\":4}}],[\"eeprom\",{\"0\":{\"42\":1,\"55\":1},\"1\":{\"43\":3,\"45\":2,\"46\":1,\"47\":2,\"48\":1,\"49\":2,\"50\":3,\"51\":2,\"52\":9,\"53\":3,\"54\":4,\"55\":4,\"56\":5,\"57\":3,\"73\":1,\"112\":1}}],[\"eanalogreference\",{\"1\":{\"36\":1}}],[\"eabi\",{\"1\":{\"7\":1}}],[\"extra\",{\"1\":{\"100\":1}}],[\"extras\",{\"0\":{\"256\":1},\"1\":{\"12\":1}}],[\"expected\",{\"1\":{\"96\":1}}],[\"examples\",{\"1\":{\"127\":2}}],[\"example\",{\"1\":{\"13\":1,\"54\":1}}],[\"executes\",{\"1\":{\"96\":2}}],[\"exe即可运行\",{\"1\":{\"22\":1}}],[\"exe安装版需要按步骤安装\",{\"1\":{\"20\":1}}],[\"exe\",{\"1\":{\"9\":1,\"247\":1,\"249\":2,\"251\":1,\"252\":1}}],[\"e\",{\"1\":{\"9\":1,\"242\":1,\"247\":1,\"248\":1}}],[\"n++\",{\"1\":{\"224\":1}}],[\"num\",{\"1\":{\"141\":2}}],[\"number\",{\"1\":{\"7\":1}}],[\"null\",{\"1\":{\"127\":2}}],[\"nullptr\",{\"1\":{\"126\":4}}],[\"np\",{\"1\":{\"98\":2}}],[\"nc\",{\"1\":{\"98\":2,\"126\":1,\"141\":2}}],[\"nview\",{\"1\":{\"54\":1}}],[\"n\",{\"1\":{\"54\":1,\"89\":2,\"96\":1,\"138\":1,\"140\":2,\"155\":2,\"167\":4,\"194\":1,\"204\":1,\"224\":15}}],[\"native\",{\"1\":{\"54\":1}}],[\"nan\",{\"1\":{\"52\":1}}],[\"name\",{\"1\":{\"52\":2,\"54\":1}}],[\"net运行时\",{\"1\":{\"249\":1}}],[\"net6进行编写\",{\"1\":{\"8\":1}}],[\"newtimestring\",{\"1\":{\"214\":5}}],[\"new\",{\"1\":{\"127\":1}}],[\"next\",{\"1\":{\"52\":1,\"54\":1}}],[\"needed\",{\"1\":{\"52\":1,\"54\":1}}],[\"nightly\",{\"1\":{\"25\":1}}],[\"nop\",{\"1\":{\"224\":2}}],[\"nopull\",{\"1\":{\"98\":16}}],[\"no\",{\"1\":{\"127\":2,\"155\":1,\"242\":1,\"246\":1,\"248\":1}}],[\"nostretchmode\",{\"1\":{\"93\":2}}],[\"not\",{\"1\":{\"50\":1,\"52\":1,\"127\":1}}],[\"nodejs\",{\"1\":{\"12\":1}}],[\"none\",{\"1\":{\"7\":1}}],[\"属性的值为编译出来的\",{\"1\":{\"7\":1}}],[\"属性的值为\",{\"1\":{\"7\":1}}],[\"添加如下代码\",{\"1\":{\"167\":1,\"182\":1,\"184\":1,\"189\":1,\"209\":1}}],[\"添加代码\",{\"0\":{\"155\":1,\"161\":1}}],[\"添加\",{\"1\":{\"140\":1}}],[\"添加开发板地址\",{\"0\":{\"25\":1}}],[\"添加文档\",{\"1\":{\"15\":1}}],[\"添加功能\",{\"1\":{\"15\":1}}],[\"添加targetid属性\",{\"1\":{\"7\":1}}],[\"添加一个armtoolchainpath属性\",{\"1\":{\"7\":1}}],[\"然后将gpio设置为low\",{\"1\":{\"189\":1}}],[\"然后可以配置\",{\"1\":{\"127\":1}}],[\"然后就可以配置溢出\",{\"1\":{\"127\":1}}],[\"然后就可以配置prescalerfactor\",{\"1\":{\"127\":1}}],[\"然后就可以配置通道的模式\",{\"1\":{\"127\":1}}],[\"然后向我们寻求帮助\",{\"1\":{\"16\":1}}],[\"然后选择cortex\",{\"1\":{\"7\":1}}],[\"然后\",{\"1\":{\"7\":1,\"118\":1}}],[\"o\",{\"1\":{\"246\":1}}],[\"oldtimestring\",{\"1\":{\"214\":4}}],[\"oled显示高度\",{\"1\":{\"209\":1}}],[\"oled显示宽度\",{\"1\":{\"209\":1}}],[\"oled屏\",{\"0\":{\"206\":1}}],[\"oled\",{\"1\":{\"73\":1,\"209\":2}}],[\"occurs\",{\"1\":{\"127\":1}}],[\"ocmode\",{\"1\":{\"127\":8}}],[\"or\",{\"1\":{\"127\":3,\"161\":1}}],[\"order\",{\"1\":{\"13\":1}}],[\"obsolete\",{\"1\":{\"127\":1}}],[\"object\",{\"1\":{\"52\":2,\"54\":1}}],[\"overwrite或者\",{\"1\":{\"246\":1}}],[\"over\",{\"1\":{\"161\":2}}],[\"overflow\",{\"1\":{\"126\":2}}],[\"ovf\",{\"1\":{\"52\":1}}],[\"otherwise\",{\"1\":{\"127\":2}}],[\"other\",{\"1\":{\"123\":1}}],[\"od\",{\"1\":{\"98\":16}}],[\"off\",{\"1\":{\"161\":1}}],[\"of\",{\"1\":{\"96\":1,\"126\":5,\"127\":1}}],[\"open\",{\"1\":{\"62\":1}}],[\"opt\",{\"1\":{\"35\":1,\"100\":1,\"138\":3}}],[\"options\",{\"1\":{\"9\":2,\"126\":1,\"249\":2}}],[\"opt=osstd\",{\"1\":{\"7\":1}}],[\"onchange\",{\"1\":{\"184\":2}}],[\"once\",{\"1\":{\"155\":1,\"161\":1}}],[\"on\",{\"1\":{\"126\":8,\"127\":1,\"161\":1}}],[\"onrequest\",{\"0\":{\"95\":1},\"1\":{\"91\":3,\"95\":2,\"96\":1}}],[\"onreceive\",{\"0\":{\"94\":1},\"1\":{\"91\":3,\"94\":2,\"96\":1}}],[\"onewire\",{\"1\":{\"177\":3}}],[\"one\",{\"1\":{\"54\":1,\"126\":2,\"127\":1}}],[\"only\",{\"1\":{\"50\":1,\"52\":1,\"54\":1,\"126\":1,\"127\":1}}],[\"os\",{\"1\":{\"20\":1,\"159\":1}}],[\"output\",{\"1\":{\"6\":1,\"7\":1,\"60\":1,\"62\":2,\"64\":1,\"70\":1,\"71\":1,\"96\":1,\"126\":3,\"127\":12,\"155\":1,\"161\":2,\"184\":1,\"189\":3}}],[\"join\",{\"1\":{\"96\":1}}],[\"json\",{\"1\":{\"12\":1,\"25\":3}}],[\"json文件\",{\"1\":{\"7\":1}}],[\"json文件中\",{\"1\":{\"7\":1}}],[\"js\",{\"1\":{\"12\":2}}],[\"jlink\",{\"1\":{\"2\":1}}],[\"g\",{\"1\":{\"224\":3}}],[\"green\",{\"1\":{\"214\":1}}],[\"gfx\",{\"1\":{\"209\":4,\"214\":2}}],[\"gz\",{\"1\":{\"194\":4}}],[\"gy\",{\"1\":{\"194\":4}}],[\"gyroscalefactor\",{\"1\":{\"194\":4}}],[\"gx\",{\"1\":{\"194\":4}}],[\"gnd\",{\"1\":{\"166\":1,\"171\":2,\"176\":2,\"193\":2,\"198\":1,\"203\":2,\"208\":4,\"213\":2,\"218\":2,\"223\":2}}],[\"gcc编译器不支持使用中文路径\",{\"1\":{\"144\":1}}],[\"gcc套件的地址\",{\"1\":{\"7\":1}}],[\"generic\",{\"1\":{\"126\":2}}],[\"generate\",{\"1\":{\"126\":1}}],[\"generalcall\",{\"1\":{\"93\":2}}],[\"getdata\",{\"1\":{\"194\":2}}],[\"gettempcbyindex方法\",{\"1\":{\"177\":1}}],[\"gettempcbyindex\",{\"1\":{\"177\":1}}],[\"gettimerclkfreq\",{\"1\":{\"126\":1}}],[\"getting\",{\"1\":{\"12\":1,\"13\":1}}],[\"getassociatedchannel\",{\"1\":{\"126\":1}}],[\"getit\",{\"1\":{\"126\":1}}],[\"getllchannel\",{\"1\":{\"126\":1}}],[\"gethandle\",{\"1\":{\"126\":1}}],[\"getchannel\",{\"1\":{\"126\":1}}],[\"getcapturecompare\",{\"1\":{\"126\":1,\"127\":1}}],[\"getcount\",{\"1\":{\"126\":1,\"127\":1}}],[\"getmode\",{\"1\":{\"126\":1}}],[\"getoverflow\",{\"1\":{\"126\":1,\"127\":1}}],[\"getprescalefactor\",{\"1\":{\"126\":1,\"127\":1}}],[\"get\",{\"0\":{\"51\":1,\"239\":1,\"240\":1},\"1\":{\"9\":2,\"51\":1,\"52\":4,\"54\":1,\"249\":2}}],[\"guide\",{\"1\":{\"13\":1}}],[\"gpio代表通用输入输出\",{\"1\":{\"59\":1}}],[\"gpio\",{\"0\":{\"58\":1,\"60\":1,\"61\":1,\"70\":1,\"71\":1},\"1\":{\"9\":1,\"35\":1,\"39\":1,\"59\":4,\"60\":4,\"61\":1,\"63\":1,\"64\":1,\"66\":1,\"68\":1,\"98\":32,\"108\":1,\"181\":1,\"182\":2,\"184\":2,\"247\":1}}],[\"gbd\",{\"1\":{\"7\":1}}],[\"g的选项\",{\"1\":{\"6\":1}}],[\"git\",{\"1\":{\"5\":1,\"9\":1,\"17\":1,\"249\":1}}],[\"github\",{\"1\":{\"5\":1,\"12\":3,\"15\":1,\"17\":1,\"25\":1,\"32\":1}}],[\"git+https\",{\"1\":{\"5\":1}}],[\"切记\",{\"1\":{\"6\":1}}],[\"blue\",{\"1\":{\"214\":2}}],[\"blacktab\",{\"1\":{\"214\":1}}],[\"black\",{\"1\":{\"214\":2}}],[\"bl\",{\"1\":{\"213\":1}}],[\"blink\",{\"1\":{\"71\":2}}],[\"bmp\",{\"1\":{\"172\":5}}],[\"bmp085包\",{\"1\":{\"172\":1}}],[\"bmp085\",{\"1\":{\"172\":5}}],[\"bmp180可以测量300至1100\",{\"1\":{\"170\":1}}],[\"bmp180\",{\"0\":{\"169\":1},\"1\":{\"170\":2,\"171\":1}}],[\"bps\",{\"1\":{\"131\":1}}],[\"based\",{\"1\":{\"127\":1}}],[\"backround\",{\"1\":{\"214\":3}}],[\"back\",{\"1\":{\"127\":2}}],[\"baud\",{\"0\":{\"236\":1},\"1\":{\"9\":1,\"131\":3,\"249\":1}}],[\"by\",{\"1\":{\"96\":2,\"127\":1,\"161\":1}}],[\"byte\",{\"0\":{\"119\":1,\"122\":1},\"1\":{\"52\":2,\"54\":2,\"71\":1,\"96\":2,\"131\":1,\"194\":1}}],[\"bytesreceived\",{\"1\":{\"89\":6}}],[\"bytes\",{\"1\":{\"9\":1,\"89\":2,\"96\":1,\"247\":1}}],[\"builtin\",{\"1\":{\"148\":2,\"161\":4}}],[\"build\",{\"1\":{\"7\":2,\"35\":1,\"100\":1,\"138\":3}}],[\"but\",{\"1\":{\"96\":1,\"126\":1,\"127\":1}}],[\"buttonstate==state\",{\"1\":{\"182\":1}}],[\"buttonstate\",{\"1\":{\"182\":2}}],[\"button\",{\"1\":{\"70\":3,\"182\":3,\"184\":4,\"214\":1}}],[\"bus\",{\"1\":{\"96\":1,\"112\":1}}],[\"bufin\",{\"0\":{\"122\":1},\"1\":{\"122\":1}}],[\"bufout\",{\"0\":{\"122\":1},\"1\":{\"122\":1}}],[\"buffer\",{\"1\":{\"100\":1,\"135\":2}}],[\"buf\",{\"0\":{\"121\":1},\"1\":{\"89\":1,\"121\":1}}],[\"bits\",{\"1\":{\"38\":1,\"106\":2,\"224\":3}}],[\"between\",{\"1\":{\"127\":2}}],[\"been\",{\"1\":{\"126\":2}}],[\"be\",{\"1\":{\"52\":1,\"54\":1,\"126\":3,\"127\":3}}],[\"before\",{\"0\":{\"229\":1},\"1\":{\"9\":1,\"249\":1}}],[\"begin初始化屏幕设备\",{\"1\":{\"209\":1}}],[\"begintransaction\",{\"0\":{\"117\":1},\"1\":{\"118\":3,\"123\":1}}],[\"begintransmission\",{\"0\":{\"86\":1},\"1\":{\"83\":2,\"86\":1,\"87\":1,\"89\":1,\"97\":1,\"194\":3,\"204\":1}}],[\"begin\",{\"0\":{\"76\":1,\"85\":1,\"93\":1,\"116\":1,\"131\":1},\"1\":{\"6\":1,\"46\":1,\"52\":1,\"54\":1,\"76\":1,\"78\":1,\"81\":1,\"83\":4,\"85\":3,\"89\":2,\"91\":4,\"93\":2,\"96\":2,\"97\":1,\"118\":1,\"123\":1,\"124\":1,\"131\":2,\"138\":1,\"139\":1,\"140\":1,\"155\":1,\"167\":1,\"172\":2,\"177\":2,\"182\":1,\"184\":1,\"194\":2,\"204\":2,\"209\":2,\"214\":1,\"224\":1}}],[\"b\",{\"0\":{\"236\":1},\"1\":{\"9\":2,\"224\":3,\"247\":1,\"249\":1,\"251\":1,\"252\":1}}],[\"bothedge\",{\"1\":{\"127\":2}}],[\"both\",{\"1\":{\"126\":1}}],[\"boot0\",{\"1\":{\"229\":1}}],[\"boot\",{\"1\":{\"229\":3}}],[\"boot按键所属的\",{\"1\":{\"182\":1,\"184\":1}}],[\"boot按键可作为通用按键使用\",{\"1\":{\"181\":1}}],[\"bootconnection=defaule\",{\"1\":{\"7\":1}}],[\"bool\",{\"1\":{\"76\":1,\"85\":2,\"87\":1,\"89\":1,\"93\":2,\"126\":4}}],[\"boards最新版即可\",{\"1\":{\"159\":1}}],[\"board\",{\"1\":{\"6\":1,\"7\":1,\"154\":1,\"161\":1,\"167\":1}}],[\"175\",{\"1\":{\"204\":1}}],[\"180\",{\"1\":{\"199\":1}}],[\"14和pa\",{\"1\":{\"219\":1}}],[\"14\",{\"1\":{\"194\":1,\"219\":1}}],[\"14f\",{\"1\":{\"54\":1}}],[\"13\",{\"1\":{\"219\":2}}],[\"131\",{\"1\":{\"194\":1}}],[\"134219264\",{\"1\":{\"9\":1,\"247\":1}}],[\"19℃\",{\"1\":{\"178\":3}}],[\"11\",{\"1\":{\"98\":1}}],[\"115200\",{\"1\":{\"6\":1,\"9\":1,\"89\":1,\"138\":1,\"155\":1,\"167\":1,\"168\":1,\"214\":1,\"247\":1,\"251\":1,\"252\":1}}],[\"16m\",{\"1\":{\"224\":1}}],[\"16g可选\",{\"1\":{\"194\":1}}],[\"16384\",{\"1\":{\"194\":1}}],[\"16\",{\"1\":{\"89\":2,\"125\":1,\"194\":1,\"209\":2,\"224\":2}}],[\"12b\",{\"1\":{\"127\":1}}],[\"128\",{\"1\":{\"73\":1,\"209\":1}}],[\"123\",{\"1\":{\"54\":1}}],[\"12\",{\"1\":{\"50\":2,\"98\":1,\"167\":1}}],[\"1\",{\"1\":{\"16\":1,\"25\":1,\"46\":1,\"96\":1,\"98\":1,\"123\":2,\"125\":1,\"126\":1,\"127\":5,\"134\":1,\"137\":1,\"156\":1,\"171\":1,\"172\":1,\"184\":3,\"189\":3,\"190\":2,\"193\":1,\"194\":2,\"203\":1,\"204\":2,\"209\":1,\"213\":1,\"214\":1,\"219\":3,\"224\":8}}],[\"1536\",{\"1\":{\"9\":1,\"247\":1}}],[\"10°c至+85°c范围内测量精度为±0\",{\"1\":{\"175\":1}}],[\"10khz\",{\"1\":{\"127\":1}}],[\"1023\",{\"1\":{\"38\":1}}],[\"100\",{\"1\":{\"9\":1,\"161\":2,\"204\":1,\"214\":1,\"247\":1}}],[\"100000\",{\"1\":{\"127\":1}}],[\"10000\",{\"1\":{\"127\":7}}],[\"1000\",{\"1\":{\"6\":2,\"97\":1,\"105\":1,\"138\":1,\"155\":1,\"189\":4,\"199\":5,\"214\":1}}],[\"10\",{\"1\":{\"9\":1,\"21\":1,\"22\":1,\"38\":1,\"52\":1,\"54\":1,\"98\":2,\"127\":5,\"209\":1,\"224\":2,\"249\":1}}],[\"h软件包\",{\"1\":{\"219\":1}}],[\"h包\",{\"1\":{\"214\":1}}],[\"h包以及arduino自带的spi\",{\"1\":{\"214\":1}}],[\"humidity\",{\"1\":{\"204\":2}}],[\"hpa\",{\"1\":{\"170\":1}}],[\"hwserial2\",{\"1\":{\"138\":1}}],[\"hwserialx\",{\"1\":{\"138\":1}}],[\"htim\",{\"1\":{\"126\":2}}],[\"https\",{\"1\":{\"25\":2,\"28\":3}}],[\"hz\",{\"1\":{\"126\":2}}],[\"happy\",{\"1\":{\"209\":1}}],[\"handle\",{\"1\":{\"126\":1}}],[\"handletypedef\",{\"1\":{\"126\":3}}],[\"has\",{\"1\":{\"126\":2}}],[\"hasinterrupt\",{\"1\":{\"126\":2,\"127\":1}}],[\"half\",{\"1\":{\"140\":2}}],[\"halfduplex\",{\"1\":{\"140\":1}}],[\"halfduplexmode\",{\"1\":{\"140\":1}}],[\"hal\",{\"1\":{\"98\":2,\"100\":1,\"126\":1,\"127\":1}}],[\"hardwareserial\",{\"1\":{\"138\":2,\"140\":6,\"141\":4}}],[\"hardware\",{\"1\":{\"127\":1}}],[\"hardwaretimer\",{\"1\":{\"125\":1,\"127\":5}}],[\"hardwaretimer库旨在提供对部分airmcu硬件定时器功能的访问\",{\"1\":{\"125\":1}}],[\"hard\",{\"1\":{\"9\":1,\"249\":1}}],[\"hours\",{\"1\":{\"214\":2}}],[\"howmany\",{\"1\":{\"96\":1}}],[\"how\",{\"1\":{\"54\":1,\"127\":2}}],[\"hope\",{\"1\":{\"13\":1}}],[\"hope作为主题\",{\"1\":{\"11\":1}}],[\"h>\",{\"1\":{\"44\":1,\"46\":1,\"48\":1,\"50\":1,\"52\":1,\"54\":1,\"56\":1,\"83\":1,\"91\":1,\"96\":1,\"97\":1,\"123\":1,\"172\":1,\"177\":2,\"194\":1,\"199\":1,\"204\":1,\"209\":4,\"214\":3,\"224\":1}}],[\"height指定的宽度和高度\",{\"1\":{\"209\":1}}],[\"height\",{\"1\":{\"209\":3}}],[\"here\",{\"1\":{\"155\":2}}],[\"hertz\",{\"1\":{\"127\":6}}],[\"hex\",{\"1\":{\"9\":1,\"247\":1}}],[\"help\",{\"1\":{\"9\":2,\"249\":2}}],[\"hello\",{\"1\":{\"6\":1,\"89\":1,\"96\":1,\"138\":1,\"155\":1}}],[\"h\",{\"1\":{\"9\":2,\"35\":1,\"83\":1,\"89\":1,\"91\":1,\"100\":2,\"138\":4,\"214\":1,\"219\":1,\"249\":2}}],[\"hclk48m\",{\"1\":{\"7\":1}}],[\"high\",{\"1\":{\"6\":1,\"64\":2,\"65\":1,\"67\":1,\"127\":4,\"155\":1,\"161\":2,\"184\":1,\"189\":3,\"190\":3}}],[\"lang环境变量为1时\",{\"1\":{\"232\":1}}],[\"lang\",{\"0\":{\"232\":1}}],[\"last\",{\"0\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1},\"1\":{\"96\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"127\":1}}],[\"lu\",{\"1\":{\"214\":1}}],[\"luatos\",{\"1\":{\"25\":1}}],[\"lcd彩屏\",{\"0\":{\"211\":1}}],[\"lsb\",{\"1\":{\"194\":1}}],[\"ld\",{\"1\":{\"143\":1}}],[\"lpuart1\",{\"1\":{\"138\":1}}],[\"ll访问它们\",{\"1\":{\"125\":1}}],[\"level\",{\"1\":{\"161\":1}}],[\"len\",{\"1\":{\"80\":2}}],[\"length\",{\"0\":{\"57\":1},\"1\":{\"57\":1}}],[\"led灯的个数\",{\"1\":{\"224\":1}}],[\"ledpin\",{\"1\":{\"70\":3,\"71\":3}}],[\"led\",{\"1\":{\"59\":1,\"60\":1,\"161\":6,\"185\":1,\"222\":3,\"224\":19}}],[\"leonardo\",{\"1\":{\"52\":1}}],[\"leaving\",{\"1\":{\"9\":1,\"247\":1,\"251\":1,\"252\":1}}],[\"lgpl\",{\"1\":{\"16\":1}}],[\"libraries\",{\"1\":{\"148\":4}}],[\"library包\",{\"1\":{\"214\":1}}],[\"library库和adafruit\",{\"1\":{\"209\":1}}],[\"library库与adafruit\",{\"1\":{\"209\":1}}],[\"library库\",{\"1\":{\"172\":2,\"177\":1}}],[\"library\",{\"1\":{\"12\":1,\"172\":1,\"177\":1,\"209\":1,\"214\":1}}],[\"linux\",{\"1\":{\"9\":2,\"30\":1,\"249\":2}}],[\"link\",{\"1\":{\"2\":1}}],[\"local\",{\"1\":{\"147\":1,\"148\":4}}],[\"location\",{\"1\":{\"54\":1}}],[\"long\",{\"1\":{\"131\":2,\"214\":4,\"224\":4}}],[\"log\",{\"1\":{\"89\":1}}],[\"logs\",{\"1\":{\"6\":1}}],[\"lowspeedclocksource=none\",{\"1\":{\"7\":1}}],[\"low\",{\"1\":{\"6\":1,\"64\":2,\"65\":1,\"67\":1,\"71\":1,\"127\":4,\"155\":1,\"161\":2,\"182\":2,\"184\":3,\"189\":3,\"190\":3,\"224\":1}}],[\"loop\",{\"1\":{\"6\":1,\"46\":1,\"48\":1,\"50\":1,\"52\":2,\"54\":2,\"56\":2,\"70\":1,\"71\":1,\"89\":1,\"96\":3,\"97\":1,\"138\":1,\"155\":1,\"161\":2,\"167\":1,\"172\":1,\"177\":1,\"182\":1,\"184\":3,\"189\":1,\"190\":1,\"194\":1,\"199\":1,\"204\":1,\"209\":1,\"214\":1,\"219\":1,\"224\":1}}],[\"我们就可以简单测试工具了\",{\"1\":{\"233\":1}}],[\"我们初始化一下spi\",{\"1\":{\"224\":1}}],[\"我们将参考此处的代码\",{\"1\":{\"224\":1}}],[\"我们将使用\",{\"1\":{\"223\":1}}],[\"我们将c\",{\"1\":{\"148\":1}}],[\"我们用init方法初始化tm1637\",{\"1\":{\"219\":1}}],[\"我们用cosnt定义颜色并防止其被更改\",{\"1\":{\"214\":1}}],[\"我们只需要使用arduino自带的wire库\",{\"1\":{\"194\":1}}],[\"我们只取第一个传感器的温度信息\",{\"1\":{\"177\":1}}],[\"我们加一个闪灯的功能代码\",{\"1\":{\"184\":1}}],[\"我们使用pinmode函数初始化pb1\",{\"1\":{\"184\":1,\"189\":1}}],[\"我们会发现\",{\"1\":{\"184\":1}}],[\"我们打印一下当前按钮的电平状态\",{\"1\":{\"182\":1}}],[\"我们首先获取这一次的按键电平状态\",{\"1\":{\"182\":1}}],[\"我们在代码开头\",{\"1\":{\"224\":1}}],[\"我们在setup\",{\"1\":{\"214\":1}}],[\"我们在这段代码中\",{\"1\":{\"189\":1}}],[\"我们在loop\",{\"1\":{\"182\":1,\"189\":1}}],[\"我们在此仅介绍一些常用的\",{\"1\":{\"130\":1}}],[\"我们下面将默认你的新文件夹路径为d\",{\"1\":{\"146\":1}}],[\"我们一般把uart称为serial\",{\"1\":{\"130\":1}}],[\"我们为用户提供了\",{\"1\":{\"114\":1}}],[\"我们必须创建两个回调函数来处理与主设备的通信\",{\"1\":{\"91\":1}}],[\"我们可以前往github\",{\"1\":{\"249\":1}}],[\"我们可以得知ws2812需要严格的时序\",{\"1\":{\"224\":1}}],[\"我们可以将loop\",{\"1\":{\"190\":1}}],[\"我们可以看到开发板上的\",{\"1\":{\"185\":1}}],[\"我们可以使用read\",{\"1\":{\"251\":1,\"252\":1}}],[\"我们可以使用write\",{\"1\":{\"247\":1}}],[\"我们可以使用gpio\",{\"1\":{\"184\":1}}],[\"我们可以使用该工具为芯片进行烧录\",{\"1\":{\"9\":1}}],[\"我们可以通过使用设备地址调用\",{\"1\":{\"91\":1}}],[\"我们可以通过调用\",{\"1\":{\"83\":2}}],[\"我们采用内置\",{\"1\":{\"43\":1}}],[\"我们还提供常见问题指南\",{\"1\":{\"32\":1}}],[\"我们通过\",{\"1\":{\"15\":1}}],[\"我们欢迎为\",{\"1\":{\"14\":1}}],[\"我们欢迎任何关于文档的新贡献\",{\"1\":{\"10\":1}}],[\"我们也可以把图片放在相应文档目录下的img文件夹下\",{\"1\":{\"13\":1}}],[\"我们应当把图片或者静态资源放在\",{\"1\":{\"13\":1}}],[\"我们点击\",{\"1\":{\"7\":1}}],[\"我们点击上方的upload按钮\",{\"1\":{\"7\":1}}],[\"我们这里设置为setup\",{\"1\":{\"7\":1}}],[\"我们这里使用$\",{\"1\":{\"7\":1}}],[\"我们这里使用air001\",{\"1\":{\"7\":1}}],[\"我们这里可以直接使用\",{\"1\":{\"7\":1}}],[\"我们这里就修改为air001debugtest\",{\"1\":{\"6\":1}}],[\"我们需要将芯片的主频设置为\",{\"1\":{\"224\":1}}],[\"我们需要将芯片主频设置为最高的\",{\"1\":{\"177\":1}}],[\"我们需要使用grove\",{\"1\":{\"219\":1}}],[\"我们需要修改其中的serverpath属性为pyocd\",{\"1\":{\"7\":1}}],[\"我们需要配置调试器\",{\"1\":{\"7\":1}}],[\"我们需要添加一个属性output\",{\"1\":{\"7\":1}}],[\"我们选择如下的配置\",{\"1\":{\"6\":1}}],[\"我们随便写一些测试代码\",{\"1\":{\"6\":1}}],[\"这片宏定义区域生效\",{\"1\":{\"214\":1}}],[\"这将使用您的变体的\",{\"1\":{\"138\":1}}],[\"这将使用变体的\",{\"1\":{\"138\":1}}],[\"这就是为什么在可用时\",{\"1\":{\"125\":1}}],[\"这些api必须在\",{\"1\":{\"139\":1}}],[\"这些\",{\"1\":{\"124\":1}}],[\"这些新参数保存在关联的\",{\"1\":{\"117\":1}}],[\"这些功能仅用于主模式\",{\"1\":{\"84\":1}}],[\"这个函数传入\",{\"1\":{\"224\":1}}],[\"这个数据传输帧可以用于读与写两种操作\",{\"1\":{\"112\":1}}],[\"这个文件名必须和父目录的名字一样\",{\"1\":{\"6\":1}}],[\"这种接口首先由摩托罗拉公司于20世纪80年代中期开发\",{\"1\":{\"112\":1}}],[\"这种串行通信被视为低速总线\",{\"1\":{\"73\":1}}],[\"这两根线称为sda\",{\"1\":{\"73\":1}}],[\"这是就需要去除读保护\",{\"1\":{\"251\":1}}],[\"这是使用\",{\"1\":{\"123\":1}}],[\"这是为了与其他不同线制的数据传输接口加以区分\",{\"1\":{\"112\":1}}],[\"这是用于连接传感器\",{\"1\":{\"73\":1}}],[\"这是一个开放项目\",{\"1\":{\"31\":1}}],[\"这可以避免在\",{\"1\":{\"32\":1}}],[\"这样只要设置\",{\"1\":{\"224\":1}}],[\"这样\",{\"1\":{\"7\":1}}],[\"这样才能获得编译出来的文件\",{\"1\":{\"7\":1}}],[\"这样才能生成调试符号\",{\"1\":{\"6\":1}}],[\"这里需要让spi处于8mhz\",{\"1\":{\"224\":1}}],[\"这里的重点是spi\",{\"1\":{\"224\":1}}],[\"这里的led\",{\"1\":{\"224\":1}}],[\"这里的颜色格式为rgb565\",{\"1\":{\"214\":1}}],[\"这里的gpio\",{\"1\":{\"184\":1}}],[\"这里使用了三元运算符\",{\"1\":{\"182\":1}}],[\"这里输入文件名\",{\"1\":{\"6\":1}}],[\"这里我们以新建工程为例\",{\"1\":{\"6\":1}}],[\"这里我们使用\",{\"1\":{\"2\":1}}],[\"uif\",{\"1\":{\"127\":2}}],[\"uint16\",{\"0\":{\"120\":2},\"1\":{\"194\":2,\"214\":10}}],[\"uint8\",{\"0\":{\"115\":4,\"116\":1,\"117\":1,\"118\":1,\"119\":2,\"120\":1,\"121\":1},\"1\":{\"38\":1,\"70\":1,\"80\":2,\"86\":1,\"87\":2,\"88\":12,\"89\":3,\"93\":1,\"135\":2,\"214\":1}}],[\"uint32\",{\"1\":{\"35\":2,\"39\":2,\"40\":1,\"41\":1,\"62\":2,\"64\":2,\"65\":1,\"67\":2,\"68\":1,\"77\":1,\"78\":1,\"79\":1,\"85\":2,\"88\":1,\"89\":1,\"103\":2,\"105\":1,\"124\":4,\"126\":33,\"139\":2,\"140\":3,\"141\":8}}],[\"uart4\",{\"1\":{\"138\":1}}],[\"uart\",{\"0\":{\"128\":1,\"130\":1},\"1\":{\"108\":1,\"129\":1,\"138\":2,\"173\":1}}],[\"unsigned\",{\"1\":{\"56\":1,\"131\":2,\"204\":1,\"214\":4,\"224\":10}}],[\"unprotect命令来关闭\",{\"1\":{\"251\":1}}],[\"unprotect\",{\"0\":{\"243\":1},\"1\":{\"9\":1,\"249\":1,\"251\":1}}],[\"usartx\",{\"1\":{\"138\":1}}],[\"usart3\",{\"1\":{\"138\":1}}],[\"usart2\",{\"1\":{\"138\":1}}],[\"usart1\",{\"1\":{\"138\":1}}],[\"usage\",{\"1\":{\"9\":2,\"249\":2}}],[\"useful\",{\"1\":{\"127\":2}}],[\"usefull\",{\"1\":{\"126\":1}}],[\"username\",{\"1\":{\"147\":1,\"148\":1}}],[\"users\",{\"1\":{\"147\":1,\"148\":7}}],[\"userdefined\",{\"1\":{\"127\":2}}],[\"user\",{\"1\":{\"126\":2,\"148\":2}}],[\"use\",{\"1\":{\"54\":1,\"127\":3}}],[\"used\",{\"1\":{\"52\":1,\"127\":5}}],[\"usb\",{\"1\":{\"54\":1,\"108\":1,\"162\":2,\"183\":2,\"223\":1}}],[\"upseconds\",{\"1\":{\"214\":11}}],[\"up\",{\"1\":{\"182\":1,\"183\":5,\"184\":1}}],[\"upon\",{\"1\":{\"126\":2}}],[\"updatecallback\",{\"1\":{\"126\":1}}],[\"update\",{\"0\":{\"49\":1},\"1\":{\"49\":1,\"50\":2,\"53\":1,\"126\":6,\"127\":2}}],[\"uploadspeed=115200\",{\"1\":{\"7\":1}}],[\"ulvalue\",{\"1\":{\"103\":2}}],[\"ulval\",{\"1\":{\"64\":2}}],[\"ulpin\",{\"1\":{\"39\":2,\"62\":2,\"64\":2,\"65\":2,\"103\":2}}],[\"ulmode\",{\"1\":{\"36\":1,\"62\":2}}],[\"uration\",{\"1\":{\"7\":1}}],[\"u\",{\"1\":{\"5\":1,\"89\":3,\"138\":2,\"140\":5}}],[\"io\",{\"1\":{\"222\":1}}],[\"i²c接口的oled屏幕\",{\"1\":{\"208\":1}}],[\"i²c停止\",{\"1\":{\"204\":1}}],[\"i²c通信从机地址为0x44\",{\"1\":{\"204\":1}}],[\"i²c的scl与sda需要有上拉电阻\",{\"1\":{\"203\":1}}],[\"i<7\",{\"1\":{\"194\":1}}],[\"i=0\",{\"1\":{\"194\":1}}],[\"ied\",{\"1\":{\"145\":1,\"149\":2}}],[\"it\",{\"1\":{\"127\":6}}],[\"its\",{\"1\":{\"127\":1}}],[\"item\",{\"1\":{\"127\":1}}],[\"itemname=marus25\",{\"1\":{\"4\":1}}],[\"items\",{\"1\":{\"4\":1}}],[\"iaddress\",{\"1\":{\"88\":4}}],[\"i2c缓冲区中存储的数据将被传输到从设备\",{\"1\":{\"83\":1}}],[\"i2c\",{\"0\":{\"72\":1,\"74\":1,\"75\":1,\"82\":1,\"84\":1,\"90\":1,\"92\":1,\"98\":1,\"100\":1},\"1\":{\"73\":2,\"74\":1,\"79\":2,\"81\":1,\"83\":3,\"84\":1,\"86\":1,\"89\":4,\"91\":2,\"96\":4,\"97\":1,\"98\":37,\"100\":4,\"108\":1}}],[\"i++\",{\"1\":{\"48\":1,\"50\":2,\"89\":1,\"194\":1,\"204\":1}}],[\"i\",{\"1\":{\"48\":4,\"50\":8,\"89\":1,\"194\":1,\"204\":3,\"219\":1}}],[\"ifdef\",{\"1\":{\"98\":2}}],[\"if\",{\"1\":{\"46\":1,\"52\":1,\"56\":1,\"70\":1,\"89\":2,\"126\":4,\"155\":1,\"172\":1,\"177\":1,\"182\":2,\"184\":1,\"204\":1,\"209\":1,\"214\":2,\"224\":1}}],[\"image\",{\"1\":{\"21\":6,\"22\":2,\"23\":2}}],[\"img\",{\"1\":{\"13\":1}}],[\"icon\",{\"1\":{\"13\":3}}],[\"isp\",{\"1\":{\"229\":1,\"239\":1,\"240\":1,\"252\":1}}],[\"iscomplementarychannel\",{\"1\":{\"126\":1}}],[\"isize\",{\"1\":{\"88\":4}}],[\"issue\",{\"1\":{\"32\":1}}],[\"is\",{\"1\":{\"9\":1,\"52\":1,\"54\":1,\"96\":4,\"123\":2,\"126\":5,\"127\":7,\"155\":1,\"161\":1,\"167\":4,\"247\":1}}],[\"ide上方菜单的项目选项\",{\"1\":{\"219\":1}}],[\"ide中\",{\"1\":{\"219\":2}}],[\"ide左上角的文件\",{\"1\":{\"25\":1}}],[\"ide将自动重启\",{\"1\":{\"23\":1}}],[\"ide支持windows\",{\"1\":{\"20\":1}}],[\"ide\",{\"0\":{\"20\":1},\"1\":{\"22\":1,\"167\":1,\"189\":1,\"229\":1}}],[\"id\",{\"0\":{\"238\":1},\"1\":{\"9\":1,\"238\":1,\"249\":1}}],[\"init\",{\"1\":{\"219\":1}}],[\"initr\",{\"1\":{\"214\":2}}],[\"initial\",{\"1\":{\"172\":1}}],[\"initialize\",{\"1\":{\"6\":1,\"161\":1}}],[\"inactive\",{\"1\":{\"127\":4}}],[\"including\",{\"1\":{\"126\":1}}],[\"include<spi\",{\"1\":{\"224\":1}}],[\"include<wire\",{\"1\":{\"194\":1}}],[\"include调用下载的tm1637\",{\"1\":{\"219\":1}}],[\"include调用servo包\",{\"1\":{\"199\":1}}],[\"include\",{\"1\":{\"44\":1,\"46\":1,\"48\":1,\"50\":1,\"52\":1,\"54\":1,\"56\":1,\"83\":1,\"89\":1,\"91\":1,\"96\":1,\"97\":1,\"123\":1,\"172\":1,\"177\":2,\"199\":1,\"204\":1,\"209\":4,\"214\":3,\"219\":1}}],[\"inputcapture\",{\"1\":{\"127\":1}}],[\"inputchannelpolarity\",{\"1\":{\"127\":5}}],[\"input\",{\"1\":{\"60\":1,\"62\":4,\"63\":1,\"65\":1,\"70\":1,\"71\":1,\"127\":6,\"182\":1,\"184\":1}}],[\"instead\",{\"1\":{\"127\":1}}],[\"instance\",{\"1\":{\"123\":4,\"127\":1}}],[\"install\",{\"1\":{\"5\":1}}],[\"inside\",{\"1\":{\"52\":1}}],[\"int16\",{\"1\":{\"194\":1}}],[\"int引脚不用连接\",{\"1\":{\"193\":1}}],[\"into\",{\"1\":{\"126\":1}}],[\"integer\",{\"1\":{\"96\":2}}],[\"integrated\",{\"1\":{\"73\":1}}],[\"interrup\",{\"1\":{\"126\":1}}],[\"interrupt\",{\"1\":{\"126\":10,\"127\":1}}],[\"interruptpin\",{\"1\":{\"71\":3}}],[\"interrupts\",{\"0\":{\"66\":1}}],[\"interface\",{\"1\":{\"73\":1,\"112\":1}}],[\"inter\",{\"1\":{\"73\":1}}],[\"internal\",{\"1\":{\"35\":1}}],[\"int\",{\"1\":{\"46\":2,\"48\":1,\"50\":2,\"52\":1,\"54\":1,\"57\":1,\"65\":1,\"96\":2,\"106\":1,\"126\":4,\"133\":1,\"134\":1,\"137\":1,\"155\":1,\"182\":2,\"194\":1,\"204\":3,\"219\":1,\"224\":2}}],[\"index\",{\"1\":{\"25\":2}}],[\"in\",{\"1\":{\"9\":1,\"54\":1,\"126\":4,\"127\":4,\"247\":1}}],[\"information\",{\"1\":{\"9\":2,\"249\":2}}],[\"ino\",{\"1\":{\"6\":1,\"7\":2,\"138\":1}}],[\"peek\",{\"0\":{\"137\":1},\"1\":{\"137\":1}}],[\"percent\",{\"1\":{\"127\":1}}],[\"percentage\",{\"1\":{\"126\":1}}],[\"period\",{\"1\":{\"126\":1}}],[\"periodcallback\",{\"1\":{\"126\":2}}],[\"peripheral\",{\"1\":{\"112\":1,\"127\":1,\"140\":1}}],[\"peripheralpins\",{\"1\":{\"98\":2,\"99\":1,\"138\":2,\"140\":1}}],[\"performs\",{\"1\":{\"50\":1}}],[\"pc10\",{\"1\":{\"123\":1}}],[\"pc11\",{\"1\":{\"123\":1}}],[\"pc12\",{\"1\":{\"123\":1}}],[\"pwm2\",{\"1\":{\"127\":2}}],[\"pwm1\",{\"1\":{\"127\":4}}],[\"pwm\",{\"0\":{\"101\":1,\"102\":1},\"1\":{\"101\":1,\"103\":2,\"105\":1,\"108\":1,\"127\":2,\"198\":1}}],[\"pf00\",{\"1\":{\"208\":1}}],[\"pf01\",{\"1\":{\"208\":1}}],[\"pf\",{\"1\":{\"98\":2,\"171\":2,\"193\":2,\"194\":2,\"203\":2,\"204\":2}}],[\"pf4\",{\"1\":{\"70\":1,\"71\":1}}],[\"pb\",{\"1\":{\"98\":4,\"155\":3,\"182\":1,\"184\":4,\"189\":9,\"190\":6,\"199\":1,\"213\":2,\"214\":2}}],[\"pb0和pb3这三个gpio\",{\"1\":{\"189\":1}}],[\"pb0和pb3三个gpio控制\",{\"1\":{\"188\":1}}],[\"pb0\",{\"1\":{\"6\":3,\"70\":1,\"71\":1}}],[\"point\",{\"1\":{\"219\":1}}],[\"power\",{\"1\":{\"161\":1}}],[\"position\",{\"1\":{\"52\":1}}],[\"port\",{\"0\":{\"235\":1},\"1\":{\"9\":1,\"52\":1,\"54\":2,\"249\":1}}],[\"put\",{\"0\":{\"53\":1},\"1\":{\"53\":1,\"54\":4,\"155\":2}}],[\"pulldown下拉输入模式\",{\"1\":{\"182\":1}}],[\"pulldown\",{\"1\":{\"62\":1,\"71\":1,\"182\":1,\"184\":1}}],[\"pullup\",{\"1\":{\"62\":1,\"70\":1}}],[\"pull\",{\"1\":{\"15\":1}}],[\"public下\",{\"1\":{\"13\":1}}],[\"public\",{\"1\":{\"12\":1}}],[\"pa0\",{\"1\":{\"138\":2,\"166\":1,\"167\":2}}],[\"pa13\",{\"1\":{\"218\":1}}],[\"pa14\",{\"1\":{\"218\":1}}],[\"pa1\",{\"1\":{\"138\":2,\"166\":1,\"167\":2}}],[\"parameter\",{\"1\":{\"127\":2}}],[\"part\",{\"1\":{\"7\":1}}],[\"pair\",{\"1\":{\"127\":1}}],[\"pausechannel\",{\"1\":{\"126\":1}}],[\"pause\",{\"1\":{\"126\":2}}],[\"pa\",{\"1\":{\"98\":10,\"172\":1,\"176\":1,\"177\":1,\"213\":4,\"214\":4,\"219\":2,\"223\":2}}],[\"page\",{\"1\":{\"43\":1}}],[\"pack\",{\"1\":{\"25\":1,\"146\":2,\"148\":3}}],[\"package\",{\"1\":{\"12\":1,\"25\":2}}],[\"p\",{\"0\":{\"235\":1},\"1\":{\"9\":2,\"242\":1,\"246\":1,\"247\":1,\"248\":1,\"249\":1,\"251\":1,\"252\":1}}],[\"priority\",{\"1\":{\"126\":1}}],[\"printf\",{\"1\":{\"89\":3,\"155\":2,\"167\":4,\"204\":2}}],[\"print\",{\"1\":{\"46\":3,\"52\":2,\"54\":1,\"89\":1,\"96\":3,\"155\":1,\"172\":6,\"177\":3,\"194\":21,\"214\":2}}],[\"println\",{\"1\":{\"6\":1,\"46\":1,\"52\":5,\"54\":1,\"96\":1,\"138\":1,\"172\":5,\"177\":4,\"182\":2,\"184\":2,\"204\":1,\"209\":2,\"214\":1}}],[\"progress或者\",{\"1\":{\"242\":1,\"246\":1,\"248\":1}}],[\"provided\",{\"1\":{\"126\":6,\"127\":1}}],[\"protect命令来开启\",{\"1\":{\"252\":1}}],[\"protect\",{\"0\":{\"244\":1},\"1\":{\"9\":1,\"249\":1,\"252\":1}}],[\"pr\",{\"0\":{\"17\":1},\"1\":{\"15\":1,\"16\":1,\"17\":1}}],[\"preemptpriority\",{\"1\":{\"126\":1}}],[\"preload\",{\"1\":{\"126\":1}}],[\"prescaler\",{\"1\":{\"126\":3,\"127\":1}}],[\"pressed\",{\"1\":{\"182\":1,\"183\":5,\"184\":1}}],[\"press\",{\"1\":{\"13\":1,\"161\":1}}],[\"preference\",{\"1\":{\"23\":1}}],[\"pre\",{\"1\":{\"5\":1}}],[\"pi\",{\"1\":{\"160\":1}}],[\"pico\",{\"0\":{\"158\":1},\"1\":{\"160\":1}}],[\"pins\",{\"1\":{\"141\":2}}],[\"pinmap\",{\"1\":{\"98\":4,\"138\":2}}],[\"pinmode\",{\"0\":{\"62\":1},\"1\":{\"6\":1,\"62\":2,\"64\":1,\"70\":2,\"71\":2,\"155\":1,\"161\":1,\"182\":1,\"184\":2,\"189\":3}}],[\"pinname\",{\"1\":{\"77\":1,\"78\":1,\"124\":4,\"126\":2,\"139\":2,\"140\":3,\"141\":8}}],[\"pin\",{\"0\":{\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1},\"1\":{\"35\":2,\"67\":2,\"77\":2,\"78\":2,\"97\":2,\"98\":16,\"99\":1,\"114\":2,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"123\":2,\"126\":5,\"127\":12,\"138\":4,\"161\":1,\"214\":1}}],[\"pid\",{\"1\":{\"9\":1,\"247\":1}}],[\"pip\",{\"1\":{\"5\":1}}],[\"py\",{\"1\":{\"140\":2}}],[\"pyn\",{\"1\":{\"140\":2}}],[\"python\",{\"1\":{\"5\":1}}],[\"pyocd\",{\"0\":{\"5\":1},\"1\":{\"5\":3,\"7\":1}}],[\"aiisp工具内置了\",{\"1\":{\"249\":1}}],[\"air401\",{\"1\":{\"28\":2,\"108\":1,\"110\":1}}],[\"air32\",{\"1\":{\"28\":1}}],[\"air32f103\",{\"1\":{\"28\":1,\"108\":1,\"110\":1,\"234\":1}}],[\"air\",{\"1\":{\"25\":3,\"31\":1,\"98\":32,\"99\":1}}],[\"air001开发板一块\",{\"1\":{\"181\":1,\"198\":1,\"208\":1}}],[\"air001开发板入门\",{\"0\":{\"153\":1},\"1\":{\"171\":1,\"176\":1,\"188\":1,\"193\":1,\"198\":1,\"203\":1,\"208\":1,\"213\":1,\"218\":1,\"223\":1}}],[\"air001\",{\"1\":{\"9\":2,\"28\":2,\"98\":1,\"108\":1,\"110\":1,\"154\":1,\"155\":1,\"165\":1,\"166\":3,\"167\":1,\"171\":1,\"176\":1,\"180\":1,\"181\":2,\"193\":1,\"197\":1,\"198\":1,\"203\":1,\"207\":1,\"208\":1,\"213\":1,\"217\":1,\"218\":1,\"223\":1,\"229\":1,\"230\":1,\"234\":1,\"247\":1,\"249\":1,\"251\":1,\"252\":1}}],[\"air001dev\",{\"1\":{\"7\":1}}],[\"air001debugtest\",{\"1\":{\"7\":2}}],[\"airisp支持烧录hex或bin格式的文件到芯片的\",{\"1\":{\"247\":1}}],[\"airisp\",{\"0\":{\"8\":1},\"1\":{\"8\":1,\"9\":9,\"247\":2,\"249\":6,\"251\":2,\"252\":2}}],[\"airm2m\",{\"1\":{\"7\":1,\"167\":1}}],[\"airmcu特有的接口\",{\"1\":{\"29\":1}}],[\"airmcu\",{\"0\":{\"0\":1,\"24\":1,\"27\":1,\"37\":1,\"104\":1,\"114\":1,\"138\":1},\"1\":{\"2\":1,\"7\":2,\"11\":1,\"14\":1,\"15\":1,\"18\":1,\"19\":1,\"27\":1,\"29\":1,\"43\":1,\"63\":1,\"66\":1,\"73\":1,\"74\":1,\"108\":1,\"109\":1,\"110\":1,\"114\":1,\"125\":1,\"138\":1,\"167\":1,\"199\":1}}],[\"az\",{\"1\":{\"194\":4}}],[\"ay\",{\"1\":{\"194\":4}}],[\"ax\",{\"1\":{\"194\":4}}],[\"again\",{\"1\":{\"161\":1}}],[\"appdata\",{\"1\":{\"147\":1,\"148\":4}}],[\"api接口\",{\"0\":{\"126\":1}}],[\"apis\",{\"0\":{\"109\":1}}],[\"api\",{\"0\":{\"34\":1,\"37\":1,\"44\":1,\"61\":1,\"75\":1,\"84\":1,\"92\":1,\"102\":1,\"104\":1,\"113\":1},\"1\":{\"29\":2,\"36\":1,\"73\":1,\"84\":1,\"100\":1,\"108\":1,\"109\":1,\"114\":1,\"115\":1,\"124\":2,\"127\":2,\"130\":2,\"139\":1}}],[\"api参考\",{\"1\":{\"12\":1}}],[\"accelscalefactor\",{\"1\":{\"194\":4}}],[\"account\",{\"1\":{\"126\":1}}],[\"active\",{\"1\":{\"127\":4}}],[\"af6\",{\"1\":{\"98\":7}}],[\"af12\",{\"1\":{\"98\":9}}],[\"af\",{\"1\":{\"98\":16}}],[\"after\",{\"0\":{\"230\":1},\"1\":{\"9\":1,\"52\":1,\"54\":1,\"126\":1,\"249\":1}}],[\"always\",{\"1\":{\"127\":2}}],[\"alternatefunction\",{\"1\":{\"127\":1}}],[\"already\",{\"1\":{\"126\":2}}],[\"all或者\",{\"1\":{\"242\":1,\"248\":1}}],[\"allocation\",{\"1\":{\"209\":2}}],[\"all\",{\"1\":{\"96\":1,\"126\":4}}],[\"also\",{\"1\":{\"54\":1}}],[\"about\",{\"0\":{\"59\":1}}],[\"asm\",{\"1\":{\"224\":2}}],[\"asynchronous\",{\"1\":{\"129\":1}}],[\"as\",{\"1\":{\"50\":1,\"96\":5,\"161\":1}}],[\"a\",{\"0\":{\"254\":1},\"1\":{\"46\":7,\"52\":1,\"96\":1,\"126\":1,\"127\":1,\"161\":2}}],[\"available\",{\"0\":{\"133\":1},\"1\":{\"96\":1,\"126\":2,\"133\":1,\"140\":1,\"204\":1}}],[\"avr\",{\"1\":{\"36\":1}}],[\"avref\",{\"1\":{\"35\":1}}],[\"avbat\",{\"1\":{\"35\":1}}],[\"another\",{\"1\":{\"123\":1,\"127\":1}}],[\"an\",{\"1\":{\"96\":3,\"126\":1,\"161\":1}}],[\"analogwriteresolution\",{\"0\":{\"106\":1},\"1\":{\"106\":1}}],[\"analogwritefrequency\",{\"0\":{\"105\":1},\"1\":{\"105\":1}}],[\"analogwrite\",{\"0\":{\"103\":1},\"1\":{\"103\":1,\"105\":1,\"106\":1}}],[\"analog\",{\"1\":{\"62\":1}}],[\"analogreference\",{\"0\":{\"36\":1},\"1\":{\"36\":1}}],[\"analogreadvref\",{\"0\":{\"41\":1},\"1\":{\"41\":1,\"167\":1}}],[\"analogreadtempsensor\",{\"0\":{\"40\":1},\"1\":{\"40\":1,\"167\":1}}],[\"analogreadmillivolts\",{\"0\":{\"39\":1},\"1\":{\"39\":1,\"167\":2}}],[\"analogreadresolution\",{\"0\":{\"38\":1},\"1\":{\"38\":1,\"167\":1}}],[\"analogread\",{\"0\":{\"35\":1},\"1\":{\"35\":1}}],[\"and\",{\"1\":{\"6\":1,\"9\":1,\"54\":1,\"123\":2,\"126\":4,\"127\":2,\"161\":1,\"214\":2,\"249\":1}}],[\"ado\",{\"1\":{\"193\":1}}],[\"adafruit\",{\"1\":{\"172\":2,\"177\":1,\"209\":2,\"214\":3}}],[\"adcgpioi2cpwm\",{\"1\":{\"109\":1}}],[\"adc的内部通道可以为atemp\",{\"1\":{\"35\":1}}],[\"adc\",{\"0\":{\"33\":1,\"34\":1,\"164\":1},\"1\":{\"33\":3,\"35\":8,\"38\":1,\"73\":1,\"108\":1,\"165\":1}}],[\"advanced\",{\"0\":{\"253\":1,\"255\":1},\"1\":{\"12\":1,\"126\":1}}],[\"addr\",{\"1\":{\"83\":1,\"89\":3,\"91\":1,\"96\":2,\"194\":5,\"204\":3}}],[\"address\",{\"1\":{\"45\":2,\"47\":2,\"49\":2,\"51\":2,\"52\":2,\"53\":2,\"54\":2,\"55\":2,\"83\":1,\"86\":2,\"88\":4,\"93\":2,\"96\":1,\"126\":1}}],[\"add\",{\"1\":{\"7\":1,\"126\":2}}],[\"attached\",{\"1\":{\"126\":2}}],[\"attaches\",{\"1\":{\"123\":2}}],[\"attach\",{\"1\":{\"126\":2,\"199\":1}}],[\"attachinterrupt\",{\"0\":{\"67\":1},\"1\":{\"67\":2,\"71\":1,\"126\":2,\"127\":2,\"184\":1}}],[\"attempts>\",{\"1\":{\"9\":1,\"249\":1}}],[\"attempts\",{\"0\":{\"228\":1},\"1\":{\"9\":1,\"249\":1}}],[\"at\",{\"1\":{\"9\":2,\"52\":1,\"247\":2}}],[\"autoreload\",{\"1\":{\"126\":2}}],[\"auto\",{\"1\":{\"9\":1,\"70\":2,\"71\":2,\"249\":1}}],[\"aur\",{\"1\":{\"9\":1,\"249\":1}}],[\"artx\",{\"1\":{\"138\":1}}],[\"art\",{\"1\":{\"138\":1,\"140\":5}}],[\"are\",{\"1\":{\"126\":1}}],[\"arm\",{\"1\":{\"27\":1}}],[\"arch包管理安装\",{\"1\":{\"249\":1}}],[\"arch\",{\"1\":{\"9\":3,\"249\":2}}],[\"arduinoide\",{\"1\":{\"148\":1}}],[\"arduino15全部替换成新建的文件夹路径即可\",{\"1\":{\"148\":1}}],[\"arduino15文件夹\",{\"1\":{\"147\":1}}],[\"arduino15\",{\"1\":{\"147\":1,\"148\":3}}],[\"arduino可以获取最新的ide目前版本是2\",{\"1\":{\"21\":1,\"22\":1}}],[\"arduino\",{\"0\":{\"20\":1,\"29\":1,\"113\":1},\"1\":{\"4\":1,\"6\":1,\"7\":1,\"16\":1,\"20\":2,\"25\":2,\"27\":1,\"29\":2,\"73\":1,\"83\":1,\"91\":1,\"100\":1,\"108\":1,\"114\":1,\"130\":2,\"145\":1,\"146\":2,\"148\":5,\"149\":2,\"165\":1,\"167\":1,\"197\":1,\"207\":1,\"229\":1}}],[\"搜索adafruit\",{\"1\":{\"214\":1}}],[\"搜索\",{\"1\":{\"4\":1}}],[\"vbus\",{\"1\":{\"218\":1,\"223\":1}}],[\"vbat电压\",{\"1\":{\"35\":1}}],[\"vcc\",{\"1\":{\"171\":1,\"176\":1,\"193\":1,\"203\":1,\"208\":2,\"213\":1,\"218\":1,\"223\":1}}],[\"vref\",{\"1\":{\"167\":1}}],[\"very\",{\"1\":{\"127\":1}}],[\"version\",{\"0\":{\"240\":1},\"1\":{\"9\":3,\"249\":3}}],[\"v\",{\"1\":{\"97\":1}}],[\"voltage\",{\"1\":{\"161\":2,\"167\":2}}],[\"volatile\",{\"1\":{\"71\":1}}],[\"void\",{\"0\":{\"116\":1,\"117\":1,\"118\":1,\"121\":2,\"122\":3},\"1\":{\"6\":2,\"36\":1,\"38\":1,\"40\":1,\"41\":1,\"46\":2,\"48\":2,\"50\":2,\"52\":2,\"54\":2,\"56\":2,\"62\":1,\"64\":1,\"67\":1,\"68\":1,\"70\":2,\"71\":3,\"77\":2,\"78\":2,\"79\":1,\"81\":1,\"86\":1,\"87\":1,\"89\":2,\"93\":1,\"94\":1,\"95\":1,\"96\":4,\"97\":2,\"103\":1,\"105\":1,\"106\":1,\"123\":1,\"124\":8,\"126\":25,\"131\":2,\"132\":1,\"136\":1,\"138\":2,\"139\":4,\"140\":2,\"141\":6,\"155\":2,\"161\":2,\"167\":2,\"172\":2,\"177\":2,\"182\":2,\"184\":3,\"189\":2,\"190\":1,\"194\":3,\"199\":2,\"204\":2,\"209\":4,\"214\":3,\"219\":2,\"224\":6}}],[\"variant\",{\"1\":{\"138\":1}}],[\"variable\",{\"1\":{\"52\":2,\"54\":1}}],[\"val\",{\"1\":{\"56\":4,\"126\":3}}],[\"valid\",{\"1\":{\"52\":1}}],[\"values\",{\"1\":{\"54\":1}}],[\"value要写入的数据\",{\"1\":{\"53\":1}}],[\"value要读取的数据\",{\"1\":{\"51\":1}}],[\"value\",{\"1\":{\"46\":3,\"47\":2,\"49\":2,\"50\":1,\"51\":1,\"53\":1,\"126\":6,\"127\":1,\"224\":4}}],[\"vuejs\",{\"1\":{\"13\":1}}],[\"vuepress\",{\"1\":{\"12\":2,\"13\":1}}],[\"v4\",{\"1\":{\"13\":1}}],[\"v1\",{\"1\":{\"9\":1,\"247\":1,\"251\":1,\"252\":1}}],[\"visualstudio\",{\"1\":{\"4\":1}}],[\"vscode文件夹下就会自动生成一个launch\",{\"1\":{\"7\":1}}],[\"vscode\",{\"0\":{\"1\":1,\"3\":1},\"1\":{\"2\":1,\"4\":1,\"7\":2}}],[\"在获取aiisp工具后\",{\"1\":{\"233\":1}}],[\"在最上方显示一行黑色的显示时长\",{\"1\":{\"215\":1}}],[\"在串口里输出得到的数据\",{\"1\":{\"204\":1}}],[\"在串口监视器中将波特率调至9600\",{\"1\":{\"173\":1,\"178\":1,\"195\":1,\"205\":1}}],[\"在串口监视器中可观察到当前串口输出和引脚上的实际电压\",{\"1\":{\"168\":1}}],[\"在上面代码的基础上\",{\"1\":{\"190\":1}}],[\"在这里\",{\"1\":{\"189\":1}}],[\"在这种情况下\",{\"1\":{\"140\":1}}],[\"在arduino的库管理中搜索并安装adafruit\",{\"1\":{\"214\":1}}],[\"在arduino中设置芯片主频\",{\"1\":{\"177\":1,\"224\":1}}],[\"在air001开发板上\",{\"1\":{\"188\":1}}],[\"在运行过程中上报的一种异常\",{\"1\":{\"184\":1}}],[\"在代码的开头定义一下全局变量\",{\"1\":{\"182\":1,\"184\":1}}],[\"在loop\",{\"1\":{\"172\":1,\"177\":1,\"199\":1}}],[\"在language选项卡下拉\",{\"1\":{\"23\":1}}],[\"在setup初始化函数中\",{\"1\":{\"224\":1}}],[\"在setup函数中添加如下代码\",{\"1\":{\"194\":1}}],[\"在setup\",{\"1\":{\"172\":1,\"177\":1,\"182\":1,\"184\":1,\"189\":1,\"199\":1,\"209\":1,\"219\":1}}],[\"在software\",{\"1\":{\"21\":1,\"22\":1}}],[\"在开发板中搜索pico\",{\"1\":{\"160\":1}}],[\"在开发板管理器中搜索pico\",{\"1\":{\"159\":1}}],[\"在开发板管理器中搜索air\",{\"1\":{\"26\":1}}],[\"在主函数中添加一些测试代码\",{\"1\":{\"155\":1,\"161\":1}}],[\"在主模式下\",{\"1\":{\"100\":1}}],[\"在文件路径栏中输入c\",{\"1\":{\"147\":1,\"148\":1}}],[\"在编译项目时\",{\"1\":{\"143\":1}}],[\"在编译时\",{\"1\":{\"100\":1}}],[\"在此通信模式下\",{\"1\":{\"140\":1}}],[\"在此模式下\",{\"1\":{\"60\":1,\"74\":1}}],[\"在嵌入式领域应用的非常广泛\",{\"1\":{\"129\":1}}],[\"在更新事件发生并生成中断时设置\",{\"1\":{\"127\":1}}],[\"在从模式下\",{\"1\":{\"100\":1}}],[\"在从机模式下\",{\"1\":{\"93\":1}}],[\"在调用\",{\"1\":{\"91\":1,\"127\":1}}],[\"在没有\",{\"1\":{\"87\":1}}],[\"在将消息写入缓冲区之前\",{\"1\":{\"86\":1}}],[\"在控制和监控应用中非常有用\",{\"1\":{\"33\":1}}],[\"在其它开发板管理器地址中输入airmcu的地址\",{\"1\":{\"25\":1}}],[\"在向我们发送\",{\"1\":{\"16\":1}}],[\"在自动生成的\",{\"1\":{\"7\":1}}],[\"在拥有\",{\"1\":{\"5\":1}}],[\"在\",{\"1\":{\"4\":1,\"7\":1,\"43\":1,\"130\":1,\"138\":2,\"140\":1,\"175\":1,\"181\":1}}],[\"switchcapvcc\",{\"1\":{\"209\":1}}],[\"screen\",{\"1\":{\"209\":6}}],[\"sclk\",{\"0\":{\"115\":1},\"1\":{\"115\":2,\"123\":1,\"124\":2,\"214\":2}}],[\"scl\",{\"1\":{\"78\":3,\"85\":2,\"97\":1,\"98\":1,\"171\":1,\"193\":1,\"203\":1,\"208\":1}}],[\"sht30是一款使用i²c通信接口的温湿度传感器\",{\"1\":{\"202\":1}}],[\"sht30\",{\"0\":{\"201\":1},\"1\":{\"203\":1,\"204\":4}}],[\"showtext\",{\"1\":{\"209\":2}}],[\"show\",{\"1\":{\"9\":2,\"249\":2}}],[\"sg90\",{\"1\":{\"198\":1}}],[\"sg90舵机一个\",{\"1\":{\"198\":1}}],[\"sg90舵机是一种位置\",{\"1\":{\"197\":1}}],[\"softserial\",{\"1\":{\"127\":1}}],[\"some\",{\"1\":{\"126\":1}}],[\"something\",{\"1\":{\"56\":1}}],[\"s\",{\"1\":{\"126\":1,\"138\":2,\"140\":5,\"194\":4}}],[\"subpriority\",{\"1\":{\"126\":1}}],[\"supplyvoltage=3v3\",{\"1\":{\"7\":1}}],[\"sprintf\",{\"1\":{\"214\":1}}],[\"specified\",{\"1\":{\"126\":6}}],[\"spi配置为2分频\",{\"1\":{\"224\":1}}],[\"spitransfermode\",{\"0\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1}}],[\"spisettings\",{\"0\":{\"117\":1}}],[\"spiclass\",{\"0\":{\"115\":2,\"116\":1},\"1\":{\"123\":1}}],[\"spi是一种事实标准\",{\"1\":{\"112\":1}}],[\"spi是一个单主机多从机的通信接口\",{\"1\":{\"112\":1}}],[\"spi准确来讲应为\",{\"1\":{\"112\":1}}],[\"spi设备之间使用全双工模式通信\",{\"1\":{\"112\":1}}],[\"spi\",{\"0\":{\"111\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"124\":1},\"1\":{\"108\":1,\"112\":1,\"113\":2,\"114\":4,\"115\":3,\"116\":2,\"117\":2,\"118\":4,\"119\":3,\"120\":3,\"121\":3,\"122\":3,\"123\":10,\"124\":1,\"223\":1,\"224\":13}}],[\"ssd1306库并进行安装\",{\"1\":{\"209\":1}}],[\"ssd1306库\",{\"1\":{\"209\":1}}],[\"ssd1306驱动\",{\"1\":{\"208\":1}}],[\"ssd1306\",{\"0\":{\"206\":1},\"1\":{\"208\":1,\"209\":5}}],[\"ssel\",{\"0\":{\"115\":1},\"1\":{\"115\":1,\"124\":2}}],[\"ssi\",{\"1\":{\"112\":1}}],[\"slave\",{\"1\":{\"89\":2}}],[\"sd卡与液晶显示器\",{\"1\":{\"112\":1}}],[\"sda引脚\",{\"1\":{\"194\":1}}],[\"sda\",{\"1\":{\"73\":1,\"77\":3,\"85\":2,\"97\":1,\"98\":1,\"171\":1,\"193\":1,\"203\":1,\"208\":1}}],[\"sdk\",{\"1\":{\"2\":1,\"7\":1}}],[\"simplify\",{\"1\":{\"127\":1}}],[\"simple\",{\"1\":{\"54\":1}}],[\"single\",{\"1\":{\"127\":1}}],[\"size\",{\"0\":{\"121\":1,\"122\":1},\"1\":{\"80\":3,\"83\":1,\"100\":1,\"135\":5,\"214\":1}}],[\"sizeof\",{\"1\":{\"52\":1,\"54\":1}}],[\"samplingtime\",{\"1\":{\"35\":2}}],[\"syu\",{\"1\":{\"9\":1,\"249\":1}}],[\"sym\",{\"1\":{\"7\":1}}],[\"symbols\",{\"1\":{\"6\":1}}],[\"sketch\",{\"1\":{\"7\":1,\"54\":1}}],[\"send\",{\"1\":{\"224\":2}}],[\"sendstop\",{\"1\":{\"87\":2,\"88\":4}}],[\"sensors\",{\"1\":{\"177\":4}}],[\"servo使用引脚pb\",{\"1\":{\"199\":1}}],[\"servo对象即可启动舵机\",{\"1\":{\"199\":1}}],[\"servo库为\",{\"1\":{\"199\":1}}],[\"servo\",{\"1\":{\"108\":1,\"125\":1,\"127\":2,\"199\":9}}],[\"serialdebugging在开头被定义为true\",{\"1\":{\"214\":1}}],[\"serialdebugging\",{\"1\":{\"214\":2}}],[\"serialn\",{\"1\":{\"138\":2}}],[\"serialeventx\",{\"1\":{\"138\":1}}],[\"seriallp1\",{\"1\":{\"138\":1}}],[\"serial4\",{\"1\":{\"138\":1}}],[\"serial3\",{\"1\":{\"138\":1}}],[\"serial2serialevent2\",{\"1\":{\"138\":1}}],[\"serial2\",{\"1\":{\"138\":7}}],[\"serial1\",{\"1\":{\"138\":3}}],[\"serialx\",{\"1\":{\"138\":3}}],[\"serial\",{\"0\":{\"139\":1},\"1\":{\"6\":2,\"46\":5,\"52\":9,\"54\":5,\"89\":4,\"96\":4,\"127\":1,\"138\":1,\"139\":1,\"155\":3,\"167\":5,\"172\":12,\"177\":8,\"182\":3,\"184\":3,\"194\":22,\"204\":4,\"209\":2,\"214\":3}}],[\"setdatamode的配置\",{\"1\":{\"224\":1}}],[\"setdatamode\",{\"1\":{\"224\":1}}],[\"setdebugoutput\",{\"1\":{\"89\":1}}],[\"setbitorder和spi\",{\"1\":{\"224\":1}}],[\"setbitorder\",{\"1\":{\"224\":1}}],[\"setfont\",{\"1\":{\"214\":1}}],[\"setrtscts\",{\"1\":{\"141\":2}}],[\"setrts\",{\"1\":{\"141\":2}}],[\"setrx\",{\"1\":{\"139\":2}}],[\"sethalfduplex\",{\"1\":{\"140\":1}}],[\"settextcolor\",{\"1\":{\"209\":1,\"214\":3}}],[\"settextsize\",{\"1\":{\"209\":1,\"214\":1}}],[\"settx\",{\"1\":{\"139\":2}}],[\"setting\",{\"1\":{\"126\":1}}],[\"settings\",{\"0\":{\"117\":1},\"1\":{\"117\":1,\"123\":4}}],[\"setinterruptpriority\",{\"1\":{\"126\":1}}],[\"setcursor\",{\"1\":{\"209\":1,\"214\":2}}],[\"setcts\",{\"1\":{\"141\":2}}],[\"setcapturecompare\",{\"1\":{\"126\":1}}],[\"setcount\",{\"1\":{\"126\":1}}],[\"setclockdivider函数\",{\"1\":{\"224\":1}}],[\"setclockdivider\",{\"1\":{\"224\":1}}],[\"setclock\",{\"0\":{\"79\":1},\"1\":{\"79\":1}}],[\"setpreloadenable\",{\"1\":{\"126\":1}}],[\"setprescalefactor\",{\"1\":{\"126\":1}}],[\"setpwm\",{\"1\":{\"126\":2}}],[\"setoverflow\",{\"1\":{\"126\":1,\"127\":3}}],[\"set\",{\"1\":{\"126\":8,\"127\":2,\"219\":1}}],[\"setmode\",{\"1\":{\"126\":2}}],[\"setmosi\",{\"1\":{\"124\":2}}],[\"setmiso\",{\"1\":{\"124\":2}}],[\"setssel\",{\"1\":{\"124\":2}}],[\"setsclk\",{\"1\":{\"124\":2}}],[\"setscl\",{\"0\":{\"78\":1},\"1\":{\"78\":3,\"194\":1,\"204\":1}}],[\"setsda\",{\"0\":{\"77\":1},\"1\":{\"77\":2,\"78\":1,\"194\":1,\"204\":1}}],[\"setup\",{\"1\":{\"6\":1,\"46\":1,\"48\":1,\"50\":1,\"52\":1,\"54\":1,\"56\":1,\"70\":1,\"71\":1,\"89\":1,\"96\":3,\"97\":2,\"123\":1,\"138\":2,\"155\":2,\"161\":2,\"167\":1,\"172\":1,\"177\":1,\"182\":1,\"184\":1,\"189\":1,\"194\":1,\"199\":1,\"204\":1,\"209\":1,\"214\":1,\"219\":1,\"224\":1}}],[\"see\",{\"1\":{\"54\":1,\"96\":2,\"127\":4}}],[\"seconds\",{\"1\":{\"127\":1}}],[\"second\",{\"1\":{\"54\":1,\"123\":1,\"161\":2}}],[\"strcpy\",{\"1\":{\"214\":1}}],[\"strcmp\",{\"1\":{\"214\":1}}],[\"structures\",{\"1\":{\"52\":1,\"54\":1}}],[\"struct\",{\"1\":{\"52\":1,\"54\":1}}],[\"st7789\",{\"1\":{\"214\":2}}],[\"st7735的对象tft\",{\"1\":{\"214\":1}}],[\"st7735是一款具有spi接口的彩色tft液晶显示驱动芯片\",{\"1\":{\"212\":1}}],[\"st7735\",{\"0\":{\"211\":1},\"1\":{\"213\":1,\"214\":6}}],[\"still\",{\"1\":{\"126\":1}}],[\"stopbit\",{\"1\":{\"87\":2}}],[\"store\",{\"1\":{\"52\":2,\"54\":2}}],[\"staging\",{\"1\":{\"148\":2}}],[\"static\",{\"1\":{\"126\":2,\"155\":1}}],[\"state\",{\"1\":{\"71\":4,\"182\":3}}],[\"stateled^1\",{\"1\":{\"70\":1}}],[\"stateled\",{\"1\":{\"70\":3}}],[\"start\",{\"1\":{\"52\":1,\"96\":1}}],[\"started\",{\"1\":{\"12\":1,\"13\":1}}],[\"styles\",{\"1\":{\"12\":1}}],[\"st\",{\"1\":{\"2\":1}}],[\"等待测量数据\",{\"1\":{\"204\":1}}],[\"等待编译并上传测试代码\",{\"1\":{\"156\":1,\"162\":1}}],[\"等\",{\"1\":{\"2\":1}}],[\"dtr\",{\"1\":{\"229\":1}}],[\"dc连接gnd则i²c从机地址为0x3c\",{\"1\":{\"208\":1}}],[\"dc连接vcc则i²c从机地址为0x3d\",{\"1\":{\"208\":1}}],[\"dc连接可以决定i²c从机地址\",{\"1\":{\"208\":1}}],[\"dc\",{\"1\":{\"208\":1,\"213\":1,\"214\":2}}],[\"d1\",{\"1\":{\"208\":1}}],[\"d0\",{\"1\":{\"208\":1}}],[\"d℃\",{\"1\":{\"204\":1}}],[\"dq\",{\"1\":{\"176\":1}}],[\"ds18b20\",{\"0\":{\"174\":1},\"1\":{\"175\":2,\"176\":1}}],[\"d\",{\"1\":{\"146\":1,\"148\":3,\"149\":1,\"155\":1,\"167\":4,\"204\":1}}],[\"dpin\",{\"1\":{\"138\":2}}],[\"duplex\",{\"1\":{\"140\":2}}],[\"due\",{\"1\":{\"127\":1}}],[\"duty\",{\"1\":{\"126\":1,\"127\":1}}],[\"dutycycle\",{\"1\":{\"126\":2,\"127\":4}}],[\"duino\",{\"1\":{\"25\":1,\"31\":1}}],[\"drain\",{\"1\":{\"62\":1}}],[\"dat\",{\"1\":{\"213\":1}}],[\"datasheet\",{\"0\":{\"110\":1}}],[\"data\",{\"0\":{\"119\":1,\"120\":1},\"1\":{\"52\":3,\"54\":4,\"80\":4,\"83\":1,\"96\":2,\"98\":16,\"99\":1,\"119\":1,\"120\":1,\"123\":2,\"135\":2,\"148\":2,\"194\":9,\"204\":6}}],[\"days\",{\"1\":{\"214\":2}}],[\"day\",{\"1\":{\"209\":1}}],[\"dallastemperature\",{\"1\":{\"177\":3}}],[\"dac\",{\"1\":{\"73\":1,\"108\":1}}],[\"daplink\",{\"1\":{\"2\":1,\"166\":1}}],[\"dap\",{\"1\":{\"2\":1}}],[\"double\",{\"1\":{\"194\":8}}],[\"documents\",{\"1\":{\"148\":2}}],[\"docs\",{\"0\":{\"257\":1},\"1\":{\"12\":2}}],[\"doesn\",{\"1\":{\"127\":1}}],[\"do\",{\"1\":{\"56\":1}}],[\"downloads\",{\"1\":{\"148\":2}}],[\"download\",{\"1\":{\"25\":1}}],[\"download仅下载\",{\"1\":{\"21\":1}}],[\"direct\",{\"1\":{\"229\":1,\"230\":1}}],[\"directories\",{\"1\":{\"148\":2}}],[\"din\",{\"1\":{\"223\":1}}],[\"dio\",{\"1\":{\"218\":1,\"219\":2}}],[\"display的zip包到本地目录\",{\"1\":{\"219\":1}}],[\"display库来驱动数码管模块\",{\"1\":{\"219\":1}}],[\"displayuptime\",{\"1\":{\"214\":2}}],[\"display\",{\"1\":{\"209\":10,\"214\":16,\"219\":4}}],[\"disconnected\",{\"1\":{\"177\":1}}],[\"disabled\",{\"1\":{\"123\":1,\"126\":1,\"127\":2,\"140\":1}}],[\"dist\",{\"1\":{\"12\":1}}],[\"div2\",{\"1\":{\"224\":1}}],[\"div\",{\"1\":{\"35\":1}}],[\"digitalpintointerrupt\",{\"1\":{\"71\":1,\"184\":1}}],[\"digitalread\",{\"0\":{\"65\":1},\"1\":{\"65\":2,\"70\":1,\"182\":1,\"184\":1}}],[\"digital\",{\"1\":{\"33\":1,\"141\":2,\"161\":1}}],[\"digitalwrite\",{\"0\":{\"64\":1},\"1\":{\"6\":2,\"64\":2,\"70\":1,\"71\":1,\"155\":2,\"161\":2,\"184\":2,\"189\":6,\"190\":6}}],[\"dbg=enable\",{\"1\":{\"7\":1}}],[\"denable\",{\"1\":{\"138\":2}}],[\"deinitialization\",{\"1\":{\"126\":1}}],[\"depending\",{\"1\":{\"126\":6}}],[\"deploy\",{\"1\":{\"12\":1}}],[\"definition\",{\"1\":{\"127\":1}}],[\"defined\",{\"1\":{\"126\":1}}],[\"define\",{\"1\":{\"89\":1,\"96\":1,\"138\":2,\"182\":1,\"184\":1,\"204\":1,\"209\":3,\"214\":6,\"219\":2,\"224\":1}}],[\"default\",{\"1\":{\"9\":5,\"123\":1,\"127\":2,\"229\":1,\"230\":1,\"249\":5}}],[\"detachinterrupt\",{\"0\":{\"68\":1},\"1\":{\"68\":2,\"126\":2,\"127\":2}}],[\"designed\",{\"1\":{\"54\":1}}],[\"description\",{\"1\":{\"9\":1,\"113\":1,\"249\":1}}],[\"delaymicroseconds\",{\"1\":{\"224\":1}}],[\"delay\",{\"1\":{\"6\":2,\"46\":1,\"89\":1,\"97\":1,\"138\":1,\"155\":1,\"161\":2,\"167\":1,\"172\":1,\"177\":1,\"184\":2,\"189\":2,\"190\":3,\"194\":1,\"199\":5,\"204\":3,\"214\":2,\"224\":2}}],[\"device\",{\"1\":{\"123\":2,\"177\":1}}],[\"dev\",{\"1\":{\"6\":1,\"83\":1,\"89\":3,\"91\":1,\"98\":1,\"189\":1,\"235\":1}}],[\"develop\",{\"1\":{\"5\":2}}],[\"debug安装即可\",{\"1\":{\"4\":1}}],[\"debug\",{\"0\":{\"1\":1},\"1\":{\"4\":1,\"6\":1,\"7\":1,\"227\":1}}],[\"cyan\",{\"1\":{\"214\":1}}],[\"ctemp\",{\"1\":{\"204\":2}}],[\"cts\",{\"1\":{\"141\":8}}],[\"cpu\",{\"1\":{\"184\":1}}],[\"c++\",{\"1\":{\"127\":1}}],[\"cc1ne\",{\"1\":{\"126\":1}}],[\"ccer\",{\"1\":{\"126\":1}}],[\"current\",{\"1\":{\"126\":1}}],[\"customvar\",{\"1\":{\"52\":5,\"54\":2}}],[\"custom\",{\"1\":{\"52\":3,\"54\":2}}],[\"cs\",{\"1\":{\"114\":6,\"115\":3,\"116\":1,\"117\":2,\"118\":6,\"119\":3,\"120\":3,\"121\":3,\"122\":3,\"123\":3,\"208\":1,\"213\":1,\"214\":2}}],[\"cb\",{\"1\":{\"94\":1,\"95\":1}}],[\"caputre\",{\"1\":{\"126\":1}}],[\"capturecompare\",{\"1\":{\"127\":4}}],[\"capturecomparecallback\",{\"1\":{\"126\":1}}],[\"capture\",{\"1\":{\"126\":2,\"127\":4}}],[\"called\",{\"1\":{\"126\":2}}],[\"callback\",{\"1\":{\"67\":3,\"94\":1,\"95\":1,\"126\":16,\"127\":7}}],[\"call\",{\"1\":{\"54\":1,\"126\":2,\"127\":3}}],[\"can\",{\"1\":{\"52\":1,\"54\":1,\"127\":1}}],[\"ch4\",{\"1\":{\"127\":1}}],[\"ch3\",{\"1\":{\"127\":1}}],[\"ch2\",{\"1\":{\"127\":1}}],[\"ch1\",{\"1\":{\"127\":1}}],[\"chapter\",{\"1\":{\"127\":2}}],[\"channels\",{\"1\":{\"126\":3,\"127\":2}}],[\"channel\",{\"1\":{\"68\":2,\"126\":25,\"127\":20}}],[\"change\",{\"1\":{\"67\":1,\"71\":1,\"184\":2}}],[\"character\",{\"1\":{\"96\":2}}],[\"char\",{\"1\":{\"52\":1,\"54\":1,\"56\":1,\"96\":1,\"204\":1,\"214\":2,\"224\":5}}],[\"chip\",{\"0\":{\"234\":1,\"238\":1},\"1\":{\"9\":3,\"167\":1,\"189\":1,\"247\":1,\"249\":2}}],[\"chip为例\",{\"1\":{\"6\":1}}],[\"cell\",{\"1\":{\"50\":2,\"56\":2}}],[\"circuit\",{\"1\":{\"73\":1}}],[\"ci\",{\"1\":{\"25\":1}}],[\"cn\",{\"1\":{\"25\":1,\"28\":3}}],[\"clk\",{\"1\":{\"213\":1,\"218\":1,\"219\":2}}],[\"cleardisplay清空屏幕信息\",{\"1\":{\"209\":1}}],[\"cleardisplay\",{\"1\":{\"209\":2}}],[\"cli\",{\"1\":{\"148\":1}}],[\"client\",{\"1\":{\"12\":1}}],[\"clock\",{\"1\":{\"35\":1,\"126\":1,\"127\":1,\"224\":1}}],[\"clocksourceandfrequency=hsi24m\",{\"1\":{\"7\":1}}],[\"c\",{\"0\":{\"234\":1},\"1\":{\"9\":2,\"96\":2,\"98\":2,\"99\":1,\"138\":2,\"140\":1,\"148\":5,\"167\":1,\"177\":1,\"247\":1,\"249\":1,\"251\":1,\"252\":1}}],[\"color\",{\"1\":{\"214\":16}}],[\"code\",{\"1\":{\"155\":2}}],[\"count++\",{\"1\":{\"155\":1,\"224\":1}}],[\"counts\",{\"1\":{\"127\":1}}],[\"counterreset\",{\"1\":{\"127\":1}}],[\"counter\",{\"1\":{\"126\":4,\"127\":8}}],[\"count\",{\"0\":{\"121\":1,\"122\":1},\"1\":{\"121\":1,\"122\":1,\"127\":1,\"155\":3,\"224\":7}}],[\"conf\",{\"1\":{\"100\":1}}],[\"configured\",{\"1\":{\"123\":1,\"126\":1}}],[\"configure\",{\"1\":{\"123\":1,\"126\":2}}],[\"configuration\",{\"1\":{\"6\":1,\"7\":1,\"126\":1,\"127\":1}}],[\"config\",{\"1\":{\"12\":1,\"131\":2}}],[\"const\",{\"1\":{\"70\":2,\"71\":2,\"80\":1,\"98\":2,\"135\":1,\"194\":3,\"214\":10}}],[\"continue\",{\"1\":{\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1}}],[\"contents\",{\"1\":{\"56\":1}}],[\"contributionsguide\",{\"1\":{\"12\":1}}],[\"converter\",{\"1\":{\"33\":1}}],[\"connect>\",{\"0\":{\"229\":1,\"230\":1}}],[\"connect\",{\"0\":{\"228\":1},\"1\":{\"9\":1,\"52\":1,\"54\":1,\"229\":1,\"230\":1,\"249\":1}}],[\"cortex\",{\"1\":{\"4\":1,\"27\":1}}],[\"computedautomatically\",{\"1\":{\"127\":1}}],[\"compatibility\",{\"1\":{\"127\":1}}],[\"comparecallback\",{\"1\":{\"126\":2}}],[\"compare\",{\"1\":{\"56\":1,\"126\":11,\"127\":25}}],[\"com21\",{\"1\":{\"9\":2,\"247\":2,\"251\":2,\"252\":2}}],[\"commands\",{\"1\":{\"9\":1,\"249\":1}}],[\"command\",{\"1\":{\"9\":1,\"126\":1,\"249\":1}}],[\"com\",{\"1\":{\"4\":1,\"5\":1,\"25\":2}}],[\"cmsis\",{\"1\":{\"2\":1,\"127\":1}}],[\"crotex\",{\"0\":{\"1\":1}}],[\"安装dallastemperature库\",{\"1\":{\"177\":1}}],[\"安装air\",{\"1\":{\"189\":1}}],[\"安装adafruit\",{\"1\":{\"172\":1,\"209\":1}}],[\"安装arduino\",{\"1\":{\"159\":1}}],[\"安装arduino插件\",{\"1\":{\"4\":1}}],[\"安装过程需要安装多个工具链\",{\"1\":{\"26\":1,\"159\":1}}],[\"安装最新版即可\",{\"1\":{\"26\":1}}],[\"安装开发板\",{\"0\":{\"26\":1,\"159\":1}}],[\"安装后命令行为\",{\"1\":{\"9\":1,\"249\":1}}],[\"安装插件\",{\"0\":{\"4\":1}}],[\"安装pyocd\",{\"1\":{\"2\":1}}],[\"安装\",{\"0\":{\"5\":1,\"19\":1,\"24\":1,\"249\":1},\"1\":{\"2\":2,\"5\":1,\"167\":1}}],[\"先决条件\",{\"0\":{\"2\":1}}],[\"的内容\",{\"1\":{\"244\":1}}],[\"的读保护打开\",{\"1\":{\"251\":1}}],[\"的读保护\",{\"1\":{\"243\":1,\"244\":1,\"251\":1,\"252\":1}}],[\"的指定地址开始\",{\"1\":{\"241\":1,\"245\":1}}],[\"的串口查看器\",{\"1\":{\"229\":1}}],[\"的控制时序\",{\"1\":{\"224\":1}}],[\"的时序要求相对严格\",{\"1\":{\"223\":1}}],[\"的连接\",{\"1\":{\"183\":1}}],[\"的状态符合某种条件时\",{\"1\":{\"184\":1}}],[\"的状态\",{\"1\":{\"182\":1}}],[\"的状态设置为\",{\"1\":{\"64\":1}}],[\"的大气压\",{\"1\":{\"170\":1}}],[\"的参考手册\",{\"1\":{\"125\":1}}],[\"的第二个参数启用\",{\"1\":{\"99\":1}}],[\"的示例\",{\"1\":{\"89\":1,\"96\":1,\"138\":1}}],[\"的情况下调用此函数相当于\",{\"1\":{\"87\":1}}],[\"的给定引脚的状态\",{\"1\":{\"65\":1}}],[\"的最后一个\",{\"1\":{\"43\":1}}],[\"的安装\",{\"0\":{\"20\":1}}],[\"的相关安装方式\",{\"1\":{\"19\":1}}],[\"的提交被挤压到之前的提交中\",{\"1\":{\"16\":1}}],[\"的附加组件和语法\",{\"1\":{\"13\":1}}],[\"的插件市场中搜索cortex\",{\"1\":{\"4\":1}}],[\"的配置\",{\"0\":{\"3\":1}}],[\"的\",{\"0\":{\"1\":1},\"1\":{\"2\":1,\"7\":2,\"27\":1,\"36\":1,\"166\":1,\"223\":1}}],[\"的调试方法\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
